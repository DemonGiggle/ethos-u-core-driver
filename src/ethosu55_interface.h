/*
 * Copyright (c) 2019-2020 Arm Limited. All rights reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the License); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#ifdef __KERNEL__
#include <linux/types.h>
#else
#include <stdint.h>
#endif

#ifdef MODEL_REGS
#include "core/simple_types.h"
#endif

#if !defined(__cplusplus) || __cplusplus < 201402L
#define CONSTEXPR
#else
#define CONSTEXPR constexpr
#endif

#ifndef __cplusplus
#define STRUCT struct
#else
#define STRUCT
#include <stdexcept>
#endif

#define NNX_ARCH_VERSION_MAJOR 0
#define NNX_ARCH_VERSION_MINOR 154
#define NNX_ARCH_VERSION_PATCH 0
#define NNX_ARCH_BASENAME "ULTAN"

// Register offsets

//
// Register subpage DEBUG_INTERNAL
//
#define NPU_REG_SHARED_BUFFER0 0x0400
#define NPU_REG_SHARED_BUFFER1 0x0404
#define NPU_REG_SHARED_BUFFER2 0x0408
#define NPU_REG_SHARED_BUFFER3 0x040C
#define NPU_REG_SHARED_BUFFER4 0x0410
#define NPU_REG_SHARED_BUFFER5 0x0414
#define NPU_REG_SHARED_BUFFER6 0x0418
#define NPU_REG_SHARED_BUFFER7 0x041C
#define NPU_REG_SHARED_BUFFER8 0x0420
#define NPU_REG_SHARED_BUFFER9 0x0424
#define NPU_REG_SHARED_BUFFER10 0x0428
#define NPU_REG_SHARED_BUFFER11 0x042C
#define NPU_REG_SHARED_BUFFER12 0x0430
#define NPU_REG_SHARED_BUFFER13 0x0434
#define NPU_REG_SHARED_BUFFER14 0x0438
#define NPU_REG_SHARED_BUFFER15 0x043C
#define NPU_REG_SHARED_BUFFER16 0x0440
#define NPU_REG_SHARED_BUFFER17 0x0444
#define NPU_REG_SHARED_BUFFER18 0x0448
#define NPU_REG_SHARED_BUFFER19 0x044C
#define NPU_REG_SHARED_BUFFER20 0x0450
#define NPU_REG_SHARED_BUFFER21 0x0454
#define NPU_REG_SHARED_BUFFER22 0x0458
#define NPU_REG_SHARED_BUFFER23 0x045C
#define NPU_REG_SHARED_BUFFER24 0x0460
#define NPU_REG_SHARED_BUFFER25 0x0464
#define NPU_REG_SHARED_BUFFER26 0x0468
#define NPU_REG_SHARED_BUFFER27 0x046C
#define NPU_REG_SHARED_BUFFER28 0x0470
#define NPU_REG_SHARED_BUFFER29 0x0474
#define NPU_REG_SHARED_BUFFER30 0x0478
#define NPU_REG_SHARED_BUFFER31 0x047C
#define NPU_REG_SHARED_BUFFER32 0x0480
#define NPU_REG_SHARED_BUFFER33 0x0484
#define NPU_REG_SHARED_BUFFER34 0x0488
#define NPU_REG_SHARED_BUFFER35 0x048C
#define NPU_REG_SHARED_BUFFER36 0x0490
#define NPU_REG_SHARED_BUFFER37 0x0494
#define NPU_REG_SHARED_BUFFER38 0x0498
#define NPU_REG_SHARED_BUFFER39 0x049C
#define NPU_REG_SHARED_BUFFER40 0x04A0
#define NPU_REG_SHARED_BUFFER41 0x04A4
#define NPU_REG_SHARED_BUFFER42 0x04A8
#define NPU_REG_SHARED_BUFFER43 0x04AC
#define NPU_REG_SHARED_BUFFER44 0x04B0
#define NPU_REG_SHARED_BUFFER45 0x04B4
#define NPU_REG_SHARED_BUFFER46 0x04B8
#define NPU_REG_SHARED_BUFFER47 0x04BC
#define NPU_REG_SHARED_BUFFER48 0x04C0
#define NPU_REG_SHARED_BUFFER49 0x04C4
#define NPU_REG_SHARED_BUFFER50 0x04C8
#define NPU_REG_SHARED_BUFFER51 0x04CC
#define NPU_REG_SHARED_BUFFER52 0x04D0
#define NPU_REG_SHARED_BUFFER53 0x04D4
#define NPU_REG_SHARED_BUFFER54 0x04D8
#define NPU_REG_SHARED_BUFFER55 0x04DC
#define NPU_REG_SHARED_BUFFER56 0x04E0
#define NPU_REG_SHARED_BUFFER57 0x04E4
#define NPU_REG_SHARED_BUFFER58 0x04E8
#define NPU_REG_SHARED_BUFFER59 0x04EC
#define NPU_REG_SHARED_BUFFER60 0x04F0
#define NPU_REG_SHARED_BUFFER61 0x04F4
#define NPU_REG_SHARED_BUFFER62 0x04F8
#define NPU_REG_SHARED_BUFFER63 0x04FC
#define NPU_REG_SHARED_BUFFER64 0x0500
#define NPU_REG_SHARED_BUFFER65 0x0504
#define NPU_REG_SHARED_BUFFER66 0x0508
#define NPU_REG_SHARED_BUFFER67 0x050C
#define NPU_REG_SHARED_BUFFER68 0x0510
#define NPU_REG_SHARED_BUFFER69 0x0514
#define NPU_REG_SHARED_BUFFER70 0x0518
#define NPU_REG_SHARED_BUFFER71 0x051C
#define NPU_REG_SHARED_BUFFER72 0x0520
#define NPU_REG_SHARED_BUFFER73 0x0524
#define NPU_REG_SHARED_BUFFER74 0x0528
#define NPU_REG_SHARED_BUFFER75 0x052C
#define NPU_REG_SHARED_BUFFER76 0x0530
#define NPU_REG_SHARED_BUFFER77 0x0534
#define NPU_REG_SHARED_BUFFER78 0x0538
#define NPU_REG_SHARED_BUFFER79 0x053C
#define NPU_REG_SHARED_BUFFER80 0x0540
#define NPU_REG_SHARED_BUFFER81 0x0544
#define NPU_REG_SHARED_BUFFER82 0x0548
#define NPU_REG_SHARED_BUFFER83 0x054C
#define NPU_REG_SHARED_BUFFER84 0x0550
#define NPU_REG_SHARED_BUFFER85 0x0554
#define NPU_REG_SHARED_BUFFER86 0x0558
#define NPU_REG_SHARED_BUFFER87 0x055C
#define NPU_REG_SHARED_BUFFER88 0x0560
#define NPU_REG_SHARED_BUFFER89 0x0564
#define NPU_REG_SHARED_BUFFER90 0x0568
#define NPU_REG_SHARED_BUFFER91 0x056C
#define NPU_REG_SHARED_BUFFER92 0x0570
#define NPU_REG_SHARED_BUFFER93 0x0574
#define NPU_REG_SHARED_BUFFER94 0x0578
#define NPU_REG_SHARED_BUFFER95 0x057C
#define NPU_REG_SHARED_BUFFER96 0x0580
#define NPU_REG_SHARED_BUFFER97 0x0584
#define NPU_REG_SHARED_BUFFER98 0x0588
#define NPU_REG_SHARED_BUFFER99 0x058C
#define NPU_REG_SHARED_BUFFER100 0x0590
#define NPU_REG_SHARED_BUFFER101 0x0594
#define NPU_REG_SHARED_BUFFER102 0x0598
#define NPU_REG_SHARED_BUFFER103 0x059C
#define NPU_REG_SHARED_BUFFER104 0x05A0
#define NPU_REG_SHARED_BUFFER105 0x05A4
#define NPU_REG_SHARED_BUFFER106 0x05A8
#define NPU_REG_SHARED_BUFFER107 0x05AC
#define NPU_REG_SHARED_BUFFER108 0x05B0
#define NPU_REG_SHARED_BUFFER109 0x05B4
#define NPU_REG_SHARED_BUFFER110 0x05B8
#define NPU_REG_SHARED_BUFFER111 0x05BC
#define NPU_REG_SHARED_BUFFER112 0x05C0
#define NPU_REG_SHARED_BUFFER113 0x05C4
#define NPU_REG_SHARED_BUFFER114 0x05C8
#define NPU_REG_SHARED_BUFFER115 0x05CC
#define NPU_REG_SHARED_BUFFER116 0x05D0
#define NPU_REG_SHARED_BUFFER117 0x05D4
#define NPU_REG_SHARED_BUFFER118 0x05D8
#define NPU_REG_SHARED_BUFFER119 0x05DC
#define NPU_REG_SHARED_BUFFER120 0x05E0
#define NPU_REG_SHARED_BUFFER121 0x05E4
#define NPU_REG_SHARED_BUFFER122 0x05E8
#define NPU_REG_SHARED_BUFFER123 0x05EC
#define NPU_REG_SHARED_BUFFER124 0x05F0
#define NPU_REG_SHARED_BUFFER125 0x05F4
#define NPU_REG_SHARED_BUFFER126 0x05F8
#define NPU_REG_SHARED_BUFFER127 0x05FC
#define NPU_REG_SHARED_BUFFER128 0x0600
#define NPU_REG_SHARED_BUFFER129 0x0604
#define NPU_REG_SHARED_BUFFER130 0x0608
#define NPU_REG_SHARED_BUFFER131 0x060C
#define NPU_REG_SHARED_BUFFER132 0x0610
#define NPU_REG_SHARED_BUFFER133 0x0614
#define NPU_REG_SHARED_BUFFER134 0x0618
#define NPU_REG_SHARED_BUFFER135 0x061C
#define NPU_REG_SHARED_BUFFER136 0x0620
#define NPU_REG_SHARED_BUFFER137 0x0624
#define NPU_REG_SHARED_BUFFER138 0x0628
#define NPU_REG_SHARED_BUFFER139 0x062C
#define NPU_REG_SHARED_BUFFER140 0x0630
#define NPU_REG_SHARED_BUFFER141 0x0634
#define NPU_REG_SHARED_BUFFER142 0x0638
#define NPU_REG_SHARED_BUFFER143 0x063C
#define NPU_REG_SHARED_BUFFER144 0x0640
#define NPU_REG_SHARED_BUFFER145 0x0644
#define NPU_REG_SHARED_BUFFER146 0x0648
#define NPU_REG_SHARED_BUFFER147 0x064C
#define NPU_REG_SHARED_BUFFER148 0x0650
#define NPU_REG_SHARED_BUFFER149 0x0654
#define NPU_REG_SHARED_BUFFER150 0x0658
#define NPU_REG_SHARED_BUFFER151 0x065C
#define NPU_REG_SHARED_BUFFER152 0x0660
#define NPU_REG_SHARED_BUFFER153 0x0664
#define NPU_REG_SHARED_BUFFER154 0x0668
#define NPU_REG_SHARED_BUFFER155 0x066C
#define NPU_REG_SHARED_BUFFER156 0x0670
#define NPU_REG_SHARED_BUFFER157 0x0674
#define NPU_REG_SHARED_BUFFER158 0x0678
#define NPU_REG_SHARED_BUFFER159 0x067C
#define NPU_REG_SHARED_BUFFER160 0x0680
#define NPU_REG_SHARED_BUFFER161 0x0684
#define NPU_REG_SHARED_BUFFER162 0x0688
#define NPU_REG_SHARED_BUFFER163 0x068C
#define NPU_REG_SHARED_BUFFER164 0x0690
#define NPU_REG_SHARED_BUFFER165 0x0694
#define NPU_REG_SHARED_BUFFER166 0x0698
#define NPU_REG_SHARED_BUFFER167 0x069C
#define NPU_REG_SHARED_BUFFER168 0x06A0
#define NPU_REG_SHARED_BUFFER169 0x06A4
#define NPU_REG_SHARED_BUFFER170 0x06A8
#define NPU_REG_SHARED_BUFFER171 0x06AC
#define NPU_REG_SHARED_BUFFER172 0x06B0
#define NPU_REG_SHARED_BUFFER173 0x06B4
#define NPU_REG_SHARED_BUFFER174 0x06B8
#define NPU_REG_SHARED_BUFFER175 0x06BC
#define NPU_REG_SHARED_BUFFER176 0x06C0
#define NPU_REG_SHARED_BUFFER177 0x06C4
#define NPU_REG_SHARED_BUFFER178 0x06C8
#define NPU_REG_SHARED_BUFFER179 0x06CC
#define NPU_REG_SHARED_BUFFER180 0x06D0
#define NPU_REG_SHARED_BUFFER181 0x06D4
#define NPU_REG_SHARED_BUFFER182 0x06D8
#define NPU_REG_SHARED_BUFFER183 0x06DC
#define NPU_REG_SHARED_BUFFER184 0x06E0
#define NPU_REG_SHARED_BUFFER185 0x06E4
#define NPU_REG_SHARED_BUFFER186 0x06E8
#define NPU_REG_SHARED_BUFFER187 0x06EC
#define NPU_REG_SHARED_BUFFER188 0x06F0
#define NPU_REG_SHARED_BUFFER189 0x06F4
#define NPU_REG_SHARED_BUFFER190 0x06F8
#define NPU_REG_SHARED_BUFFER191 0x06FC
#define NPU_REG_SHARED_BUFFER192 0x0700
#define NPU_REG_SHARED_BUFFER193 0x0704
#define NPU_REG_SHARED_BUFFER194 0x0708
#define NPU_REG_SHARED_BUFFER195 0x070C
#define NPU_REG_SHARED_BUFFER196 0x0710
#define NPU_REG_SHARED_BUFFER197 0x0714
#define NPU_REG_SHARED_BUFFER198 0x0718
#define NPU_REG_SHARED_BUFFER199 0x071C
#define NPU_REG_SHARED_BUFFER200 0x0720
#define NPU_REG_SHARED_BUFFER201 0x0724
#define NPU_REG_SHARED_BUFFER202 0x0728
#define NPU_REG_SHARED_BUFFER203 0x072C
#define NPU_REG_SHARED_BUFFER204 0x0730
#define NPU_REG_SHARED_BUFFER205 0x0734
#define NPU_REG_SHARED_BUFFER206 0x0738
#define NPU_REG_SHARED_BUFFER207 0x073C
#define NPU_REG_SHARED_BUFFER208 0x0740
#define NPU_REG_SHARED_BUFFER209 0x0744
#define NPU_REG_SHARED_BUFFER210 0x0748
#define NPU_REG_SHARED_BUFFER211 0x074C
#define NPU_REG_SHARED_BUFFER212 0x0750
#define NPU_REG_SHARED_BUFFER213 0x0754
#define NPU_REG_SHARED_BUFFER214 0x0758
#define NPU_REG_SHARED_BUFFER215 0x075C
#define NPU_REG_SHARED_BUFFER216 0x0760
#define NPU_REG_SHARED_BUFFER217 0x0764
#define NPU_REG_SHARED_BUFFER218 0x0768
#define NPU_REG_SHARED_BUFFER219 0x076C
#define NPU_REG_SHARED_BUFFER220 0x0770
#define NPU_REG_SHARED_BUFFER221 0x0774
#define NPU_REG_SHARED_BUFFER222 0x0778
#define NPU_REG_SHARED_BUFFER223 0x077C
#define NPU_REG_SHARED_BUFFER224 0x0780
#define NPU_REG_SHARED_BUFFER225 0x0784
#define NPU_REG_SHARED_BUFFER226 0x0788
#define NPU_REG_SHARED_BUFFER227 0x078C
#define NPU_REG_SHARED_BUFFER228 0x0790
#define NPU_REG_SHARED_BUFFER229 0x0794
#define NPU_REG_SHARED_BUFFER230 0x0798
#define NPU_REG_SHARED_BUFFER231 0x079C
#define NPU_REG_SHARED_BUFFER232 0x07A0
#define NPU_REG_SHARED_BUFFER233 0x07A4
#define NPU_REG_SHARED_BUFFER234 0x07A8
#define NPU_REG_SHARED_BUFFER235 0x07AC
#define NPU_REG_SHARED_BUFFER236 0x07B0
#define NPU_REG_SHARED_BUFFER237 0x07B4
#define NPU_REG_SHARED_BUFFER238 0x07B8
#define NPU_REG_SHARED_BUFFER239 0x07BC
#define NPU_REG_SHARED_BUFFER240 0x07C0
#define NPU_REG_SHARED_BUFFER241 0x07C4
#define NPU_REG_SHARED_BUFFER242 0x07C8
#define NPU_REG_SHARED_BUFFER243 0x07CC
#define NPU_REG_SHARED_BUFFER244 0x07D0
#define NPU_REG_SHARED_BUFFER245 0x07D4
#define NPU_REG_SHARED_BUFFER246 0x07D8
#define NPU_REG_SHARED_BUFFER247 0x07DC
#define NPU_REG_SHARED_BUFFER248 0x07E0
#define NPU_REG_SHARED_BUFFER249 0x07E4
#define NPU_REG_SHARED_BUFFER250 0x07E8
#define NPU_REG_SHARED_BUFFER251 0x07EC
#define NPU_REG_SHARED_BUFFER252 0x07F0
#define NPU_REG_SHARED_BUFFER253 0x07F4
#define NPU_REG_SHARED_BUFFER254 0x07F8
#define NPU_REG_SHARED_BUFFER255 0x07FC
#define DEBUG_INTERNAL_REGISTERS_SIZE 0x0800

//
// Register subpage HW_DEBUG_INTERNAL
//
#define NPU_REG_CLKFORCE 0x0140
#define NPU_REG_DEBUG 0x0144
#define NPU_REG_DEBUG2 0x0148
#define NPU_REG_DEBUGCORE 0x014C
#define HW_DEBUG_INTERNAL_REGISTERS_SIZE 0x0150

//
// Register subpage NPU_BP
//
#define NPU_REG_BASEP0 0x0080
#define NPU_REG_BASEP1 0x0084
#define NPU_REG_BASEP2 0x0088
#define NPU_REG_BASEP3 0x008C
#define NPU_REG_BASEP4 0x0090
#define NPU_REG_BASEP5 0x0094
#define NPU_REG_BASEP6 0x0098
#define NPU_REG_BASEP7 0x009C
#define NPU_REG_BASEP8 0x00A0
#define NPU_REG_BASEP9 0x00A4
#define NPU_REG_BASEP10 0x00A8
#define NPU_REG_BASEP11 0x00AC
#define NPU_REG_BASEP12 0x00B0
#define NPU_REG_BASEP13 0x00B4
#define NPU_REG_BASEP14 0x00B8
#define NPU_REG_BASEP15 0x00BC
#define NPU_BP_REGISTERS_SIZE 0x00C0

//
// Register subpage NPU_IDS
//
#define NPU_REG_REVISION 0x0FC0
#define NPU_REG_PID4 0x0FD0
#define NPU_REG_PID5 0x0FD4
#define NPU_REG_PID6 0x0FD8
#define NPU_REG_PID7 0x0FDC
#define NPU_REG_PID0 0x0FE0
#define NPU_REG_PID1 0x0FE4
#define NPU_REG_PID2 0x0FE8
#define NPU_REG_PID3 0x0FEC
#define NPU_REG_CID0 0x0FF0
#define NPU_REG_CID1 0x0FF4
#define NPU_REG_CID2 0x0FF8
#define NPU_REG_CID3 0x0FFC
#define NPU_IDS_REGISTERS_SIZE 0x1000

//
// Register subpage NPU_REG
//
#define NPU_REG_ID 0x0000
#define NPU_REG_STATUS 0x0004
#define NPU_REG_CMD 0x0008
#define NPU_REG_RESET 0x000C
#define NPU_REG_QBASE0 0x0010
#define NPU_REG_QBASE1 0x0014
#define NPU_REG_QREAD 0x0018
#define NPU_REG_QCONFIG 0x001C
#define NPU_REG_QSIZE 0x0020
#define NPU_REG_PROT 0x0024
#define NPU_REG_CONFIG 0x0028
#define NPU_REG_LOCK 0x002C
#define NPU_REG_REGIONCFG 0x003C
#define NPU_REG_AXI_LIMIT0 0x0040
#define NPU_REG_AXI_LIMIT1 0x0044
#define NPU_REG_AXI_LIMIT2 0x0048
#define NPU_REG_AXI_LIMIT3 0x004C
#define NPU_REG_REGISTERS_SIZE 0x0050

//
// Register subpage PMU_INTERNAL
//
#define NPU_REG_PMCR 0x0180
#define NPU_REG_PMCNTENSET 0x0184
#define NPU_REG_PMCNTENCLR 0x0188
#define NPU_REG_PMOVSSET 0x018C
#define NPU_REG_PMOVSCLR 0x0190
#define NPU_REG_PMINTSET 0x0194
#define NPU_REG_PMINTCLR 0x0198
#define NPU_REG_PMCCNTR_LO 0x01A0
#define NPU_REG_PMCCNTR_HI 0x01A4
#define NPU_REG_PMCCNTR_CFG 0x01A8
#define NPU_REG_PMCAXI_CHAN 0x01AC
#define NPU_REG_PMEVCNTR0 0x0300
#define NPU_REG_PMEVCNTR1 0x0304
#define NPU_REG_PMEVCNTR2 0x0308
#define NPU_REG_PMEVCNTR3 0x030C
#define NPU_REG_PMEVTYPER0 0x0380
#define NPU_REG_PMEVTYPER1 0x0384
#define NPU_REG_PMEVTYPER2 0x0388
#define NPU_REG_PMEVTYPER3 0x038C
#define PMU_INTERNAL_REGISTERS_SIZE 0x0390

//
// Register subpage TSU_DEBUG_INTERNAL
//
#define NPU_REG_IFM_PAD_TOP 0x0800
#define NPU_REG_IFM_PAD_LEFT 0x0804
#define NPU_REG_IFM_PAD_RIGHT 0x0808
#define NPU_REG_IFM_PAD_BOTTOM 0x080C
#define NPU_REG_IFM_DEPTH_M1 0x0810
#define NPU_REG_IFM_PRECISION 0x0814
#define NPU_REG_IFM_UPSCALE 0x081C
#define NPU_REG_IFM_ZERO_POINT 0x0824
#define NPU_REG_IFM_WIDTH0_M1 0x0828
#define NPU_REG_IFM_HEIGHT0_M1 0x082C
#define NPU_REG_IFM_HEIGHT1_M1 0x0830
#define NPU_REG_IFM_IB_END 0x0834
#define NPU_REG_IFM_REGION 0x083C
#define NPU_REG_OFM_WIDTH_M1 0x0844
#define NPU_REG_OFM_HEIGHT_M1 0x0848
#define NPU_REG_OFM_DEPTH_M1 0x084C
#define NPU_REG_OFM_PRECISION 0x0850
#define NPU_REG_OFM_BLK_WIDTH_M1 0x0854
#define NPU_REG_OFM_BLK_HEIGHT_M1 0x0858
#define NPU_REG_OFM_BLK_DEPTH_M1 0x085C
#define NPU_REG_OFM_ZERO_POINT 0x0860
#define NPU_REG_OFM_WIDTH0_M1 0x0868
#define NPU_REG_OFM_HEIGHT0_M1 0x086C
#define NPU_REG_OFM_HEIGHT1_M1 0x0870
#define NPU_REG_OFM_REGION 0x087C
#define NPU_REG_KERNEL_WIDTH_M1 0x0880
#define NPU_REG_KERNEL_HEIGHT_M1 0x0884
#define NPU_REG_KERNEL_STRIDE 0x0888
#define NPU_REG_PARALLEL_MODE 0x088C
#define NPU_REG_ACC_FORMAT 0x0890
#define NPU_REG_ACTIVATION 0x0894
#define NPU_REG_ACTIVATION_MIN 0x0898
#define NPU_REG_ACTIVATION_MAX 0x089C
#define NPU_REG_WEIGHT_REGION 0x08A0
#define NPU_REG_SCALE_REGION 0x08A4
#define NPU_REG_AB_START 0x08B4
#define NPU_REG_BLOCKDEP 0x08BC
#define NPU_REG_DMA0_SRC_REGION 0x08C0
#define NPU_REG_DMA0_DST_REGION 0x08C4
#define NPU_REG_DMA0_SIZE0 0x08C8
#define NPU_REG_DMA0_SIZE1 0x08CC
#define NPU_REG_IFM2_BROADCAST 0x0900
#define NPU_REG_IFM2_SCALAR 0x0904
#define NPU_REG_IFM2_PRECISION 0x0914
#define NPU_REG_IFM2_ZERO_POINT 0x0924
#define NPU_REG_IFM2_WIDTH0_M1 0x0928
#define NPU_REG_IFM2_HEIGHT0_M1 0x092C
#define NPU_REG_IFM2_HEIGHT1_M1 0x0930
#define NPU_REG_IFM2_IB_START 0x0934
#define NPU_REG_IFM2_REGION 0x093C
#define NPU_REG_IFM_BASE0 0x0A00
#define NPU_REG_IFM_BASE0_HI 0x0A04
#define NPU_REG_IFM_BASE1 0x0A08
#define NPU_REG_IFM_BASE1_HI 0x0A0C
#define NPU_REG_IFM_BASE2 0x0A10
#define NPU_REG_IFM_BASE2_HI 0x0A14
#define NPU_REG_IFM_BASE3 0x0A18
#define NPU_REG_IFM_BASE3_HI 0x0A1C
#define NPU_REG_IFM_STRIDE_X 0x0A20
#define NPU_REG_IFM_STRIDE_X_HI 0x0A24
#define NPU_REG_IFM_STRIDE_Y 0x0A28
#define NPU_REG_IFM_STRIDE_Y_HI 0x0A2C
#define NPU_REG_IFM_STRIDE_C 0x0A30
#define NPU_REG_IFM_STRIDE_C_HI 0x0A34
#define NPU_REG_OFM_BASE0 0x0A40
#define NPU_REG_OFM_BASE0_HI 0x0A44
#define NPU_REG_OFM_BASE1 0x0A48
#define NPU_REG_OFM_BASE1_HI 0x0A4C
#define NPU_REG_OFM_BASE2 0x0A50
#define NPU_REG_OFM_BASE2_HI 0x0A54
#define NPU_REG_OFM_BASE3 0x0A58
#define NPU_REG_OFM_BASE3_HI 0x0A5C
#define NPU_REG_OFM_STRIDE_X 0x0A60
#define NPU_REG_OFM_STRIDE_X_HI 0x0A64
#define NPU_REG_OFM_STRIDE_Y 0x0A68
#define NPU_REG_OFM_STRIDE_Y_HI 0x0A6C
#define NPU_REG_OFM_STRIDE_C 0x0A70
#define NPU_REG_OFM_STRIDE_C_HI 0x0A74
#define NPU_REG_WEIGHT_BASE 0x0A80
#define NPU_REG_WEIGHT_BASE_HI 0x0A84
#define NPU_REG_WEIGHT_LENGTH 0x0A88
#define NPU_REG_WEIGHT_LENGTH_HI 0x0A8C
#define NPU_REG_SCALE_BASE 0x0A90
#define NPU_REG_SCALE_BASE_HI 0x0A94
#define NPU_REG_SCALE_LENGTH 0x0A98
#define NPU_REG_OFM_SCALE 0x0AA0
#define NPU_REG_OFM_SCALE_SHIFT 0x0AA4
#define NPU_REG_OPA_SCALE 0x0AA8
#define NPU_REG_OPA_SCALE_SHIFT 0x0AAC
#define NPU_REG_OPB_SCALE 0x0AB0
#define NPU_REG_DMA0_SRC 0x0AC0
#define NPU_REG_DMA0_SRC_HI 0x0AC4
#define NPU_REG_DMA0_DST 0x0AC8
#define NPU_REG_DMA0_DST_HI 0x0ACC
#define NPU_REG_DMA0_LEN 0x0AD0
#define NPU_REG_DMA0_LEN_HI 0x0AD4
#define NPU_REG_DMA0_SKIP0 0x0AD8
#define NPU_REG_DMA0_SKIP0_HI 0x0ADC
#define NPU_REG_DMA0_SKIP1 0x0AE0
#define NPU_REG_DMA0_SKIP1_HI 0x0AE4
#define NPU_REG_IFM2_BASE0 0x0B00
#define NPU_REG_IFM2_BASE0_HI 0x0B04
#define NPU_REG_IFM2_BASE1 0x0B08
#define NPU_REG_IFM2_BASE1_HI 0x0B0C
#define NPU_REG_IFM2_BASE2 0x0B10
#define NPU_REG_IFM2_BASE2_HI 0x0B14
#define NPU_REG_IFM2_BASE3 0x0B18
#define NPU_REG_IFM2_BASE3_HI 0x0B1C
#define NPU_REG_IFM2_STRIDE_X 0x0B20
#define NPU_REG_IFM2_STRIDE_X_HI 0x0B24
#define NPU_REG_IFM2_STRIDE_Y 0x0B28
#define NPU_REG_IFM2_STRIDE_Y_HI 0x0B2C
#define NPU_REG_IFM2_STRIDE_C 0x0B30
#define NPU_REG_IFM2_STRIDE_C_HI 0x0B34
#define NPU_REG_WEIGHT1_BASE 0x0B40
#define NPU_REG_WEIGHT1_BASE_HI 0x0B44
#define NPU_REG_WEIGHT1_LENGTH 0x0B48
#define NPU_REG_WEIGHT1_LENGTH_HI 0x0B4C
#define NPU_REG_SCALE1_BASE 0x0B50
#define NPU_REG_SCALE1_BASE_HI 0x0B54
#define NPU_REG_SCALE1_LENGTH 0x0B58
#define TSU_DEBUG_INTERNAL_REGISTERS_SIZE 0x0B5C

//
// Register subpage TSU_DEBUG_RO_INTERNAL
//
#define NPU_REG_KERNEL_X 0x0200
#define NPU_REG_KERNEL_Y 0x0204
#define NPU_REG_KERNEL_W_M1 0x0208
#define NPU_REG_KERNEL_H_M1 0x020C
#define NPU_REG_OFM_CBLK_WIDTH_M1 0x0210
#define NPU_REG_OFM_CBLK_HEIGHT_M1 0x0214
#define NPU_REG_OFM_CBLK_DEPTH_M1 0x0218
#define NPU_REG_IFM_CBLK_DEPTH_M1 0x021C
#define NPU_REG_OFM_X 0x0220
#define NPU_REG_OFM_Y 0x0224
#define NPU_REG_OFM_Z 0x0228
#define NPU_REG_IFM_Z 0x022C
#define NPU_REG_PAD_TOP 0x0230
#define NPU_REG_PAD_LEFT 0x0234
#define NPU_REG_IFM_CBLK_WIDTH 0x0238
#define NPU_REG_IFM_CBLK_HEIGHT 0x023C
#define NPU_REG_DMA_IFM_SRC 0x0240
#define NPU_REG_DMA_IFM_SRC_HI 0x0244
#define NPU_REG_DMA_IFM_DST 0x0248
#define NPU_REG_DMA_OFM_SRC 0x024C
#define NPU_REG_DMA_OFM_DST 0x0250
#define NPU_REG_DMA_OFM_DST_HI 0x0254
#define NPU_REG_DMA_WEIGHT_SRC 0x0258
#define NPU_REG_DMA_WEIGHT_SRC_HI 0x025C
#define NPU_REG_DMA_CMD_SRC 0x0260
#define NPU_REG_DMA_CMD_SRC_HI 0x0264
#define NPU_REG_DMA_CMD_SIZE 0x0268
#define NPU_REG_DMA_M2M_SRC 0x026C
#define NPU_REG_DMA_M2M_SRC_HI 0x0270
#define NPU_REG_DMA_M2M_DST 0x0274
#define NPU_REG_DMA_M2M_DST_HI 0x0278
#define NPU_REG_CURRENT_QREAD 0x027C
#define NPU_REG_DMA_SCALE_SRC 0x0280
#define NPU_REG_DMA_SCALE_SRC_HI 0x0284
#define NPU_REG_CURRENT_CMD 0x02BC
#define TSU_DEBUG_RO_INTERNAL_REGISTERS_SIZE 0x02C0

#ifdef __cplusplus

// Enum types

enum class acc_format : uint8_t
{
    INT_32BIT = 0,
    INT_40BIT = 1,
    FP_S5_10  = 2,
};

enum class activation : uint8_t
{
    NONE      = 0,
    TANH      = 3,
    SIGMOID   = 4,
    LUT_START = 16,
    LUT_END   = 23,
};

enum class clip_range : uint8_t
{
    OFM_PRECISION = 0,
    FORCE_UINT8   = 2,
    FORCE_INT8    = 3,
    FORCE_INT16   = 5,
};

enum class cmd0 : uint16_t
{
    NPU_OP_STOP               = 0x000,
    NPU_OP_IRQ                = 0x001,
    NPU_OP_CONV               = 0x002,
    NPU_OP_DEPTHWISE          = 0x003,
    NPU_OP_POOL               = 0x005,
    NPU_OP_ELEMENTWISE        = 0x006,
    NPU_OP_DMA_START          = 0x010,
    NPU_OP_DMA_WAIT           = 0x011,
    NPU_OP_KERNEL_WAIT        = 0x012,
    NPU_OP_PMU_MASK           = 0x013,
    NPU_SET_IFM_PAD_TOP       = 0x100,
    NPU_SET_IFM_PAD_LEFT      = 0x101,
    NPU_SET_IFM_PAD_RIGHT     = 0x102,
    NPU_SET_IFM_PAD_BOTTOM    = 0x103,
    NPU_SET_IFM_DEPTH_M1      = 0x104,
    NPU_SET_IFM_PRECISION     = 0x105,
    NPU_SET_IFM_UPSCALE       = 0x107,
    NPU_SET_IFM_ZERO_POINT    = 0x109,
    NPU_SET_IFM_WIDTH0_M1     = 0x10A,
    NPU_SET_IFM_HEIGHT0_M1    = 0x10B,
    NPU_SET_IFM_HEIGHT1_M1    = 0x10C,
    NPU_SET_IFM_IB_END        = 0x10D,
    NPU_SET_IFM_REGION        = 0x10F,
    NPU_SET_OFM_WIDTH_M1      = 0x111,
    NPU_SET_OFM_HEIGHT_M1     = 0x112,
    NPU_SET_OFM_DEPTH_M1      = 0x113,
    NPU_SET_OFM_PRECISION     = 0x114,
    NPU_SET_OFM_BLK_WIDTH_M1  = 0x115,
    NPU_SET_OFM_BLK_HEIGHT_M1 = 0x116,
    NPU_SET_OFM_BLK_DEPTH_M1  = 0x117,
    NPU_SET_OFM_ZERO_POINT    = 0x118,
    NPU_SET_OFM_WIDTH0_M1     = 0x11A,
    NPU_SET_OFM_HEIGHT0_M1    = 0x11B,
    NPU_SET_OFM_HEIGHT1_M1    = 0x11C,
    NPU_SET_OFM_REGION        = 0x11F,
    NPU_SET_KERNEL_WIDTH_M1   = 0x120,
    NPU_SET_KERNEL_HEIGHT_M1  = 0x121,
    NPU_SET_KERNEL_STRIDE     = 0x122,
    NPU_SET_PARALLEL_MODE     = 0x123,
    NPU_SET_ACC_FORMAT        = 0x124,
    NPU_SET_ACTIVATION        = 0x125,
    NPU_SET_ACTIVATION_MIN    = 0x126,
    NPU_SET_ACTIVATION_MAX    = 0x127,
    NPU_SET_WEIGHT_REGION     = 0x128,
    NPU_SET_SCALE_REGION      = 0x129,
    NPU_SET_AB_START          = 0x12D,
    NPU_SET_BLOCKDEP          = 0x12F,
    NPU_SET_DMA0_SRC_REGION   = 0x130,
    NPU_SET_DMA0_DST_REGION   = 0x131,
    NPU_SET_DMA0_SIZE0        = 0x132,
    NPU_SET_DMA0_SIZE1        = 0x133,
    NPU_SET_IFM2_BROADCAST    = 0x180,
    NPU_SET_IFM2_SCALAR       = 0x181,
    NPU_SET_IFM2_PRECISION    = 0x185,
    NPU_SET_IFM2_ZERO_POINT   = 0x189,
    NPU_SET_IFM2_WIDTH0_M1    = 0x18A,
    NPU_SET_IFM2_HEIGHT0_M1   = 0x18B,
    NPU_SET_IFM2_HEIGHT1_M1   = 0x18C,
    NPU_SET_IFM2_IB_START     = 0x18D,
    NPU_SET_IFM2_REGION       = 0x18F,
};

enum class cmd1 : uint8_t
{
    NPU_SET_IFM_BASE0      = 0x000,
    NPU_SET_IFM_BASE1      = 0x001,
    NPU_SET_IFM_BASE2      = 0x002,
    NPU_SET_IFM_BASE3      = 0x003,
    NPU_SET_IFM_STRIDE_X   = 0x004,
    NPU_SET_IFM_STRIDE_Y   = 0x005,
    NPU_SET_IFM_STRIDE_C   = 0x006,
    NPU_SET_OFM_BASE0      = 0x010,
    NPU_SET_OFM_BASE1      = 0x011,
    NPU_SET_OFM_BASE2      = 0x012,
    NPU_SET_OFM_BASE3      = 0x013,
    NPU_SET_OFM_STRIDE_X   = 0x014,
    NPU_SET_OFM_STRIDE_Y   = 0x015,
    NPU_SET_OFM_STRIDE_C   = 0x016,
    NPU_SET_WEIGHT_BASE    = 0x020,
    NPU_SET_WEIGHT_LENGTH  = 0x021,
    NPU_SET_SCALE_BASE     = 0x022,
    NPU_SET_SCALE_LENGTH   = 0x023,
    NPU_SET_OFM_SCALE      = 0x024,
    NPU_SET_OPA_SCALE      = 0x025,
    NPU_SET_OPB_SCALE      = 0x026,
    NPU_SET_DMA0_SRC       = 0x030,
    NPU_SET_DMA0_DST       = 0x031,
    NPU_SET_DMA0_LEN       = 0x032,
    NPU_SET_DMA0_SKIP0     = 0x033,
    NPU_SET_DMA0_SKIP1     = 0x034,
    NPU_SET_IFM2_BASE0     = 0x080,
    NPU_SET_IFM2_BASE1     = 0x081,
    NPU_SET_IFM2_BASE2     = 0x082,
    NPU_SET_IFM2_BASE3     = 0x083,
    NPU_SET_IFM2_STRIDE_X  = 0x084,
    NPU_SET_IFM2_STRIDE_Y  = 0x085,
    NPU_SET_IFM2_STRIDE_C  = 0x086,
    NPU_SET_WEIGHT1_BASE   = 0x090,
    NPU_SET_WEIGHT1_LENGTH = 0x091,
    NPU_SET_SCALE1_BASE    = 0x092,
    NPU_SET_SCALE1_LENGTH  = 0x093,
};

enum class data_format : uint8_t
{
    NHWC    = 0,
    NHCWB16 = 1,
};

enum class elementwise_mode : uint8_t
{
    MUL   = 0,
    ADD   = 1,
    SUB   = 2,
    MIN   = 3,
    MAX   = 4,
    LRELU = 5,
    ABS   = 6,
    CLZ   = 7,
    SHR   = 8,
    SHL   = 9,
};

enum class ifm_precision : uint8_t
{
    W8_U8  = 0,
    W8_S8  = 1,
    W8_U16 = 4,
    W8_S16 = 5,
    W8_S32 = 9,
};

enum class ifm_scale_mode : uint8_t
{
    SCALE_16BIT     = 0,
    SCALE_OPA_32BIT = 1,
    SCALE_OPB_32BIT = 2,
};

enum class memory_type : uint8_t
{
    AXI0_OUTSTANDING_COUNTER0 = 0,
    AXI0_OUTSTANDING_COUNTER1 = 1,
    AXI1_OUTSTANDING_COUNTER2 = 2,
    AXI1_OUTSTANDING_COUNTER3 = 3,
};

enum class ofm_precision : uint8_t
{
    U8  = 0,
    S8  = 1,
    U16 = 2,
    S16 = 3,
    S32 = 5,
};

enum class pmu_event_type : uint16_t
{
    CYCLE                      = 0x11,
    NPU_IDLE                   = 0x20,
    MAC_ACTIVE                 = 0x30,
    MAC_ACTIVE_8BIT            = 0x31,
    MAC_ACTIVE_16BIT           = 0x32,
    MAC_DPU_ACTIVE             = 0x33,
    MAC_STALLED_BY_WD_ACC      = 0x34,
    MAC_STALLED_BY_WD          = 0x35,
    MAC_STALLED_BY_ACC         = 0x36,
    MAC_STALLED_BY_IB          = 0x37,
    AO_ACTIVE                  = 0x40,
    AO_ACTIVE_8BIT             = 0x41,
    AO_ACTIVE_16BIT            = 0x42,
    AO_STALLED_BY_OFMP_OB      = 0x43,
    AO_STALLED_BY_OFMP         = 0x44,
    AO_STALLED_BY_OB           = 0x45,
    AO_STALLED_BY_ACC_IB       = 0x46,
    AO_STALLED_BY_ACC          = 0x47,
    AO_STALLED_BY_IB           = 0x48,
    WD_ACTIVE                  = 0x50,
    WD_STALLED                 = 0x51,
    WD_STALLED_BY_WS           = 0x52,
    WD_STALLED_BY_WD_BUF       = 0x53,
    WD_PARSE_ACTIVE            = 0x54,
    WD_PARSE_STALLED           = 0x55,
    WD_PARSE_STALLED_IN        = 0x56,
    WD_PARSE_STALLED_OUT       = 0x57,
    AXI0_RD_TRANS_ACCEPTED     = 0x80,
    AXI0_RD_TRANS_COMPLETED    = 0x81,
    AXI0_RD_DATA_BEAT_RECEIVED = 0x82,
    AXI0_RD_TRAN_REQ_STALLED   = 0x83,
    AXI0_WR_TRANS_ACCEPTED     = 0x84,
    AXI0_WR_TRANS_COMPLETED_M  = 0x85,
    AXI0_WR_TRANS_COMPLETED_S  = 0x86,
    AXI0_WR_DATA_BEAT_WRITTEN  = 0x87,
    AXI0_WR_TRAN_REQ_STALLED   = 0x88,
    AXI0_WR_DATA_BEAT_STALLED  = 0x89,
    AXI0_ENABLED_CYCLES        = 0x8c,
    AXI0_RD_STALL_LIMIT        = 0x8e,
    AXI0_WR_STALL_LIMIT        = 0x8f,
    AXI1_RD_TRANS_ACCEPTED     = 0x180,
    AXI1_RD_TRANS_COMPLETED    = 0x181,
    AXI1_RD_DATA_BEAT_RECEIVED = 0x182,
    AXI1_RD_TRAN_REQ_STALLED   = 0x183,
    AXI1_WR_TRANS_ACCEPTED     = 0x184,
    AXI1_WR_TRANS_COMPLETED_M  = 0x185,
    AXI1_WR_TRANS_COMPLETED_S  = 0x186,
    AXI1_WR_DATA_BEAT_WRITTEN  = 0x187,
    AXI1_WR_TRAN_REQ_STALLED   = 0x188,
    AXI1_WR_DATA_BEAT_STALLED  = 0x189,
    AXI1_ENABLED_CYCLES        = 0x18c,
    AXI1_RD_STALL_LIMIT        = 0x18e,
    AXI1_WR_STALL_LIMIT        = 0x18f,
    AXI_LATENCY_ANY            = 0xa0,
    AXI_LATENCY_32             = 0xa1,
    AXI_LATENCY_64             = 0xa2,
    AXI_LATENCY_128            = 0xa3,
    AXI_LATENCY_256            = 0xa4,
    AXI_LATENCY_512            = 0xa5,
    AXI_LATENCY_1024           = 0xa6,
};

enum class pooling_mode : uint8_t
{
    MAX        = 0,
    AVERAGE    = 1,
    REDUCE_SUM = 2,
};

enum class privilege_level : uint8_t
{
    USER       = 0,
    PRIVILEGED = 1,
};

enum class product : uint8_t
{
    ETHOS_U55 = 0,
};

enum class resampling_mode : uint8_t
{
    NONE      = 0,
    NEAREST   = 1,
    TRANSPOSE = 2,
};

enum class rounding : uint8_t
{
    TFL      = 0,
    TRUNCATE = 1,
    NATURAL  = 2,
};

enum class security_level : uint8_t
{
    SECURE     = 0,
    NON_SECURE = 1,
};

enum class state : uint8_t
{
    STOPPED = 0,
    RUNNING = 1,
};

enum class stride_mode : uint8_t
{
    STRIDE_MODE_1D = 0,
    STRIDE_MODE_2D = 1,
    STRIDE_MODE_3D = 2,
};

#else

enum acc_format
{
    ACC_FORMAT_INT_32BIT = 0,
    ACC_FORMAT_INT_40BIT = 1,
    ACC_FORMAT_FP_S5_10  = 2,
};

enum activation
{
    ACTIVATION_NONE      = 0,
    ACTIVATION_TANH      = 3,
    ACTIVATION_SIGMOID   = 4,
    ACTIVATION_LUT_START = 16,
    ACTIVATION_LUT_END   = 23,
};

enum clip_range
{
    CLIP_RANGE_OFM_PRECISION = 0,
    CLIP_RANGE_FORCE_UINT8   = 2,
    CLIP_RANGE_FORCE_INT8    = 3,
    CLIP_RANGE_FORCE_INT16   = 5,
};

enum cmd0
{
    CMD0_NPU_OP_STOP               = 0x000,
    CMD0_NPU_OP_IRQ                = 0x001,
    CMD0_NPU_OP_CONV               = 0x002,
    CMD0_NPU_OP_DEPTHWISE          = 0x003,
    CMD0_NPU_OP_POOL               = 0x005,
    CMD0_NPU_OP_ELEMENTWISE        = 0x006,
    CMD0_NPU_OP_DMA_START          = 0x010,
    CMD0_NPU_OP_DMA_WAIT           = 0x011,
    CMD0_NPU_OP_KERNEL_WAIT        = 0x012,
    CMD0_NPU_OP_PMU_MASK           = 0x013,
    CMD0_NPU_SET_IFM_PAD_TOP       = 0x100,
    CMD0_NPU_SET_IFM_PAD_LEFT      = 0x101,
    CMD0_NPU_SET_IFM_PAD_RIGHT     = 0x102,
    CMD0_NPU_SET_IFM_PAD_BOTTOM    = 0x103,
    CMD0_NPU_SET_IFM_DEPTH_M1      = 0x104,
    CMD0_NPU_SET_IFM_PRECISION     = 0x105,
    CMD0_NPU_SET_IFM_UPSCALE       = 0x107,
    CMD0_NPU_SET_IFM_ZERO_POINT    = 0x109,
    CMD0_NPU_SET_IFM_WIDTH0_M1     = 0x10A,
    CMD0_NPU_SET_IFM_HEIGHT0_M1    = 0x10B,
    CMD0_NPU_SET_IFM_HEIGHT1_M1    = 0x10C,
    CMD0_NPU_SET_IFM_IB_END        = 0x10D,
    CMD0_NPU_SET_IFM_REGION        = 0x10F,
    CMD0_NPU_SET_OFM_WIDTH_M1      = 0x111,
    CMD0_NPU_SET_OFM_HEIGHT_M1     = 0x112,
    CMD0_NPU_SET_OFM_DEPTH_M1      = 0x113,
    CMD0_NPU_SET_OFM_PRECISION     = 0x114,
    CMD0_NPU_SET_OFM_BLK_WIDTH_M1  = 0x115,
    CMD0_NPU_SET_OFM_BLK_HEIGHT_M1 = 0x116,
    CMD0_NPU_SET_OFM_BLK_DEPTH_M1  = 0x117,
    CMD0_NPU_SET_OFM_ZERO_POINT    = 0x118,
    CMD0_NPU_SET_OFM_WIDTH0_M1     = 0x11A,
    CMD0_NPU_SET_OFM_HEIGHT0_M1    = 0x11B,
    CMD0_NPU_SET_OFM_HEIGHT1_M1    = 0x11C,
    CMD0_NPU_SET_OFM_REGION        = 0x11F,
    CMD0_NPU_SET_KERNEL_WIDTH_M1   = 0x120,
    CMD0_NPU_SET_KERNEL_HEIGHT_M1  = 0x121,
    CMD0_NPU_SET_KERNEL_STRIDE     = 0x122,
    CMD0_NPU_SET_PARALLEL_MODE     = 0x123,
    CMD0_NPU_SET_ACC_FORMAT        = 0x124,
    CMD0_NPU_SET_ACTIVATION        = 0x125,
    CMD0_NPU_SET_ACTIVATION_MIN    = 0x126,
    CMD0_NPU_SET_ACTIVATION_MAX    = 0x127,
    CMD0_NPU_SET_WEIGHT_REGION     = 0x128,
    CMD0_NPU_SET_SCALE_REGION      = 0x129,
    CMD0_NPU_SET_AB_START          = 0x12D,
    CMD0_NPU_SET_BLOCKDEP          = 0x12F,
    CMD0_NPU_SET_DMA0_SRC_REGION   = 0x130,
    CMD0_NPU_SET_DMA0_DST_REGION   = 0x131,
    CMD0_NPU_SET_DMA0_SIZE0        = 0x132,
    CMD0_NPU_SET_DMA0_SIZE1        = 0x133,
    CMD0_NPU_SET_IFM2_BROADCAST    = 0x180,
    CMD0_NPU_SET_IFM2_SCALAR       = 0x181,
    CMD0_NPU_SET_IFM2_PRECISION    = 0x185,
    CMD0_NPU_SET_IFM2_ZERO_POINT   = 0x189,
    CMD0_NPU_SET_IFM2_WIDTH0_M1    = 0x18A,
    CMD0_NPU_SET_IFM2_HEIGHT0_M1   = 0x18B,
    CMD0_NPU_SET_IFM2_HEIGHT1_M1   = 0x18C,
    CMD0_NPU_SET_IFM2_IB_START     = 0x18D,
    CMD0_NPU_SET_IFM2_REGION       = 0x18F,
};

enum cmd1
{
    CMD1_NPU_SET_IFM_BASE0      = 0x000,
    CMD1_NPU_SET_IFM_BASE1      = 0x001,
    CMD1_NPU_SET_IFM_BASE2      = 0x002,
    CMD1_NPU_SET_IFM_BASE3      = 0x003,
    CMD1_NPU_SET_IFM_STRIDE_X   = 0x004,
    CMD1_NPU_SET_IFM_STRIDE_Y   = 0x005,
    CMD1_NPU_SET_IFM_STRIDE_C   = 0x006,
    CMD1_NPU_SET_OFM_BASE0      = 0x010,
    CMD1_NPU_SET_OFM_BASE1      = 0x011,
    CMD1_NPU_SET_OFM_BASE2      = 0x012,
    CMD1_NPU_SET_OFM_BASE3      = 0x013,
    CMD1_NPU_SET_OFM_STRIDE_X   = 0x014,
    CMD1_NPU_SET_OFM_STRIDE_Y   = 0x015,
    CMD1_NPU_SET_OFM_STRIDE_C   = 0x016,
    CMD1_NPU_SET_WEIGHT_BASE    = 0x020,
    CMD1_NPU_SET_WEIGHT_LENGTH  = 0x021,
    CMD1_NPU_SET_SCALE_BASE     = 0x022,
    CMD1_NPU_SET_SCALE_LENGTH   = 0x023,
    CMD1_NPU_SET_OFM_SCALE      = 0x024,
    CMD1_NPU_SET_OPA_SCALE      = 0x025,
    CMD1_NPU_SET_OPB_SCALE      = 0x026,
    CMD1_NPU_SET_DMA0_SRC       = 0x030,
    CMD1_NPU_SET_DMA0_DST       = 0x031,
    CMD1_NPU_SET_DMA0_LEN       = 0x032,
    CMD1_NPU_SET_DMA0_SKIP0     = 0x033,
    CMD1_NPU_SET_DMA0_SKIP1     = 0x034,
    CMD1_NPU_SET_IFM2_BASE0     = 0x080,
    CMD1_NPU_SET_IFM2_BASE1     = 0x081,
    CMD1_NPU_SET_IFM2_BASE2     = 0x082,
    CMD1_NPU_SET_IFM2_BASE3     = 0x083,
    CMD1_NPU_SET_IFM2_STRIDE_X  = 0x084,
    CMD1_NPU_SET_IFM2_STRIDE_Y  = 0x085,
    CMD1_NPU_SET_IFM2_STRIDE_C  = 0x086,
    CMD1_NPU_SET_WEIGHT1_BASE   = 0x090,
    CMD1_NPU_SET_WEIGHT1_LENGTH = 0x091,
    CMD1_NPU_SET_SCALE1_BASE    = 0x092,
    CMD1_NPU_SET_SCALE1_LENGTH  = 0x093,
};

enum data_format
{
    DATA_FORMAT_NHWC    = 0,
    DATA_FORMAT_NHCWB16 = 1,
};

enum elementwise_mode
{
    ELEMENTWISE_MODE_MUL   = 0,
    ELEMENTWISE_MODE_ADD   = 1,
    ELEMENTWISE_MODE_SUB   = 2,
    ELEMENTWISE_MODE_MIN   = 3,
    ELEMENTWISE_MODE_MAX   = 4,
    ELEMENTWISE_MODE_LRELU = 5,
    ELEMENTWISE_MODE_ABS   = 6,
    ELEMENTWISE_MODE_CLZ   = 7,
    ELEMENTWISE_MODE_SHR   = 8,
    ELEMENTWISE_MODE_SHL   = 9,
};

enum ifm_precision
{
    IFM_PRECISION_W8_U8  = 0,
    IFM_PRECISION_W8_S8  = 1,
    IFM_PRECISION_W8_U16 = 4,
    IFM_PRECISION_W8_S16 = 5,
    IFM_PRECISION_W8_S32 = 9,
};

enum ifm_scale_mode
{
    IFM_SCALE_MODE_SCALE_16BIT     = 0,
    IFM_SCALE_MODE_SCALE_OPA_32BIT = 1,
    IFM_SCALE_MODE_SCALE_OPB_32BIT = 2,
};

enum memory_type
{
    MEMORY_TYPE_AXI0_OUTSTANDING_COUNTER0 = 0,
    MEMORY_TYPE_AXI0_OUTSTANDING_COUNTER1 = 1,
    MEMORY_TYPE_AXI1_OUTSTANDING_COUNTER2 = 2,
    MEMORY_TYPE_AXI1_OUTSTANDING_COUNTER3 = 3,
};

enum ofm_precision
{
    OFM_PRECISION_U8  = 0,
    OFM_PRECISION_S8  = 1,
    OFM_PRECISION_U16 = 2,
    OFM_PRECISION_S16 = 3,
    OFM_PRECISION_S32 = 5,
};

enum pmu_event_type
{
    PMU_EVENT_TYPE_CYCLE                      = 0x11,
    PMU_EVENT_TYPE_NPU_IDLE                   = 0x20,
    PMU_EVENT_TYPE_MAC_ACTIVE                 = 0x30,
    PMU_EVENT_TYPE_MAC_ACTIVE_8BIT            = 0x31,
    PMU_EVENT_TYPE_MAC_ACTIVE_16BIT           = 0x32,
    PMU_EVENT_TYPE_MAC_DPU_ACTIVE             = 0x33,
    PMU_EVENT_TYPE_MAC_STALLED_BY_WD_ACC      = 0x34,
    PMU_EVENT_TYPE_MAC_STALLED_BY_WD          = 0x35,
    PMU_EVENT_TYPE_MAC_STALLED_BY_ACC         = 0x36,
    PMU_EVENT_TYPE_MAC_STALLED_BY_IB          = 0x37,
    PMU_EVENT_TYPE_AO_ACTIVE                  = 0x40,
    PMU_EVENT_TYPE_AO_ACTIVE_8BIT             = 0x41,
    PMU_EVENT_TYPE_AO_ACTIVE_16BIT            = 0x42,
    PMU_EVENT_TYPE_AO_STALLED_BY_OFMP_OB      = 0x43,
    PMU_EVENT_TYPE_AO_STALLED_BY_OFMP         = 0x44,
    PMU_EVENT_TYPE_AO_STALLED_BY_OB           = 0x45,
    PMU_EVENT_TYPE_AO_STALLED_BY_ACC_IB       = 0x46,
    PMU_EVENT_TYPE_AO_STALLED_BY_ACC          = 0x47,
    PMU_EVENT_TYPE_AO_STALLED_BY_IB           = 0x48,
    PMU_EVENT_TYPE_WD_ACTIVE                  = 0x50,
    PMU_EVENT_TYPE_WD_STALLED                 = 0x51,
    PMU_EVENT_TYPE_WD_STALLED_BY_WS           = 0x52,
    PMU_EVENT_TYPE_WD_STALLED_BY_WD_BUF       = 0x53,
    PMU_EVENT_TYPE_WD_PARSE_ACTIVE            = 0x54,
    PMU_EVENT_TYPE_WD_PARSE_STALLED           = 0x55,
    PMU_EVENT_TYPE_WD_PARSE_STALLED_IN        = 0x56,
    PMU_EVENT_TYPE_WD_PARSE_STALLED_OUT       = 0x57,
    PMU_EVENT_TYPE_AXI0_RD_TRANS_ACCEPTED     = 0x80,
    PMU_EVENT_TYPE_AXI0_RD_TRANS_COMPLETED    = 0x81,
    PMU_EVENT_TYPE_AXI0_RD_DATA_BEAT_RECEIVED = 0x82,
    PMU_EVENT_TYPE_AXI0_RD_TRAN_REQ_STALLED   = 0x83,
    PMU_EVENT_TYPE_AXI0_WR_TRANS_ACCEPTED     = 0x84,
    PMU_EVENT_TYPE_AXI0_WR_TRANS_COMPLETED_M  = 0x85,
    PMU_EVENT_TYPE_AXI0_WR_TRANS_COMPLETED_S  = 0x86,
    PMU_EVENT_TYPE_AXI0_WR_DATA_BEAT_WRITTEN  = 0x87,
    PMU_EVENT_TYPE_AXI0_WR_TRAN_REQ_STALLED   = 0x88,
    PMU_EVENT_TYPE_AXI0_WR_DATA_BEAT_STALLED  = 0x89,
    PMU_EVENT_TYPE_AXI0_ENABLED_CYCLES        = 0x8c,
    PMU_EVENT_TYPE_AXI0_RD_STALL_LIMIT        = 0x8e,
    PMU_EVENT_TYPE_AXI0_WR_STALL_LIMIT        = 0x8f,
    PMU_EVENT_TYPE_AXI1_RD_TRANS_ACCEPTED     = 0x180,
    PMU_EVENT_TYPE_AXI1_RD_TRANS_COMPLETED    = 0x181,
    PMU_EVENT_TYPE_AXI1_RD_DATA_BEAT_RECEIVED = 0x182,
    PMU_EVENT_TYPE_AXI1_RD_TRAN_REQ_STALLED   = 0x183,
    PMU_EVENT_TYPE_AXI1_WR_TRANS_ACCEPTED     = 0x184,
    PMU_EVENT_TYPE_AXI1_WR_TRANS_COMPLETED_M  = 0x185,
    PMU_EVENT_TYPE_AXI1_WR_TRANS_COMPLETED_S  = 0x186,
    PMU_EVENT_TYPE_AXI1_WR_DATA_BEAT_WRITTEN  = 0x187,
    PMU_EVENT_TYPE_AXI1_WR_TRAN_REQ_STALLED   = 0x188,
    PMU_EVENT_TYPE_AXI1_WR_DATA_BEAT_STALLED  = 0x189,
    PMU_EVENT_TYPE_AXI1_ENABLED_CYCLES        = 0x18c,
    PMU_EVENT_TYPE_AXI1_RD_STALL_LIMIT        = 0x18e,
    PMU_EVENT_TYPE_AXI1_WR_STALL_LIMIT        = 0x18f,
    PMU_EVENT_TYPE_AXI_LATENCY_ANY            = 0xa0,
    PMU_EVENT_TYPE_AXI_LATENCY_32             = 0xa1,
    PMU_EVENT_TYPE_AXI_LATENCY_64             = 0xa2,
    PMU_EVENT_TYPE_AXI_LATENCY_128            = 0xa3,
    PMU_EVENT_TYPE_AXI_LATENCY_256            = 0xa4,
    PMU_EVENT_TYPE_AXI_LATENCY_512            = 0xa5,
    PMU_EVENT_TYPE_AXI_LATENCY_1024           = 0xa6,
};

enum pooling_mode
{
    POOLING_MODE_MAX        = 0,
    POOLING_MODE_AVERAGE    = 1,
    POOLING_MODE_REDUCE_SUM = 2,
};

enum privilege_level
{
    PRIVILEGE_LEVEL_USER       = 0,
    PRIVILEGE_LEVEL_PRIVILEGED = 1,
};

enum product
{
    PRODUCT_ETHOS_U55 = 0,
};

enum resampling_mode
{
    RESAMPLING_MODE_NONE      = 0,
    RESAMPLING_MODE_NEAREST   = 1,
    RESAMPLING_MODE_TRANSPOSE = 2,
};

enum rounding
{
    ROUNDING_TFL      = 0,
    ROUNDING_TRUNCATE = 1,
    ROUNDING_NATURAL  = 2,
};

enum security_level
{
    SECURITY_LEVEL_SECURE     = 0,
    SECURITY_LEVEL_NON_SECURE = 1,
};

enum state
{
    STATE_STOPPED = 0,
    STATE_RUNNING = 1,
};

enum stride_mode
{
    STRIDE_MODE_STRIDE_MODE_1D = 0,
    STRIDE_MODE_STRIDE_MODE_2D = 1,
    STRIDE_MODE_STRIDE_MODE_3D = 2,
};

#endif

// clkforce_r - Force clocks on for clock gating
struct clkforce_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<1> top_level_clk; // set to 1 to force on TOP level clock
    ::core::dt::uint_t<1> cc_clk;        // set to 1 to force on CC clock
    ::core::dt::uint_t<1> dma_clk;       // set to 1 to force on DMA clock
    ::core::dt::uint_t<1> mac_clk;       // set to 1 to force on MAC clock
    ::core::dt::uint_t<1> ao_clk;        // set to 1 to force on AO clock
    ::core::dt::uint_t<1> wd_clk;        // set to 1 to force on WD clock
#else
    union
    {
        struct
        {
            uint32_t top_level_clk : 1; // set to 1 to force on TOP level clock
            uint32_t cc_clk : 1;        // set to 1 to force on CC clock
            uint32_t dma_clk : 1;       // set to 1 to force on DMA clock
            uint32_t mac_clk : 1;       // set to 1 to force on MAC clock
            uint32_t ao_clk : 1;        // set to 1 to force on AO clock
            uint32_t wd_clk : 1;        // set to 1 to force on WD clock
            uint32_t reserved0 : 26;
        };
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR clkforce_r() :
        top_level_clk(static_cast<uint32_t>(0)), cc_clk(static_cast<uint32_t>(0)), dma_clk(static_cast<uint32_t>(0)),
        mac_clk(static_cast<uint32_t>(0)), ao_clk(static_cast<uint32_t>(0)), wd_clk(static_cast<uint32_t>(0))
    {
    }
    CONSTEXPR clkforce_r(uint32_t value) :
        top_level_clk(value >> 0), cc_clk(value >> 1), dma_clk(value >> 2), mac_clk(value >> 3), ao_clk(value >> 4),
        wd_clk(value >> 5)
    {
    }
    CONSTEXPR void operator=(uint32_t value)
    {
        top_level_clk = value >> 0;
        cc_clk        = value >> 1;
        dma_clk       = value >> 2;
        mac_clk       = value >> 3;
        ao_clk        = value >> 4;
        wd_clk        = value >> 5;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (top_level_clk << 0) | (cc_clk << 1) | (dma_clk << 2) | (mac_clk << 3) | (ao_clk << 4) | (wd_clk << 5);
    }
    clkforce_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR clkforce_r() :
        top_level_clk(static_cast<uint32_t>(0)), cc_clk(static_cast<uint32_t>(0)), dma_clk(static_cast<uint32_t>(0)),
        mac_clk(static_cast<uint32_t>(0)), ao_clk(static_cast<uint32_t>(0)), wd_clk(static_cast<uint32_t>(0)),
        reserved0(static_cast<uint32_t>(0))
    {
    }
    CONSTEXPR clkforce_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    clkforce_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_top_level_clk() const
    {
        uint32_t value = static_cast<uint32_t>(top_level_clk);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_top_level_clk() const volatile
    {
        uint32_t value = static_cast<uint32_t>(top_level_clk);
        return value;
    }
#endif
    CONSTEXPR clkforce_r &set_top_level_clk(uint32_t value)
    {
        top_level_clk = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_cc_clk() const
    {
        uint32_t value = static_cast<uint32_t>(cc_clk);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_cc_clk() const volatile
    {
        uint32_t value = static_cast<uint32_t>(cc_clk);
        return value;
    }
#endif
    CONSTEXPR clkforce_r &set_cc_clk(uint32_t value)
    {
        cc_clk = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_dma_clk() const
    {
        uint32_t value = static_cast<uint32_t>(dma_clk);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_dma_clk() const volatile
    {
        uint32_t value = static_cast<uint32_t>(dma_clk);
        return value;
    }
#endif
    CONSTEXPR clkforce_r &set_dma_clk(uint32_t value)
    {
        dma_clk = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_mac_clk() const
    {
        uint32_t value = static_cast<uint32_t>(mac_clk);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_mac_clk() const volatile
    {
        uint32_t value = static_cast<uint32_t>(mac_clk);
        return value;
    }
#endif
    CONSTEXPR clkforce_r &set_mac_clk(uint32_t value)
    {
        mac_clk = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_ao_clk() const
    {
        uint32_t value = static_cast<uint32_t>(ao_clk);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_ao_clk() const volatile
    {
        uint32_t value = static_cast<uint32_t>(ao_clk);
        return value;
    }
#endif
    CONSTEXPR clkforce_r &set_ao_clk(uint32_t value)
    {
        ao_clk = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_wd_clk() const
    {
        uint32_t value = static_cast<uint32_t>(wd_clk);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_wd_clk() const volatile
    {
        uint32_t value = static_cast<uint32_t>(wd_clk);
        return value;
    }
#endif
    CONSTEXPR clkforce_r &set_wd_clk(uint32_t value)
    {
        wd_clk = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// basep0_r - Lower 32 bits of the Base pointer for region index 0
struct basep0_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> addr_word; // The low word of the 64-bit address
#else
    union
    {
        uint32_t addr_word; // The low word of the 64-bit address
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR basep0_r() : addr_word(static_cast<uint32_t>(0)) {}
    CONSTEXPR basep0_r(uint32_t value) : addr_word(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        addr_word = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (addr_word << 0);
    }
    basep0_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR basep0_r() : addr_word(static_cast<uint32_t>(0)) {}
    CONSTEXPR basep0_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    basep0_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_addr_word() const
    {
        uint32_t value = static_cast<uint32_t>(addr_word);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_addr_word() const volatile
    {
        uint32_t value = static_cast<uint32_t>(addr_word);
        return value;
    }
#endif
    CONSTEXPR basep0_r &set_addr_word(uint32_t value)
    {
        addr_word = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// basep1_r - Upper 32 bits of the Base pointer for region index 0
struct basep1_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> addr_word; // The high word of the 64-bit address
#else
    union
    {
        uint32_t addr_word; // The high word of the 64-bit address
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR basep1_r() : addr_word(static_cast<uint32_t>(0)) {}
    CONSTEXPR basep1_r(uint32_t value) : addr_word(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        addr_word = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (addr_word << 0);
    }
    basep1_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR basep1_r() : addr_word(static_cast<uint32_t>(0)) {}
    CONSTEXPR basep1_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    basep1_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_addr_word() const
    {
        uint32_t value = static_cast<uint32_t>(addr_word);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_addr_word() const volatile
    {
        uint32_t value = static_cast<uint32_t>(addr_word);
        return value;
    }
#endif
    CONSTEXPR basep1_r &set_addr_word(uint32_t value)
    {
        addr_word = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// basep2_r - Lower 32 bits of the Base pointer for region index 1
struct basep2_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> addr_word; // The low word of the 64-bit address
#else
    union
    {
        uint32_t addr_word; // The low word of the 64-bit address
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR basep2_r() : addr_word(static_cast<uint32_t>(0)) {}
    CONSTEXPR basep2_r(uint32_t value) : addr_word(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        addr_word = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (addr_word << 0);
    }
    basep2_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR basep2_r() : addr_word(static_cast<uint32_t>(0)) {}
    CONSTEXPR basep2_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    basep2_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_addr_word() const
    {
        uint32_t value = static_cast<uint32_t>(addr_word);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_addr_word() const volatile
    {
        uint32_t value = static_cast<uint32_t>(addr_word);
        return value;
    }
#endif
    CONSTEXPR basep2_r &set_addr_word(uint32_t value)
    {
        addr_word = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// basep3_r - Upper 32 bits of the Base pointer for region index 1
struct basep3_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> addr_word; // The high word of the 64-bit address
#else
    union
    {
        uint32_t addr_word; // The high word of the 64-bit address
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR basep3_r() : addr_word(static_cast<uint32_t>(0)) {}
    CONSTEXPR basep3_r(uint32_t value) : addr_word(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        addr_word = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (addr_word << 0);
    }
    basep3_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR basep3_r() : addr_word(static_cast<uint32_t>(0)) {}
    CONSTEXPR basep3_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    basep3_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_addr_word() const
    {
        uint32_t value = static_cast<uint32_t>(addr_word);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_addr_word() const volatile
    {
        uint32_t value = static_cast<uint32_t>(addr_word);
        return value;
    }
#endif
    CONSTEXPR basep3_r &set_addr_word(uint32_t value)
    {
        addr_word = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// basep4_r - Lower 32 bits of the Base pointer for region index 2
struct basep4_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> addr_word; // The low word of the 64-bit address
#else
    union
    {
        uint32_t addr_word; // The low word of the 64-bit address
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR basep4_r() : addr_word(static_cast<uint32_t>(0)) {}
    CONSTEXPR basep4_r(uint32_t value) : addr_word(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        addr_word = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (addr_word << 0);
    }
    basep4_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR basep4_r() : addr_word(static_cast<uint32_t>(0)) {}
    CONSTEXPR basep4_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    basep4_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_addr_word() const
    {
        uint32_t value = static_cast<uint32_t>(addr_word);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_addr_word() const volatile
    {
        uint32_t value = static_cast<uint32_t>(addr_word);
        return value;
    }
#endif
    CONSTEXPR basep4_r &set_addr_word(uint32_t value)
    {
        addr_word = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// basep5_r - Upper 32 bits of the Base pointer for region index 2
struct basep5_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> addr_word; // The high word of the 64-bit address
#else
    union
    {
        uint32_t addr_word; // The high word of the 64-bit address
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR basep5_r() : addr_word(static_cast<uint32_t>(0)) {}
    CONSTEXPR basep5_r(uint32_t value) : addr_word(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        addr_word = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (addr_word << 0);
    }
    basep5_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR basep5_r() : addr_word(static_cast<uint32_t>(0)) {}
    CONSTEXPR basep5_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    basep5_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_addr_word() const
    {
        uint32_t value = static_cast<uint32_t>(addr_word);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_addr_word() const volatile
    {
        uint32_t value = static_cast<uint32_t>(addr_word);
        return value;
    }
#endif
    CONSTEXPR basep5_r &set_addr_word(uint32_t value)
    {
        addr_word = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// basep6_r - Lower 32 bits of the Base pointer for region index 3
struct basep6_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> addr_word; // The low word of the 64-bit address
#else
    union
    {
        uint32_t addr_word; // The low word of the 64-bit address
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR basep6_r() : addr_word(static_cast<uint32_t>(0)) {}
    CONSTEXPR basep6_r(uint32_t value) : addr_word(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        addr_word = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (addr_word << 0);
    }
    basep6_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR basep6_r() : addr_word(static_cast<uint32_t>(0)) {}
    CONSTEXPR basep6_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    basep6_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_addr_word() const
    {
        uint32_t value = static_cast<uint32_t>(addr_word);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_addr_word() const volatile
    {
        uint32_t value = static_cast<uint32_t>(addr_word);
        return value;
    }
#endif
    CONSTEXPR basep6_r &set_addr_word(uint32_t value)
    {
        addr_word = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// basep7_r - Upper 32 bits of the Base pointer for region index 3
struct basep7_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> addr_word; // The high word of the 64-bit address
#else
    union
    {
        uint32_t addr_word; // The high word of the 64-bit address
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR basep7_r() : addr_word(static_cast<uint32_t>(0)) {}
    CONSTEXPR basep7_r(uint32_t value) : addr_word(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        addr_word = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (addr_word << 0);
    }
    basep7_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR basep7_r() : addr_word(static_cast<uint32_t>(0)) {}
    CONSTEXPR basep7_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    basep7_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_addr_word() const
    {
        uint32_t value = static_cast<uint32_t>(addr_word);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_addr_word() const volatile
    {
        uint32_t value = static_cast<uint32_t>(addr_word);
        return value;
    }
#endif
    CONSTEXPR basep7_r &set_addr_word(uint32_t value)
    {
        addr_word = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// basep8_r - Lower 32 bits of the Base pointer for region index 4
struct basep8_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> addr_word; // The low word of the 64-bit address
#else
    union
    {
        uint32_t addr_word; // The low word of the 64-bit address
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR basep8_r() : addr_word(static_cast<uint32_t>(0)) {}
    CONSTEXPR basep8_r(uint32_t value) : addr_word(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        addr_word = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (addr_word << 0);
    }
    basep8_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR basep8_r() : addr_word(static_cast<uint32_t>(0)) {}
    CONSTEXPR basep8_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    basep8_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_addr_word() const
    {
        uint32_t value = static_cast<uint32_t>(addr_word);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_addr_word() const volatile
    {
        uint32_t value = static_cast<uint32_t>(addr_word);
        return value;
    }
#endif
    CONSTEXPR basep8_r &set_addr_word(uint32_t value)
    {
        addr_word = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// basep9_r - Upper 32 bits of the Base pointer for region index 4
struct basep9_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> addr_word; // The high word of the 64-bit address
#else
    union
    {
        uint32_t addr_word; // The high word of the 64-bit address
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR basep9_r() : addr_word(static_cast<uint32_t>(0)) {}
    CONSTEXPR basep9_r(uint32_t value) : addr_word(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        addr_word = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (addr_word << 0);
    }
    basep9_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR basep9_r() : addr_word(static_cast<uint32_t>(0)) {}
    CONSTEXPR basep9_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    basep9_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_addr_word() const
    {
        uint32_t value = static_cast<uint32_t>(addr_word);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_addr_word() const volatile
    {
        uint32_t value = static_cast<uint32_t>(addr_word);
        return value;
    }
#endif
    CONSTEXPR basep9_r &set_addr_word(uint32_t value)
    {
        addr_word = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// basep10_r - Lower 32 bits of the Base pointer for region index 5
struct basep10_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> addr_word; // The low word of the 64-bit address
#else
    union
    {
        uint32_t addr_word; // The low word of the 64-bit address
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR basep10_r() : addr_word(static_cast<uint32_t>(0)) {}
    CONSTEXPR basep10_r(uint32_t value) : addr_word(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        addr_word = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (addr_word << 0);
    }
    basep10_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR basep10_r() : addr_word(static_cast<uint32_t>(0)) {}
    CONSTEXPR basep10_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    basep10_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_addr_word() const
    {
        uint32_t value = static_cast<uint32_t>(addr_word);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_addr_word() const volatile
    {
        uint32_t value = static_cast<uint32_t>(addr_word);
        return value;
    }
#endif
    CONSTEXPR basep10_r &set_addr_word(uint32_t value)
    {
        addr_word = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// basep11_r - Upper 32 bits of the Base pointer for region index 5
struct basep11_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> addr_word; // The high word of the 64-bit address
#else
    union
    {
        uint32_t addr_word; // The high word of the 64-bit address
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR basep11_r() : addr_word(static_cast<uint32_t>(0)) {}
    CONSTEXPR basep11_r(uint32_t value) : addr_word(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        addr_word = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (addr_word << 0);
    }
    basep11_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR basep11_r() : addr_word(static_cast<uint32_t>(0)) {}
    CONSTEXPR basep11_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    basep11_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_addr_word() const
    {
        uint32_t value = static_cast<uint32_t>(addr_word);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_addr_word() const volatile
    {
        uint32_t value = static_cast<uint32_t>(addr_word);
        return value;
    }
#endif
    CONSTEXPR basep11_r &set_addr_word(uint32_t value)
    {
        addr_word = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// basep12_r - Lower 32 bits of the Base pointer for region index 6
struct basep12_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> addr_word; // The low word of the 64-bit address
#else
    union
    {
        uint32_t addr_word; // The low word of the 64-bit address
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR basep12_r() : addr_word(static_cast<uint32_t>(0)) {}
    CONSTEXPR basep12_r(uint32_t value) : addr_word(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        addr_word = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (addr_word << 0);
    }
    basep12_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR basep12_r() : addr_word(static_cast<uint32_t>(0)) {}
    CONSTEXPR basep12_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    basep12_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_addr_word() const
    {
        uint32_t value = static_cast<uint32_t>(addr_word);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_addr_word() const volatile
    {
        uint32_t value = static_cast<uint32_t>(addr_word);
        return value;
    }
#endif
    CONSTEXPR basep12_r &set_addr_word(uint32_t value)
    {
        addr_word = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// basep13_r - Upper 32 bits of the Base pointer for region index 6
struct basep13_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> addr_word; // The high word of the 64-bit address
#else
    union
    {
        uint32_t addr_word; // The high word of the 64-bit address
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR basep13_r() : addr_word(static_cast<uint32_t>(0)) {}
    CONSTEXPR basep13_r(uint32_t value) : addr_word(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        addr_word = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (addr_word << 0);
    }
    basep13_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR basep13_r() : addr_word(static_cast<uint32_t>(0)) {}
    CONSTEXPR basep13_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    basep13_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_addr_word() const
    {
        uint32_t value = static_cast<uint32_t>(addr_word);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_addr_word() const volatile
    {
        uint32_t value = static_cast<uint32_t>(addr_word);
        return value;
    }
#endif
    CONSTEXPR basep13_r &set_addr_word(uint32_t value)
    {
        addr_word = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// basep14_r - Lower 32 bits of the Base pointer for region index 7
struct basep14_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> addr_word; // The low word of the 64-bit address
#else
    union
    {
        uint32_t addr_word; // The low word of the 64-bit address
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR basep14_r() : addr_word(static_cast<uint32_t>(0)) {}
    CONSTEXPR basep14_r(uint32_t value) : addr_word(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        addr_word = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (addr_word << 0);
    }
    basep14_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR basep14_r() : addr_word(static_cast<uint32_t>(0)) {}
    CONSTEXPR basep14_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    basep14_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_addr_word() const
    {
        uint32_t value = static_cast<uint32_t>(addr_word);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_addr_word() const volatile
    {
        uint32_t value = static_cast<uint32_t>(addr_word);
        return value;
    }
#endif
    CONSTEXPR basep14_r &set_addr_word(uint32_t value)
    {
        addr_word = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// basep15_r - Upper 32 bits of the Base pointer for region index 7
struct basep15_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> addr_word; // The high word of the 64-bit address
#else
    union
    {
        uint32_t addr_word; // The high word of the 64-bit address
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR basep15_r() : addr_word(static_cast<uint32_t>(0)) {}
    CONSTEXPR basep15_r(uint32_t value) : addr_word(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        addr_word = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (addr_word << 0);
    }
    basep15_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR basep15_r() : addr_word(static_cast<uint32_t>(0)) {}
    CONSTEXPR basep15_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    basep15_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_addr_word() const
    {
        uint32_t value = static_cast<uint32_t>(addr_word);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_addr_word() const volatile
    {
        uint32_t value = static_cast<uint32_t>(addr_word);
        return value;
    }
#endif
    CONSTEXPR basep15_r &set_addr_word(uint32_t value)
    {
        addr_word = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// pid4_r - Peripheral ID byte 4 (Arm=code 4)
struct pid4_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> PID4; // Byte 4 of Peripheral ID (Lower 8 bits valid)
#else
    union
    {
        uint32_t PID4; // Byte 4 of Peripheral ID (Lower 8 bits valid)
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR pid4_r() : PID4(static_cast<uint32_t>(0x04)) {}
    CONSTEXPR pid4_r(uint32_t value) : PID4(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        PID4 = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (PID4 << 0);
    }
    pid4_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR pid4_r() : PID4(static_cast<uint32_t>(0x04)) {}
    CONSTEXPR pid4_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    pid4_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_PID4() const
    {
        uint32_t value = static_cast<uint32_t>(PID4);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_PID4() const volatile
    {
        uint32_t value = static_cast<uint32_t>(PID4);
        return value;
    }
#endif
    CONSTEXPR pid4_r &set_PID4(uint32_t value)
    {
        PID4 = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// pid5_r - Peripheral ID byte 5 (reserved)
struct pid5_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> PID5; // Byte 5 of Peripheral ID (Lower 8 bits valid)
#else
    union
    {
        uint32_t PID5; // Byte 5 of Peripheral ID (Lower 8 bits valid)
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR pid5_r() : PID5(static_cast<uint32_t>(0x00)) {}
    CONSTEXPR pid5_r(uint32_t value) : PID5(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        PID5 = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (PID5 << 0);
    }
    pid5_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR pid5_r() : PID5(static_cast<uint32_t>(0x00)) {}
    CONSTEXPR pid5_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    pid5_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_PID5() const
    {
        uint32_t value = static_cast<uint32_t>(PID5);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_PID5() const volatile
    {
        uint32_t value = static_cast<uint32_t>(PID5);
        return value;
    }
#endif
    CONSTEXPR pid5_r &set_PID5(uint32_t value)
    {
        PID5 = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// pid6_r - Peripheral ID byte 6 (reserved)
struct pid6_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> PID6; // Byte 6 of Peripheral ID (Lower 8 bits valid)
#else
    union
    {
        uint32_t PID6; // Byte 6 of Peripheral ID (Lower 8 bits valid)
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR pid6_r() : PID6(static_cast<uint32_t>(0x00)) {}
    CONSTEXPR pid6_r(uint32_t value) : PID6(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        PID6 = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (PID6 << 0);
    }
    pid6_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR pid6_r() : PID6(static_cast<uint32_t>(0x00)) {}
    CONSTEXPR pid6_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    pid6_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_PID6() const
    {
        uint32_t value = static_cast<uint32_t>(PID6);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_PID6() const volatile
    {
        uint32_t value = static_cast<uint32_t>(PID6);
        return value;
    }
#endif
    CONSTEXPR pid6_r &set_PID6(uint32_t value)
    {
        PID6 = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// pid7_r - Peripheral ID byte 7 (reserved)
struct pid7_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> PID7; // Byte 7 of Peripheral ID (Lower 8 bits valid)
#else
    union
    {
        uint32_t PID7; // Byte 7 of Peripheral ID (Lower 8 bits valid)
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR pid7_r() : PID7(static_cast<uint32_t>(0x00)) {}
    CONSTEXPR pid7_r(uint32_t value) : PID7(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        PID7 = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (PID7 << 0);
    }
    pid7_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR pid7_r() : PID7(static_cast<uint32_t>(0x00)) {}
    CONSTEXPR pid7_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    pid7_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_PID7() const
    {
        uint32_t value = static_cast<uint32_t>(PID7);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_PID7() const volatile
    {
        uint32_t value = static_cast<uint32_t>(PID7);
        return value;
    }
#endif
    CONSTEXPR pid7_r &set_PID7(uint32_t value)
    {
        PID7 = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// pid0_r - Peripheral ID byte 0. This is bits[7:0] of the part number.
struct pid0_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> PID0; // Byte 0 of Peripheral ID (Lower 8 bits valid)
#else
    union
    {
        uint32_t PID0; // Byte 0 of Peripheral ID (Lower 8 bits valid)
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR pid0_r() : PID0(static_cast<uint32_t>(0x80)) {}
    CONSTEXPR pid0_r(uint32_t value) : PID0(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        PID0 = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (PID0 << 0);
    }
    pid0_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR pid0_r() : PID0(static_cast<uint32_t>(0x80)) {}
    CONSTEXPR pid0_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    pid0_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_PID0() const
    {
        uint32_t value = static_cast<uint32_t>(PID0);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_PID0() const volatile
    {
        uint32_t value = static_cast<uint32_t>(PID0);
        return value;
    }
#endif
    CONSTEXPR pid0_r &set_PID0(uint32_t value)
    {
        PID0 = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// pid1_r - Peripheral ID byte 1. This is bits[11:8] of the part number in bits[3:0], and bits[3:0] of the Arm ID in
// bits[7:4].
struct pid1_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> PID1; // Byte 1 of Peripheral ID (Lower 8 bits valid)
#else
    union
    {
        uint32_t PID1; // Byte 1 of Peripheral ID (Lower 8 bits valid)
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR pid1_r() : PID1(static_cast<uint32_t>(0xB5)) {}
    CONSTEXPR pid1_r(uint32_t value) : PID1(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        PID1 = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (PID1 << 0);
    }
    pid1_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR pid1_r() : PID1(static_cast<uint32_t>(0xB5)) {}
    CONSTEXPR pid1_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    pid1_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_PID1() const
    {
        uint32_t value = static_cast<uint32_t>(PID1);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_PID1() const volatile
    {
        uint32_t value = static_cast<uint32_t>(PID1);
        return value;
    }
#endif
    CONSTEXPR pid1_r &set_PID1(uint32_t value)
    {
        PID1 = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// pid2_r - Peripheral ID byte 2. This is bits[6:4] of the Arm ID in bits[2:0], and bit 3 indicates format B.
struct pid2_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> PID2; // Byte 2 of Peripheral ID (Lower 8 bits valid)
#else
    union
    {
        uint32_t PID2; // Byte 2 of Peripheral ID (Lower 8 bits valid)
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR pid2_r() : PID2(static_cast<uint32_t>(0x0B)) {}
    CONSTEXPR pid2_r(uint32_t value) : PID2(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        PID2 = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (PID2 << 0);
    }
    pid2_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR pid2_r() : PID2(static_cast<uint32_t>(0x0B)) {}
    CONSTEXPR pid2_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    pid2_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_PID2() const
    {
        uint32_t value = static_cast<uint32_t>(PID2);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_PID2() const volatile
    {
        uint32_t value = static_cast<uint32_t>(PID2);
        return value;
    }
#endif
    CONSTEXPR pid2_r &set_PID2(uint32_t value)
    {
        PID2 = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// pid3_r - Peripheral ID byte 3.
struct pid3_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> PID3; // Byte 1 of Peripheral ID (Lower 8 bits valid)
#else
    union
    {
        uint32_t PID3; // Byte 1 of Peripheral ID (Lower 8 bits valid)
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR pid3_r() : PID3(static_cast<uint32_t>(0x0)) {}
    CONSTEXPR pid3_r(uint32_t value) : PID3(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        PID3 = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (PID3 << 0);
    }
    pid3_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR pid3_r() : PID3(static_cast<uint32_t>(0x0)) {}
    CONSTEXPR pid3_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    pid3_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_PID3() const
    {
        uint32_t value = static_cast<uint32_t>(PID3);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_PID3() const volatile
    {
        uint32_t value = static_cast<uint32_t>(PID3);
        return value;
    }
#endif
    CONSTEXPR pid3_r &set_PID3(uint32_t value)
    {
        PID3 = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// cid0_r - Component ID byte 0.
struct cid0_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> CID0; // Byte 0 of Component ID (Lower 8 bits valid)
#else
    union
    {
        uint32_t CID0; // Byte 0 of Component ID (Lower 8 bits valid)
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR cid0_r() : CID0(static_cast<uint32_t>(0x0D)) {}
    CONSTEXPR cid0_r(uint32_t value) : CID0(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        CID0 = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (CID0 << 0);
    }
    cid0_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR cid0_r() : CID0(static_cast<uint32_t>(0x0D)) {}
    CONSTEXPR cid0_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    cid0_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_CID0() const
    {
        uint32_t value = static_cast<uint32_t>(CID0);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_CID0() const volatile
    {
        uint32_t value = static_cast<uint32_t>(CID0);
        return value;
    }
#endif
    CONSTEXPR cid0_r &set_CID0(uint32_t value)
    {
        CID0 = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// cid1_r - Component ID byte 1.
struct cid1_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> CID1; // Byte 1 of Component ID (Lower 8 bits valid)
#else
    union
    {
        uint32_t CID1; // Byte 1 of Component ID (Lower 8 bits valid)
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR cid1_r() : CID1(static_cast<uint32_t>(0xF0)) {}
    CONSTEXPR cid1_r(uint32_t value) : CID1(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        CID1 = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (CID1 << 0);
    }
    cid1_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR cid1_r() : CID1(static_cast<uint32_t>(0xF0)) {}
    CONSTEXPR cid1_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    cid1_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_CID1() const
    {
        uint32_t value = static_cast<uint32_t>(CID1);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_CID1() const volatile
    {
        uint32_t value = static_cast<uint32_t>(CID1);
        return value;
    }
#endif
    CONSTEXPR cid1_r &set_CID1(uint32_t value)
    {
        CID1 = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// cid2_r - Component ID byte 2.
struct cid2_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> CID2; // Byte 2 of Component ID (Lower 8 bits valid)
#else
    union
    {
        uint32_t CID2; // Byte 2 of Component ID (Lower 8 bits valid)
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR cid2_r() : CID2(static_cast<uint32_t>(0x05)) {}
    CONSTEXPR cid2_r(uint32_t value) : CID2(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        CID2 = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (CID2 << 0);
    }
    cid2_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR cid2_r() : CID2(static_cast<uint32_t>(0x05)) {}
    CONSTEXPR cid2_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    cid2_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_CID2() const
    {
        uint32_t value = static_cast<uint32_t>(CID2);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_CID2() const volatile
    {
        uint32_t value = static_cast<uint32_t>(CID2);
        return value;
    }
#endif
    CONSTEXPR cid2_r &set_CID2(uint32_t value)
    {
        CID2 = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// cid3_r - Component ID byte 3.
struct cid3_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> CID3; // Byte 3 of Component ID (Lower 8 bits valid)
#else
    union
    {
        uint32_t CID3; // Byte 3 of Component ID (Lower 8 bits valid)
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR cid3_r() : CID3(static_cast<uint32_t>(0xB1)) {}
    CONSTEXPR cid3_r(uint32_t value) : CID3(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        CID3 = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (CID3 << 0);
    }
    cid3_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR cid3_r() : CID3(static_cast<uint32_t>(0xB1)) {}
    CONSTEXPR cid3_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    cid3_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_CID3() const
    {
        uint32_t value = static_cast<uint32_t>(CID3);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_CID3() const volatile
    {
        uint32_t value = static_cast<uint32_t>(CID3);
        return value;
    }
#endif
    CONSTEXPR cid3_r &set_CID3(uint32_t value)
    {
        CID3 = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// id_r - ID register
struct id_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<4> version_status; // 0 for now
    ::core::dt::uint_t<4> version_minor;  // This is the n for the P part of an RnPn release number
    ::core::dt::uint_t<4> version_major;  // This is the n for the R part of an RnPn release number
    ::core::dt::uint_t<4> product_major;  // 0 for now
    ::core::dt::uint_t<4> arch_patch_rev; // This is the patch number of the architecture version a.b
    ::core::dt::uint_t<8>
        arch_minor_rev; // This is the minor architecture version number, b in the architecture version a.b
    ::core::dt::uint_t<4>
        arch_major_rev; // This is the major architecture version number, a in the architecture version a.b
#else
    union
    {
        struct
        {
            uint32_t version_status : 4; // 0 for now
            uint32_t version_minor : 4;  // This is the n for the P part of an RnPn release number
            uint32_t version_major : 4;  // This is the n for the R part of an RnPn release number
            uint32_t product_major : 4;  // 0 for now
            uint32_t arch_patch_rev : 4; // This is the patch number of the architecture version a.b
            uint32_t
                arch_minor_rev : 8; // This is the minor architecture version number, b in the architecture version a.b
            uint32_t
                arch_major_rev : 4; // This is the major architecture version number, a in the architecture version a.b
        };
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR id_r() :
        version_status(static_cast<uint32_t>(0x0)), version_minor(static_cast<uint32_t>(0x0)),
        version_major(static_cast<uint32_t>(0x0)), product_major(static_cast<uint32_t>(0x0)),
        arch_patch_rev(static_cast<uint32_t>(0)), arch_minor_rev(static_cast<uint32_t>(154)),
        arch_major_rev(static_cast<uint32_t>(0))
    {
    }
    CONSTEXPR id_r(uint32_t value) :
        version_status(value >> 0), version_minor(value >> 4), version_major(value >> 8), product_major(value >> 12),
        arch_patch_rev(value >> 16), arch_minor_rev(value >> 20), arch_major_rev(value >> 28)
    {
    }
    CONSTEXPR void operator=(uint32_t value)
    {
        version_status = value >> 0;
        version_minor  = value >> 4;
        version_major  = value >> 8;
        product_major  = value >> 12;
        arch_patch_rev = value >> 16;
        arch_minor_rev = value >> 20;
        arch_major_rev = value >> 28;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (version_status << 0) | (version_minor << 4) | (version_major << 8) | (product_major << 12) |
               (arch_patch_rev << 16) | (arch_minor_rev << 20) | (arch_major_rev << 28);
    }
    id_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR id_r() :
        version_status(static_cast<uint32_t>(0x0)), version_minor(static_cast<uint32_t>(0x0)),
        version_major(static_cast<uint32_t>(0x0)), product_major(static_cast<uint32_t>(0x0)),
        arch_patch_rev(static_cast<uint32_t>(0)), arch_minor_rev(static_cast<uint32_t>(154)),
        arch_major_rev(static_cast<uint32_t>(0))
    {
    }
    CONSTEXPR id_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    id_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_version_status() const
    {
        uint32_t value = static_cast<uint32_t>(version_status);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_version_status() const volatile
    {
        uint32_t value = static_cast<uint32_t>(version_status);
        return value;
    }
#endif
    CONSTEXPR id_r &set_version_status(uint32_t value)
    {
        version_status = ((1u << 4) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_version_minor() const
    {
        uint32_t value = static_cast<uint32_t>(version_minor);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_version_minor() const volatile
    {
        uint32_t value = static_cast<uint32_t>(version_minor);
        return value;
    }
#endif
    CONSTEXPR id_r &set_version_minor(uint32_t value)
    {
        version_minor = ((1u << 4) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_version_major() const
    {
        uint32_t value = static_cast<uint32_t>(version_major);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_version_major() const volatile
    {
        uint32_t value = static_cast<uint32_t>(version_major);
        return value;
    }
#endif
    CONSTEXPR id_r &set_version_major(uint32_t value)
    {
        version_major = ((1u << 4) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_product_major() const
    {
        uint32_t value = static_cast<uint32_t>(product_major);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_product_major() const volatile
    {
        uint32_t value = static_cast<uint32_t>(product_major);
        return value;
    }
#endif
    CONSTEXPR id_r &set_product_major(uint32_t value)
    {
        product_major = ((1u << 4) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_arch_patch_rev() const
    {
        uint32_t value = static_cast<uint32_t>(arch_patch_rev);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_arch_patch_rev() const volatile
    {
        uint32_t value = static_cast<uint32_t>(arch_patch_rev);
        return value;
    }
#endif
    CONSTEXPR id_r &set_arch_patch_rev(uint32_t value)
    {
        arch_patch_rev = ((1u << 4) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_arch_minor_rev() const
    {
        uint32_t value = static_cast<uint32_t>(arch_minor_rev);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_arch_minor_rev() const volatile
    {
        uint32_t value = static_cast<uint32_t>(arch_minor_rev);
        return value;
    }
#endif
    CONSTEXPR id_r &set_arch_minor_rev(uint32_t value)
    {
        arch_minor_rev = ((1u << 8) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_arch_major_rev() const
    {
        uint32_t value = static_cast<uint32_t>(arch_major_rev);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_arch_major_rev() const volatile
    {
        uint32_t value = static_cast<uint32_t>(arch_major_rev);
        return value;
    }
#endif
    CONSTEXPR id_r &set_arch_major_rev(uint32_t value)
    {
        arch_major_rev = ((1u << 4) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// status_r - Register describes the current operating status of the NPU
struct status_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<1> state; // NPU state, 0 = Stopped, 1 = Running
    ::core::dt::uint_t<1>
        irq_raised; // Raw IRQ status, 0 = IRQ not raised, 1 = IRQ raised. IRQ is cleared using command register bit 1
    ::core::dt::uint_t<1>
        bus_status; // 0=OK, 1=Bus abort detected and processing halted (NPU will reach IDLE state and not to start
                    // process any more commands/AXI transactions). Can only be cleared by a reset
    ::core::dt::uint_t<1>
        reset_status; // Reset is ongoing and only this register can be read (other registers read as 0 and writes are
                      // ignored.) A value of 0 means NPU is not being reset and can be accessed as normal
    ::core::dt::uint_t<1>
        cmd_parse_error; // 0=No error 1=Command stream parsing error detected. Can only be cleared by reset
    ::core::dt::uint_t<1>
        cmd_end_reached; // 0=Not reached, 1=Reached. Cleared by writing QBASE or QSIZE when NPU is in stopped state
    ::core::dt::uint_t<1> pmu_irq_raised; // 0=No PMU IRQ, 1=PMU IRQ raised. Cleared by using command register bit 1
    ::core::dt::uint_t<1>
        wd_fault; // Weight decoder state: 0=no fault 1=weight decoder decompression fault. Can only be cleared by reset
    ::core::dt::uint_t<1> faulting_interface; // Faulting interface on bus abort. 0=AXI-M0 1=AXI-M1
    ::core::dt::uint_t<4> faulting_channel; // Faulting channel on a bus abort. Read: 0=Cmd 1=IFM 2=Weights 3=Scale+Bias
                                            // 4=Mem2Mem; Write: 8=OFM 9=Mem2Mem
    ::core::dt::uint_t<16> irq_history_mask; // IRQ History mask
#else
    union
    {
        struct
        {
            uint32_t state : 1;      // NPU state, 0 = Stopped, 1 = Running
            uint32_t irq_raised : 1; // Raw IRQ status, 0 = IRQ not raised, 1 = IRQ raised. IRQ is cleared using command
                                     // register bit 1
            uint32_t
                bus_status : 1; // 0=OK, 1=Bus abort detected and processing halted (NPU will reach IDLE state and not
                                // to start process any more commands/AXI transactions). Can only be cleared by a reset
            uint32_t reset_status : 1; // Reset is ongoing and only this register can be read (other registers read as 0
                                       // and writes are ignored.) A value of 0 means NPU is not being reset and can be
                                       // accessed as normal
            uint32_t
                cmd_parse_error : 1; // 0=No error 1=Command stream parsing error detected. Can only be cleared by reset
            uint32_t cmd_end_reached : 1; // 0=Not reached, 1=Reached. Cleared by writing QBASE or QSIZE when NPU is in
                                          // stopped state
            uint32_t pmu_irq_raised : 1;  // 0=No PMU IRQ, 1=PMU IRQ raised. Cleared by using command register bit 1
            uint32_t wd_fault : 1; // Weight decoder state: 0=no fault 1=weight decoder decompression fault. Can only be
                                   // cleared by reset
            uint32_t reserved0 : 3;
            uint32_t faulting_interface : 1; // Faulting interface on bus abort. 0=AXI-M0 1=AXI-M1
            uint32_t faulting_channel : 4;  // Faulting channel on a bus abort. Read: 0=Cmd 1=IFM 2=Weights 3=Scale+Bias
                                            // 4=Mem2Mem; Write: 8=OFM 9=Mem2Mem
            uint32_t irq_history_mask : 16; // IRQ History mask
        };
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR status_r() :
        state(static_cast<uint32_t>(::state::STOPPED)), irq_raised(static_cast<uint32_t>(0x0)),
        bus_status(static_cast<uint32_t>(0x0)), reset_status(static_cast<uint32_t>(0x1)),
        cmd_parse_error(static_cast<uint32_t>(0x0)), cmd_end_reached(static_cast<uint32_t>(0x0)),
        pmu_irq_raised(static_cast<uint32_t>(0x0)), wd_fault(static_cast<uint32_t>(0x0)),
        faulting_interface(static_cast<uint32_t>(0x0)), faulting_channel(static_cast<uint32_t>(0x0)),
        irq_history_mask(static_cast<uint32_t>(0x0))
    {
    }
    CONSTEXPR status_r(uint32_t value) :
        state(value >> 0), irq_raised(value >> 1), bus_status(value >> 2), reset_status(value >> 3),
        cmd_parse_error(value >> 4), cmd_end_reached(value >> 5), pmu_irq_raised(value >> 6), wd_fault(value >> 7),
        faulting_interface(value >> 11), faulting_channel(value >> 12), irq_history_mask(value >> 16)
    {
    }
    CONSTEXPR void operator=(uint32_t value)
    {
        state              = value >> 0;
        irq_raised         = value >> 1;
        bus_status         = value >> 2;
        reset_status       = value >> 3;
        cmd_parse_error    = value >> 4;
        cmd_end_reached    = value >> 5;
        pmu_irq_raised     = value >> 6;
        wd_fault           = value >> 7;
        faulting_interface = value >> 11;
        faulting_channel   = value >> 12;
        irq_history_mask   = value >> 16;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (state << 0) | (irq_raised << 1) | (bus_status << 2) | (reset_status << 3) | (cmd_parse_error << 4) |
               (cmd_end_reached << 5) | (pmu_irq_raised << 6) | (wd_fault << 7) | (faulting_interface << 11) |
               (faulting_channel << 12) | (irq_history_mask << 16);
    }
    status_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR status_r() :
        state(static_cast<uint32_t>(::state::STOPPED)), irq_raised(static_cast<uint32_t>(0x0)),
        bus_status(static_cast<uint32_t>(0x0)), reset_status(static_cast<uint32_t>(0x1)),
        cmd_parse_error(static_cast<uint32_t>(0x0)), cmd_end_reached(static_cast<uint32_t>(0x0)),
        pmu_irq_raised(static_cast<uint32_t>(0x0)), wd_fault(static_cast<uint32_t>(0x0)),
        reserved0(static_cast<uint32_t>(0)), faulting_interface(static_cast<uint32_t>(0x0)),
        faulting_channel(static_cast<uint32_t>(0x0)), irq_history_mask(static_cast<uint32_t>(0x0))
    {
    }
    CONSTEXPR status_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    status_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR ::state get_state() const
    {
        ::state value = static_cast<::state>(state);
        return value;
    }
#ifndef MODEL_REGS
    ::state get_state() const volatile
    {
        ::state value = static_cast<::state>(state);
        return value;
    }
#endif
    CONSTEXPR status_r &set_state(::state value)
    {
        state = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_irq_raised() const
    {
        uint32_t value = static_cast<uint32_t>(irq_raised);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_irq_raised() const volatile
    {
        uint32_t value = static_cast<uint32_t>(irq_raised);
        return value;
    }
#endif
    CONSTEXPR status_r &set_irq_raised(uint32_t value)
    {
        irq_raised = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_bus_status() const
    {
        uint32_t value = static_cast<uint32_t>(bus_status);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_bus_status() const volatile
    {
        uint32_t value = static_cast<uint32_t>(bus_status);
        return value;
    }
#endif
    CONSTEXPR status_r &set_bus_status(uint32_t value)
    {
        bus_status = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_reset_status() const
    {
        uint32_t value = static_cast<uint32_t>(reset_status);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_reset_status() const volatile
    {
        uint32_t value = static_cast<uint32_t>(reset_status);
        return value;
    }
#endif
    CONSTEXPR status_r &set_reset_status(uint32_t value)
    {
        reset_status = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_cmd_parse_error() const
    {
        uint32_t value = static_cast<uint32_t>(cmd_parse_error);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_cmd_parse_error() const volatile
    {
        uint32_t value = static_cast<uint32_t>(cmd_parse_error);
        return value;
    }
#endif
    CONSTEXPR status_r &set_cmd_parse_error(uint32_t value)
    {
        cmd_parse_error = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_cmd_end_reached() const
    {
        uint32_t value = static_cast<uint32_t>(cmd_end_reached);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_cmd_end_reached() const volatile
    {
        uint32_t value = static_cast<uint32_t>(cmd_end_reached);
        return value;
    }
#endif
    CONSTEXPR status_r &set_cmd_end_reached(uint32_t value)
    {
        cmd_end_reached = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_pmu_irq_raised() const
    {
        uint32_t value = static_cast<uint32_t>(pmu_irq_raised);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_pmu_irq_raised() const volatile
    {
        uint32_t value = static_cast<uint32_t>(pmu_irq_raised);
        return value;
    }
#endif
    CONSTEXPR status_r &set_pmu_irq_raised(uint32_t value)
    {
        pmu_irq_raised = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_wd_fault() const
    {
        uint32_t value = static_cast<uint32_t>(wd_fault);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_wd_fault() const volatile
    {
        uint32_t value = static_cast<uint32_t>(wd_fault);
        return value;
    }
#endif
    CONSTEXPR status_r &set_wd_fault(uint32_t value)
    {
        wd_fault = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_faulting_interface() const
    {
        uint32_t value = static_cast<uint32_t>(faulting_interface);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_faulting_interface() const volatile
    {
        uint32_t value = static_cast<uint32_t>(faulting_interface);
        return value;
    }
#endif
    CONSTEXPR status_r &set_faulting_interface(uint32_t value)
    {
        faulting_interface = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_faulting_channel() const
    {
        uint32_t value = static_cast<uint32_t>(faulting_channel);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_faulting_channel() const volatile
    {
        uint32_t value = static_cast<uint32_t>(faulting_channel);
        return value;
    }
#endif
    CONSTEXPR status_r &set_faulting_channel(uint32_t value)
    {
        faulting_channel = ((1u << 4) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_irq_history_mask() const
    {
        uint32_t value = static_cast<uint32_t>(irq_history_mask);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_irq_history_mask() const volatile
    {
        uint32_t value = static_cast<uint32_t>(irq_history_mask);
        return value;
    }
#endif
    CONSTEXPR status_r &set_irq_history_mask(uint32_t value)
    {
        irq_history_mask = ((1u << 16) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// cmd_r - Command register, reads as last written command
struct cmd_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<1>
        transition_to_running_state; // Write 1 to transition the NPU to running state. Writing 0 has no effect
    ::core::dt::uint_t<1> clear_irq; // Write 1 to clear the IRQ status in the STATUS register. Writing 0 has no effect
    ::core::dt::uint_t<1> clock_q_enable; // Write 1 to this bit to enable clock off using clock q-interface and enable
                                          // the master clock gate
    ::core::dt::uint_t<1> power_q_enable; // Write 1 to this bit to enable power off using power q-interface
    ::core::dt::uint_t<1>
        stop_request; // Write 1 to this bit to request STOP after completing any already-started commands
    ::core::dt::uint_t<16> clear_irq_history; // Clears the IRQ history mask
#else
    union
    {
        struct
        {
            uint32_t transition_to_running_state : 1; // Write 1 to transition the NPU to running state. Writing 0 has
                                                      // no effect
            uint32_t clear_irq : 1; // Write 1 to clear the IRQ status in the STATUS register. Writing 0 has no effect
            uint32_t clock_q_enable : 1; // Write 1 to this bit to enable clock off using clock q-interface and enable
                                         // the master clock gate
            uint32_t power_q_enable : 1; // Write 1 to this bit to enable power off using power q-interface
            uint32_t
                stop_request : 1; // Write 1 to this bit to request STOP after completing any already-started commands
            uint32_t reserved0 : 11;
            uint32_t clear_irq_history : 16; // Clears the IRQ history mask
        };
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR cmd_r() :
        transition_to_running_state(static_cast<uint32_t>(0x0)), clear_irq(static_cast<uint32_t>(0x0)),
        clock_q_enable(static_cast<uint32_t>(0x0)), power_q_enable(static_cast<uint32_t>(0x0)),
        stop_request(static_cast<uint32_t>(0x0)), clear_irq_history(static_cast<uint32_t>(0x0))
    {
    }
    CONSTEXPR cmd_r(uint32_t value) :
        transition_to_running_state(value >> 0), clear_irq(value >> 1), clock_q_enable(value >> 2),
        power_q_enable(value >> 3), stop_request(value >> 4), clear_irq_history(value >> 16)
    {
    }
    CONSTEXPR void operator=(uint32_t value)
    {
        transition_to_running_state = value >> 0;
        clear_irq                   = value >> 1;
        clock_q_enable              = value >> 2;
        power_q_enable              = value >> 3;
        stop_request                = value >> 4;
        clear_irq_history           = value >> 16;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (transition_to_running_state << 0) | (clear_irq << 1) | (clock_q_enable << 2) | (power_q_enable << 3) |
               (stop_request << 4) | (clear_irq_history << 16);
    }
    cmd_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR cmd_r() :
        transition_to_running_state(static_cast<uint32_t>(0x0)), clear_irq(static_cast<uint32_t>(0x0)),
        clock_q_enable(static_cast<uint32_t>(0x0)), power_q_enable(static_cast<uint32_t>(0x0)),
        stop_request(static_cast<uint32_t>(0x0)), reserved0(static_cast<uint32_t>(0)),
        clear_irq_history(static_cast<uint32_t>(0x0))
    {
    }
    CONSTEXPR cmd_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    cmd_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_transition_to_running_state() const
    {
        uint32_t value = static_cast<uint32_t>(transition_to_running_state);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_transition_to_running_state() const volatile
    {
        uint32_t value = static_cast<uint32_t>(transition_to_running_state);
        return value;
    }
#endif
    CONSTEXPR cmd_r &set_transition_to_running_state(uint32_t value)
    {
        transition_to_running_state = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_clear_irq() const
    {
        uint32_t value = static_cast<uint32_t>(clear_irq);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_clear_irq() const volatile
    {
        uint32_t value = static_cast<uint32_t>(clear_irq);
        return value;
    }
#endif
    CONSTEXPR cmd_r &set_clear_irq(uint32_t value)
    {
        clear_irq = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_clock_q_enable() const
    {
        uint32_t value = static_cast<uint32_t>(clock_q_enable);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_clock_q_enable() const volatile
    {
        uint32_t value = static_cast<uint32_t>(clock_q_enable);
        return value;
    }
#endif
    CONSTEXPR cmd_r &set_clock_q_enable(uint32_t value)
    {
        clock_q_enable = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_power_q_enable() const
    {
        uint32_t value = static_cast<uint32_t>(power_q_enable);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_power_q_enable() const volatile
    {
        uint32_t value = static_cast<uint32_t>(power_q_enable);
        return value;
    }
#endif
    CONSTEXPR cmd_r &set_power_q_enable(uint32_t value)
    {
        power_q_enable = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_stop_request() const
    {
        uint32_t value = static_cast<uint32_t>(stop_request);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_stop_request() const volatile
    {
        uint32_t value = static_cast<uint32_t>(stop_request);
        return value;
    }
#endif
    CONSTEXPR cmd_r &set_stop_request(uint32_t value)
    {
        stop_request = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_clear_irq_history() const
    {
        uint32_t value = static_cast<uint32_t>(clear_irq_history);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_clear_irq_history() const volatile
    {
        uint32_t value = static_cast<uint32_t>(clear_irq_history);
        return value;
    }
#endif
    CONSTEXPR cmd_r &set_clear_irq_history(uint32_t value)
    {
        clear_irq_history = ((1u << 16) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// reset_r - Request Reset and new security mode
struct reset_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<1> pending_CPL; // Current privilege level 0=User 1=Privileged
    ::core::dt::uint_t<1> pending_CSL; // Current security level 0=Secure 1=Non secure
#else
    union
    {
        struct
        {
            uint32_t pending_CPL : 1; // Current privilege level 0=User 1=Privileged
            uint32_t pending_CSL : 1; // Current security level 0=Secure 1=Non secure
            uint32_t reserved0 : 30;
        };
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR reset_r() :
        pending_CPL(static_cast<uint32_t>(::privilege_level::USER)),
        pending_CSL(static_cast<uint32_t>(::security_level::SECURE))
    {
    }
    CONSTEXPR reset_r(uint32_t value) : pending_CPL(value >> 0), pending_CSL(value >> 1) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        pending_CPL = value >> 0;
        pending_CSL = value >> 1;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (pending_CPL << 0) | (pending_CSL << 1);
    }
    reset_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR reset_r() :
        pending_CPL(static_cast<uint32_t>(::privilege_level::USER)),
        pending_CSL(static_cast<uint32_t>(::security_level::SECURE)), reserved0(static_cast<uint32_t>(0))
    {
    }
    CONSTEXPR reset_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    reset_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR ::privilege_level get_pending_CPL() const
    {
        ::privilege_level value = static_cast<::privilege_level>(pending_CPL);
        return value;
    }
#ifndef MODEL_REGS
    ::privilege_level get_pending_CPL() const volatile
    {
        ::privilege_level value = static_cast<::privilege_level>(pending_CPL);
        return value;
    }
#endif
    CONSTEXPR reset_r &set_pending_CPL(::privilege_level value)
    {
        pending_CPL = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR ::security_level get_pending_CSL() const
    {
        ::security_level value = static_cast<::security_level>(pending_CSL);
        return value;
    }
#ifndef MODEL_REGS
    ::security_level get_pending_CSL() const volatile
    {
        ::security_level value = static_cast<::security_level>(pending_CSL);
        return value;
    }
#endif
    CONSTEXPR reset_r &set_pending_CSL(::security_level value)
    {
        pending_CSL = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// qbase0_r - Base address of command queue bits [31:0]. The address is 4 byte aligned
struct qbase0_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> QBASE0; // The 4 byte aligned lower bytes of the base address value for the command stream
#else
    union
    {
        uint32_t QBASE0; // The 4 byte aligned lower bytes of the base address value for the command stream
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR qbase0_r() : QBASE0(static_cast<uint32_t>(0x00000000)) {}
    CONSTEXPR qbase0_r(uint32_t value) : QBASE0(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        QBASE0 = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (QBASE0 << 0);
    }
    qbase0_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR qbase0_r() : QBASE0(static_cast<uint32_t>(0x00000000)) {}
    CONSTEXPR qbase0_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    qbase0_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_QBASE0() const
    {
        uint32_t value = static_cast<uint32_t>(QBASE0);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_QBASE0() const volatile
    {
        uint32_t value = static_cast<uint32_t>(QBASE0);
        return value;
    }
#endif
    CONSTEXPR qbase0_r &set_QBASE0(uint32_t value)
    {
        QBASE0 = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// qbase1_r - Address extension bits [47:32] bits for queue base
struct qbase1_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> QBASE1; // The 4 byte aligned upper bytes of the base address value for the command stream
#else
    union
    {
        uint32_t QBASE1; // The 4 byte aligned upper bytes of the base address value for the command stream
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR qbase1_r() : QBASE1(static_cast<uint32_t>(0x00000000)) {}
    CONSTEXPR qbase1_r(uint32_t value) : QBASE1(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        QBASE1 = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (QBASE1 << 0);
    }
    qbase1_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR qbase1_r() : QBASE1(static_cast<uint32_t>(0x00000000)) {}
    CONSTEXPR qbase1_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    qbase1_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_QBASE1() const
    {
        uint32_t value = static_cast<uint32_t>(QBASE1);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_QBASE1() const volatile
    {
        uint32_t value = static_cast<uint32_t>(QBASE1);
        return value;
    }
#endif
    CONSTEXPR qbase1_r &set_QBASE1(uint32_t value)
    {
        QBASE1 = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// qread_r - Read offset in the command stream in bytes. Multiple of 4 in the range 0 to 16 MB
struct qread_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> QREAD; // The read offset of the current command under execution
#else
    union
    {
        uint32_t QREAD; // The read offset of the current command under execution
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR qread_r() : QREAD(static_cast<uint32_t>(0x00000000)) {}
    CONSTEXPR qread_r(uint32_t value) : QREAD(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        QREAD = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (QREAD << 0);
    }
    qread_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR qread_r() : QREAD(static_cast<uint32_t>(0x00000000)) {}
    CONSTEXPR qread_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    qread_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_QREAD() const
    {
        uint32_t value = static_cast<uint32_t>(QREAD);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_QREAD() const volatile
    {
        uint32_t value = static_cast<uint32_t>(QREAD);
        return value;
    }
#endif
    CONSTEXPR qread_r &set_QREAD(uint32_t value)
    {
        QREAD = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// qconfig_r - AXI configuration for the command stream in the range 0-3. Same encoding as for REGIONCFG
struct qconfig_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> QCONFIG; // AXI configuration for the command stream in the range 0-3
#else
    union
    {
        uint32_t QCONFIG; // AXI configuration for the command stream in the range 0-3
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR qconfig_r() : QCONFIG(static_cast<uint32_t>(0x00000000)) {}
    CONSTEXPR qconfig_r(uint32_t value) : QCONFIG(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        QCONFIG = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (QCONFIG << 0);
    }
    qconfig_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR qconfig_r() : QCONFIG(static_cast<uint32_t>(0x00000000)) {}
    CONSTEXPR qconfig_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    qconfig_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_QCONFIG() const
    {
        uint32_t value = static_cast<uint32_t>(QCONFIG);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_QCONFIG() const volatile
    {
        uint32_t value = static_cast<uint32_t>(QCONFIG);
        return value;
    }
#endif
    CONSTEXPR qconfig_r &set_QCONFIG(uint32_t value)
    {
        QCONFIG = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// qsize_r - Size of the command stream in bytes. Multiple of 4 in the range 0 to 16 MB
struct qsize_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> QSIZE; // Size of the next command stream to be executed by the NPU
#else
    union
    {
        uint32_t QSIZE; // Size of the next command stream to be executed by the NPU
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR qsize_r() : QSIZE(static_cast<uint32_t>(0x00000000)) {}
    CONSTEXPR qsize_r(uint32_t value) : QSIZE(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        QSIZE = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (QSIZE << 0);
    }
    qsize_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR qsize_r() : QSIZE(static_cast<uint32_t>(0x00000000)) {}
    CONSTEXPR qsize_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    qsize_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_QSIZE() const
    {
        uint32_t value = static_cast<uint32_t>(QSIZE);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_QSIZE() const volatile
    {
        uint32_t value = static_cast<uint32_t>(QSIZE);
        return value;
    }
#endif
    CONSTEXPR qsize_r &set_QSIZE(uint32_t value)
    {
        QSIZE = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// prot_r - Protection level configured for the NPU when acting as an AXI master
struct prot_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<1> active_CPL; // Current privilege level 0=User 1=Privileged
    ::core::dt::uint_t<1> active_CSL; // Current security level 0=Secure 1=Non secure
#else
    union
    {
        struct
        {
            uint32_t active_CPL : 1; // Current privilege level 0=User 1=Privileged
            uint32_t active_CSL : 1; // Current security level 0=Secure 1=Non secure
            uint32_t reserved0 : 30;
        };
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR prot_r() :
        active_CPL(static_cast<uint32_t>(::privilege_level::USER)),
        active_CSL(static_cast<uint32_t>(::security_level::SECURE))
    {
    }
    CONSTEXPR prot_r(uint32_t value) : active_CPL(value >> 0), active_CSL(value >> 1) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        active_CPL = value >> 0;
        active_CSL = value >> 1;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (active_CPL << 0) | (active_CSL << 1);
    }
    prot_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR prot_r() :
        active_CPL(static_cast<uint32_t>(::privilege_level::USER)),
        active_CSL(static_cast<uint32_t>(::security_level::SECURE)), reserved0(static_cast<uint32_t>(0))
    {
    }
    CONSTEXPR prot_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    prot_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR ::privilege_level get_active_CPL() const
    {
        ::privilege_level value = static_cast<::privilege_level>(active_CPL);
        return value;
    }
#ifndef MODEL_REGS
    ::privilege_level get_active_CPL() const volatile
    {
        ::privilege_level value = static_cast<::privilege_level>(active_CPL);
        return value;
    }
#endif
    CONSTEXPR prot_r &set_active_CPL(::privilege_level value)
    {
        active_CPL = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR ::security_level get_active_CSL() const
    {
        ::security_level value = static_cast<::security_level>(active_CSL);
        return value;
    }
#ifndef MODEL_REGS
    ::security_level get_active_CSL() const volatile
    {
        ::security_level value = static_cast<::security_level>(active_CSL);
        return value;
    }
#endif
    CONSTEXPR prot_r &set_active_CSL(::security_level value)
    {
        active_CSL = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// config_r - RTL configuration
struct config_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<4>
        macs_per_cc; // The log2(macs/clock cycle). Valid encoding range is 5 to 8 for 32 to 256 MACs/clock cycle.
    ::core::dt::uint_t<4>
        cmd_stream_version;           // command stream version accepted by this NPU. Set to 0 for Ethos-U55 EAC.
    ::core::dt::uint_t<8> shram_size; // Size in KB of SHRAM in the range 8 to 48.
    ::core::dt::uint_t<4> product;    // Product configuration
#else
    union
    {
        struct
        {
            uint32_t macs_per_cc : 4;        // The log2(macs/clock cycle). Valid encoding range is 5 to 8 for 32 to 256
                                             // MACs/clock cycle.
            uint32_t cmd_stream_version : 4; // command stream version accepted by this NPU. Set to 0 for Ethos-U55 EAC.
            uint32_t shram_size : 8;         // Size in KB of SHRAM in the range 8 to 48.
            uint32_t reserved0 : 12;
            uint32_t product : 4; // Product configuration
        };
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR config_r() :
        macs_per_cc(static_cast<uint32_t>(0x0)), cmd_stream_version(static_cast<uint32_t>(0x0)),
        shram_size(static_cast<uint32_t>(0x0)), product(static_cast<uint32_t>(::product::ETHOS_U55))
    {
    }
    CONSTEXPR config_r(uint32_t value) :
        macs_per_cc(value >> 0), cmd_stream_version(value >> 4), shram_size(value >> 8), product(value >> 28)
    {
    }
    CONSTEXPR void operator=(uint32_t value)
    {
        macs_per_cc        = value >> 0;
        cmd_stream_version = value >> 4;
        shram_size         = value >> 8;
        product            = value >> 28;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (macs_per_cc << 0) | (cmd_stream_version << 4) | (shram_size << 8) | (product << 28);
    }
    config_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR config_r() :
        macs_per_cc(static_cast<uint32_t>(0x0)), cmd_stream_version(static_cast<uint32_t>(0x0)),
        shram_size(static_cast<uint32_t>(0x0)), reserved0(static_cast<uint32_t>(0)),
        product(static_cast<uint32_t>(::product::ETHOS_U55))
    {
    }
    CONSTEXPR config_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    config_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_macs_per_cc() const
    {
        uint32_t value = static_cast<uint32_t>(macs_per_cc);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_macs_per_cc() const volatile
    {
        uint32_t value = static_cast<uint32_t>(macs_per_cc);
        return value;
    }
#endif
    CONSTEXPR config_r &set_macs_per_cc(uint32_t value)
    {
        macs_per_cc = ((1u << 4) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_cmd_stream_version() const
    {
        uint32_t value = static_cast<uint32_t>(cmd_stream_version);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_cmd_stream_version() const volatile
    {
        uint32_t value = static_cast<uint32_t>(cmd_stream_version);
        return value;
    }
#endif
    CONSTEXPR config_r &set_cmd_stream_version(uint32_t value)
    {
        cmd_stream_version = ((1u << 4) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_shram_size() const
    {
        uint32_t value = static_cast<uint32_t>(shram_size);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_shram_size() const volatile
    {
        uint32_t value = static_cast<uint32_t>(shram_size);
        return value;
    }
#endif
    CONSTEXPR config_r &set_shram_size(uint32_t value)
    {
        shram_size = ((1u << 8) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR ::product get_product() const
    {
        ::product value = static_cast<::product>(product);
        return value;
    }
#ifndef MODEL_REGS
    ::product get_product() const volatile
    {
        ::product value = static_cast<::product>(product);
        return value;
    }
#endif
    CONSTEXPR config_r &set_product(::product value)
    {
        product = ((1u << 4) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// lock_r - Lock register. This register is designed for driver use and does not affect NPU functionality
struct lock_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> LOCK; // 32 bit value for LOCK configuration
#else
    union
    {
        uint32_t LOCK; // 32 bit value for LOCK configuration
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR lock_r() : LOCK(static_cast<uint32_t>(0x00000000)) {}
    CONSTEXPR lock_r(uint32_t value) : LOCK(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        LOCK = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (LOCK << 0);
    }
    lock_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR lock_r() : LOCK(static_cast<uint32_t>(0x00000000)) {}
    CONSTEXPR lock_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    lock_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_LOCK() const
    {
        uint32_t value = static_cast<uint32_t>(LOCK);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_LOCK() const volatile
    {
        uint32_t value = static_cast<uint32_t>(LOCK);
        return value;
    }
#endif
    CONSTEXPR lock_r &set_LOCK(uint32_t value)
    {
        LOCK = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// regioncfg_r - Base pointer configuration. Bits[2*k+1:2*k] give the memory type for REGION[k]
struct regioncfg_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<2> region0; // Bits for Region0 Configurion
    ::core::dt::uint_t<2> region1; // Bits for Region1 Configurion
    ::core::dt::uint_t<2> region2; // Bits for Region2 Configurion
    ::core::dt::uint_t<2> region3; // Bits for Region3 Configurion
    ::core::dt::uint_t<2> region4; // Bits for Region4 Configurion
    ::core::dt::uint_t<2> region5; // Bits for Region5 Configurion
    ::core::dt::uint_t<2> region6; // Bits for Region6 Configurion
    ::core::dt::uint_t<2> region7; // Bits for Region7 Configurion
#else
    union
    {
        struct
        {
            uint32_t region0 : 2; // Bits for Region0 Configurion
            uint32_t region1 : 2; // Bits for Region1 Configurion
            uint32_t region2 : 2; // Bits for Region2 Configurion
            uint32_t region3 : 2; // Bits for Region3 Configurion
            uint32_t region4 : 2; // Bits for Region4 Configurion
            uint32_t region5 : 2; // Bits for Region5 Configurion
            uint32_t region6 : 2; // Bits for Region6 Configurion
            uint32_t region7 : 2; // Bits for Region7 Configurion
            uint32_t reserved0 : 16;
        };
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR regioncfg_r() :
        region0(static_cast<uint32_t>(::memory_type::AXI0_OUTSTANDING_COUNTER0)),
        region1(static_cast<uint32_t>(::memory_type::AXI0_OUTSTANDING_COUNTER0)),
        region2(static_cast<uint32_t>(::memory_type::AXI0_OUTSTANDING_COUNTER0)),
        region3(static_cast<uint32_t>(::memory_type::AXI0_OUTSTANDING_COUNTER0)),
        region4(static_cast<uint32_t>(::memory_type::AXI0_OUTSTANDING_COUNTER0)),
        region5(static_cast<uint32_t>(::memory_type::AXI0_OUTSTANDING_COUNTER0)),
        region6(static_cast<uint32_t>(::memory_type::AXI0_OUTSTANDING_COUNTER0)),
        region7(static_cast<uint32_t>(::memory_type::AXI0_OUTSTANDING_COUNTER0))
    {
    }
    CONSTEXPR regioncfg_r(uint32_t value) :
        region0(value >> 0), region1(value >> 2), region2(value >> 4), region3(value >> 6), region4(value >> 8),
        region5(value >> 10), region6(value >> 12), region7(value >> 14)
    {
    }
    CONSTEXPR void operator=(uint32_t value)
    {
        region0 = value >> 0;
        region1 = value >> 2;
        region2 = value >> 4;
        region3 = value >> 6;
        region4 = value >> 8;
        region5 = value >> 10;
        region6 = value >> 12;
        region7 = value >> 14;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (region0 << 0) | (region1 << 2) | (region2 << 4) | (region3 << 6) | (region4 << 8) | (region5 << 10) |
               (region6 << 12) | (region7 << 14);
    }
    regioncfg_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR regioncfg_r() :
        region0(static_cast<uint32_t>(::memory_type::AXI0_OUTSTANDING_COUNTER0)),
        region1(static_cast<uint32_t>(::memory_type::AXI0_OUTSTANDING_COUNTER0)),
        region2(static_cast<uint32_t>(::memory_type::AXI0_OUTSTANDING_COUNTER0)),
        region3(static_cast<uint32_t>(::memory_type::AXI0_OUTSTANDING_COUNTER0)),
        region4(static_cast<uint32_t>(::memory_type::AXI0_OUTSTANDING_COUNTER0)),
        region5(static_cast<uint32_t>(::memory_type::AXI0_OUTSTANDING_COUNTER0)),
        region6(static_cast<uint32_t>(::memory_type::AXI0_OUTSTANDING_COUNTER0)),
        region7(static_cast<uint32_t>(::memory_type::AXI0_OUTSTANDING_COUNTER0)), reserved0(static_cast<uint32_t>(0))
    {
    }
    CONSTEXPR regioncfg_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    regioncfg_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR ::memory_type get_region0() const
    {
        ::memory_type value = static_cast<::memory_type>(region0);
        return value;
    }
#ifndef MODEL_REGS
    ::memory_type get_region0() const volatile
    {
        ::memory_type value = static_cast<::memory_type>(region0);
        return value;
    }
#endif
    CONSTEXPR regioncfg_r &set_region0(::memory_type value)
    {
        region0 = ((1u << 2) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR ::memory_type get_region1() const
    {
        ::memory_type value = static_cast<::memory_type>(region1);
        return value;
    }
#ifndef MODEL_REGS
    ::memory_type get_region1() const volatile
    {
        ::memory_type value = static_cast<::memory_type>(region1);
        return value;
    }
#endif
    CONSTEXPR regioncfg_r &set_region1(::memory_type value)
    {
        region1 = ((1u << 2) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR ::memory_type get_region2() const
    {
        ::memory_type value = static_cast<::memory_type>(region2);
        return value;
    }
#ifndef MODEL_REGS
    ::memory_type get_region2() const volatile
    {
        ::memory_type value = static_cast<::memory_type>(region2);
        return value;
    }
#endif
    CONSTEXPR regioncfg_r &set_region2(::memory_type value)
    {
        region2 = ((1u << 2) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR ::memory_type get_region3() const
    {
        ::memory_type value = static_cast<::memory_type>(region3);
        return value;
    }
#ifndef MODEL_REGS
    ::memory_type get_region3() const volatile
    {
        ::memory_type value = static_cast<::memory_type>(region3);
        return value;
    }
#endif
    CONSTEXPR regioncfg_r &set_region3(::memory_type value)
    {
        region3 = ((1u << 2) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR ::memory_type get_region4() const
    {
        ::memory_type value = static_cast<::memory_type>(region4);
        return value;
    }
#ifndef MODEL_REGS
    ::memory_type get_region4() const volatile
    {
        ::memory_type value = static_cast<::memory_type>(region4);
        return value;
    }
#endif
    CONSTEXPR regioncfg_r &set_region4(::memory_type value)
    {
        region4 = ((1u << 2) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR ::memory_type get_region5() const
    {
        ::memory_type value = static_cast<::memory_type>(region5);
        return value;
    }
#ifndef MODEL_REGS
    ::memory_type get_region5() const volatile
    {
        ::memory_type value = static_cast<::memory_type>(region5);
        return value;
    }
#endif
    CONSTEXPR regioncfg_r &set_region5(::memory_type value)
    {
        region5 = ((1u << 2) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR ::memory_type get_region6() const
    {
        ::memory_type value = static_cast<::memory_type>(region6);
        return value;
    }
#ifndef MODEL_REGS
    ::memory_type get_region6() const volatile
    {
        ::memory_type value = static_cast<::memory_type>(region6);
        return value;
    }
#endif
    CONSTEXPR regioncfg_r &set_region6(::memory_type value)
    {
        region6 = ((1u << 2) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR ::memory_type get_region7() const
    {
        ::memory_type value = static_cast<::memory_type>(region7);
        return value;
    }
#ifndef MODEL_REGS
    ::memory_type get_region7() const volatile
    {
        ::memory_type value = static_cast<::memory_type>(region7);
        return value;
    }
#endif
    CONSTEXPR regioncfg_r &set_region7(::memory_type value)
    {
        region7 = ((1u << 2) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// axi_limit0_r - AXI limits for port 0 counter 0
struct axi_limit0_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<2> max_beats; // Burst split alignment: 0=64 bytes, 1=128 bytes, 2=256 bytes, 3=reserved
    ::core::dt::uint_t<4> memtype;   // Memtype
    ::core::dt::uint_t<8>
        max_outstanding_read_m1; // Maximum number of outstanding AXI read transactions - 1 in range 0 to 31
    ::core::dt::uint_t<8>
        max_outstanding_write_m1; // Maximum number of outstanding AXI write transactions - 1 in range 0 to 15
#else
    union
    {
        struct
        {
            uint32_t max_beats : 2; // Burst split alignment: 0=64 bytes, 1=128 bytes, 2=256 bytes, 3=reserved
            uint32_t reserved0 : 2;
            uint32_t memtype : 4; // Memtype
            uint32_t reserved1 : 8;
            uint32_t
                max_outstanding_read_m1 : 8; // Maximum number of outstanding AXI read transactions - 1 in range 0 to 31
            uint32_t max_outstanding_write_m1 : 8; // Maximum number of outstanding AXI write transactions - 1 in range
                                                   // 0 to 15
        };
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR axi_limit0_r() :
        max_beats(static_cast<uint32_t>(0)), memtype(static_cast<uint32_t>(0)),
        max_outstanding_read_m1(static_cast<uint32_t>(0x00)), max_outstanding_write_m1(static_cast<uint32_t>(0x000000))
    {
    }
    CONSTEXPR axi_limit0_r(uint32_t value) :
        max_beats(value >> 0), memtype(value >> 4), max_outstanding_read_m1(value >> 16),
        max_outstanding_write_m1(value >> 24)
    {
    }
    CONSTEXPR void operator=(uint32_t value)
    {
        max_beats                = value >> 0;
        memtype                  = value >> 4;
        max_outstanding_read_m1  = value >> 16;
        max_outstanding_write_m1 = value >> 24;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (max_beats << 0) | (memtype << 4) | (max_outstanding_read_m1 << 16) | (max_outstanding_write_m1 << 24);
    }
    axi_limit0_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR axi_limit0_r() :
        max_beats(static_cast<uint32_t>(0)), reserved0(static_cast<uint32_t>(0)), memtype(static_cast<uint32_t>(0)),
        reserved1(static_cast<uint32_t>(0)), max_outstanding_read_m1(static_cast<uint32_t>(0x00)),
        max_outstanding_write_m1(static_cast<uint32_t>(0x000000))
    {
    }
    CONSTEXPR axi_limit0_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    axi_limit0_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_max_beats() const
    {
        uint32_t value = static_cast<uint32_t>(max_beats);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_max_beats() const volatile
    {
        uint32_t value = static_cast<uint32_t>(max_beats);
        return value;
    }
#endif
    CONSTEXPR axi_limit0_r &set_max_beats(uint32_t value)
    {
        max_beats = ((1u << 2) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_memtype() const
    {
        uint32_t value = static_cast<uint32_t>(memtype);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_memtype() const volatile
    {
        uint32_t value = static_cast<uint32_t>(memtype);
        return value;
    }
#endif
    CONSTEXPR axi_limit0_r &set_memtype(uint32_t value)
    {
        memtype = ((1u << 4) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_max_outstanding_read_m1() const
    {
        uint32_t value = static_cast<uint32_t>(max_outstanding_read_m1);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_max_outstanding_read_m1() const volatile
    {
        uint32_t value = static_cast<uint32_t>(max_outstanding_read_m1);
        return value;
    }
#endif
    CONSTEXPR axi_limit0_r &set_max_outstanding_read_m1(uint32_t value)
    {
        max_outstanding_read_m1 = ((1u << 8) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_max_outstanding_write_m1() const
    {
        uint32_t value = static_cast<uint32_t>(max_outstanding_write_m1);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_max_outstanding_write_m1() const volatile
    {
        uint32_t value = static_cast<uint32_t>(max_outstanding_write_m1);
        return value;
    }
#endif
    CONSTEXPR axi_limit0_r &set_max_outstanding_write_m1(uint32_t value)
    {
        max_outstanding_write_m1 = ((1u << 8) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// axi_limit1_r - AXI limits for port 0 counter 1
struct axi_limit1_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<2> max_beats; // Burst split alignment: 0=64 bytes, 1=128 bytes, 2=256 bytes, 3=reserved
    ::core::dt::uint_t<4> memtype;   // Memtype
    ::core::dt::uint_t<8>
        max_outstanding_read_m1; // Maximum number of outstanding AXI read transactions - 1 in range 0 to 31
    ::core::dt::uint_t<8>
        max_outstanding_write_m1; // Maximum number of outstanding AXI write transactions - 1 in range 0 to 15
#else
    union
    {
        struct
        {
            uint32_t max_beats : 2; // Burst split alignment: 0=64 bytes, 1=128 bytes, 2=256 bytes, 3=reserved
            uint32_t reserved0 : 2;
            uint32_t memtype : 4; // Memtype
            uint32_t reserved1 : 8;
            uint32_t
                max_outstanding_read_m1 : 8; // Maximum number of outstanding AXI read transactions - 1 in range 0 to 31
            uint32_t max_outstanding_write_m1 : 8; // Maximum number of outstanding AXI write transactions - 1 in range
                                                   // 0 to 15
        };
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR axi_limit1_r() :
        max_beats(static_cast<uint32_t>(0)), memtype(static_cast<uint32_t>(0)),
        max_outstanding_read_m1(static_cast<uint32_t>(0x00)), max_outstanding_write_m1(static_cast<uint32_t>(0x000000))
    {
    }
    CONSTEXPR axi_limit1_r(uint32_t value) :
        max_beats(value >> 0), memtype(value >> 4), max_outstanding_read_m1(value >> 16),
        max_outstanding_write_m1(value >> 24)
    {
    }
    CONSTEXPR void operator=(uint32_t value)
    {
        max_beats                = value >> 0;
        memtype                  = value >> 4;
        max_outstanding_read_m1  = value >> 16;
        max_outstanding_write_m1 = value >> 24;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (max_beats << 0) | (memtype << 4) | (max_outstanding_read_m1 << 16) | (max_outstanding_write_m1 << 24);
    }
    axi_limit1_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR axi_limit1_r() :
        max_beats(static_cast<uint32_t>(0)), reserved0(static_cast<uint32_t>(0)), memtype(static_cast<uint32_t>(0)),
        reserved1(static_cast<uint32_t>(0)), max_outstanding_read_m1(static_cast<uint32_t>(0x00)),
        max_outstanding_write_m1(static_cast<uint32_t>(0x000000))
    {
    }
    CONSTEXPR axi_limit1_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    axi_limit1_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_max_beats() const
    {
        uint32_t value = static_cast<uint32_t>(max_beats);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_max_beats() const volatile
    {
        uint32_t value = static_cast<uint32_t>(max_beats);
        return value;
    }
#endif
    CONSTEXPR axi_limit1_r &set_max_beats(uint32_t value)
    {
        max_beats = ((1u << 2) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_memtype() const
    {
        uint32_t value = static_cast<uint32_t>(memtype);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_memtype() const volatile
    {
        uint32_t value = static_cast<uint32_t>(memtype);
        return value;
    }
#endif
    CONSTEXPR axi_limit1_r &set_memtype(uint32_t value)
    {
        memtype = ((1u << 4) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_max_outstanding_read_m1() const
    {
        uint32_t value = static_cast<uint32_t>(max_outstanding_read_m1);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_max_outstanding_read_m1() const volatile
    {
        uint32_t value = static_cast<uint32_t>(max_outstanding_read_m1);
        return value;
    }
#endif
    CONSTEXPR axi_limit1_r &set_max_outstanding_read_m1(uint32_t value)
    {
        max_outstanding_read_m1 = ((1u << 8) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_max_outstanding_write_m1() const
    {
        uint32_t value = static_cast<uint32_t>(max_outstanding_write_m1);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_max_outstanding_write_m1() const volatile
    {
        uint32_t value = static_cast<uint32_t>(max_outstanding_write_m1);
        return value;
    }
#endif
    CONSTEXPR axi_limit1_r &set_max_outstanding_write_m1(uint32_t value)
    {
        max_outstanding_write_m1 = ((1u << 8) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// axi_limit2_r - AXI limits for port 1 counter 2
struct axi_limit2_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<2> max_beats; // Burst split alignment: 0=64 bytes, 1=128 bytes, 2=256 bytes, 3=reserved
    ::core::dt::uint_t<4> memtype;   // Memtype
    ::core::dt::uint_t<8>
        max_outstanding_read_m1; // Maximum number of outstanding AXI read transactions - 1 in range 0 to 31
    ::core::dt::uint_t<8>
        max_outstanding_write_m1; // Maximum number of outstanding AXI write transactions - 1 in range 0 to 15
#else
    union
    {
        struct
        {
            uint32_t max_beats : 2; // Burst split alignment: 0=64 bytes, 1=128 bytes, 2=256 bytes, 3=reserved
            uint32_t reserved0 : 2;
            uint32_t memtype : 4; // Memtype
            uint32_t reserved1 : 8;
            uint32_t
                max_outstanding_read_m1 : 8; // Maximum number of outstanding AXI read transactions - 1 in range 0 to 31
            uint32_t max_outstanding_write_m1 : 8; // Maximum number of outstanding AXI write transactions - 1 in range
                                                   // 0 to 15
        };
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR axi_limit2_r() :
        max_beats(static_cast<uint32_t>(0)), memtype(static_cast<uint32_t>(0)),
        max_outstanding_read_m1(static_cast<uint32_t>(0x00)), max_outstanding_write_m1(static_cast<uint32_t>(0x000000))
    {
    }
    CONSTEXPR axi_limit2_r(uint32_t value) :
        max_beats(value >> 0), memtype(value >> 4), max_outstanding_read_m1(value >> 16),
        max_outstanding_write_m1(value >> 24)
    {
    }
    CONSTEXPR void operator=(uint32_t value)
    {
        max_beats                = value >> 0;
        memtype                  = value >> 4;
        max_outstanding_read_m1  = value >> 16;
        max_outstanding_write_m1 = value >> 24;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (max_beats << 0) | (memtype << 4) | (max_outstanding_read_m1 << 16) | (max_outstanding_write_m1 << 24);
    }
    axi_limit2_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR axi_limit2_r() :
        max_beats(static_cast<uint32_t>(0)), reserved0(static_cast<uint32_t>(0)), memtype(static_cast<uint32_t>(0)),
        reserved1(static_cast<uint32_t>(0)), max_outstanding_read_m1(static_cast<uint32_t>(0x00)),
        max_outstanding_write_m1(static_cast<uint32_t>(0x000000))
    {
    }
    CONSTEXPR axi_limit2_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    axi_limit2_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_max_beats() const
    {
        uint32_t value = static_cast<uint32_t>(max_beats);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_max_beats() const volatile
    {
        uint32_t value = static_cast<uint32_t>(max_beats);
        return value;
    }
#endif
    CONSTEXPR axi_limit2_r &set_max_beats(uint32_t value)
    {
        max_beats = ((1u << 2) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_memtype() const
    {
        uint32_t value = static_cast<uint32_t>(memtype);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_memtype() const volatile
    {
        uint32_t value = static_cast<uint32_t>(memtype);
        return value;
    }
#endif
    CONSTEXPR axi_limit2_r &set_memtype(uint32_t value)
    {
        memtype = ((1u << 4) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_max_outstanding_read_m1() const
    {
        uint32_t value = static_cast<uint32_t>(max_outstanding_read_m1);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_max_outstanding_read_m1() const volatile
    {
        uint32_t value = static_cast<uint32_t>(max_outstanding_read_m1);
        return value;
    }
#endif
    CONSTEXPR axi_limit2_r &set_max_outstanding_read_m1(uint32_t value)
    {
        max_outstanding_read_m1 = ((1u << 8) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_max_outstanding_write_m1() const
    {
        uint32_t value = static_cast<uint32_t>(max_outstanding_write_m1);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_max_outstanding_write_m1() const volatile
    {
        uint32_t value = static_cast<uint32_t>(max_outstanding_write_m1);
        return value;
    }
#endif
    CONSTEXPR axi_limit2_r &set_max_outstanding_write_m1(uint32_t value)
    {
        max_outstanding_write_m1 = ((1u << 8) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// axi_limit3_r - AXI limits for port 1 counter 3
struct axi_limit3_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<2> max_beats; // Burst split alignment: 0=64 bytes, 1=128 bytes, 2=256 bytes, 3=reserved
    ::core::dt::uint_t<4> memtype;   // Memtype
    ::core::dt::uint_t<8>
        max_outstanding_read_m1; // Maximum number of outstanding AXI read transactions - 1 in range 0 to 31
    ::core::dt::uint_t<8>
        max_outstanding_write_m1; // Maximum number of outstanding AXI write transactions - 1 in range 0 to 15
#else
    union
    {
        struct
        {
            uint32_t max_beats : 2; // Burst split alignment: 0=64 bytes, 1=128 bytes, 2=256 bytes, 3=reserved
            uint32_t reserved0 : 2;
            uint32_t memtype : 4; // Memtype
            uint32_t reserved1 : 8;
            uint32_t
                max_outstanding_read_m1 : 8; // Maximum number of outstanding AXI read transactions - 1 in range 0 to 31
            uint32_t max_outstanding_write_m1 : 8; // Maximum number of outstanding AXI write transactions - 1 in range
                                                   // 0 to 15
        };
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR axi_limit3_r() :
        max_beats(static_cast<uint32_t>(0)), memtype(static_cast<uint32_t>(0)),
        max_outstanding_read_m1(static_cast<uint32_t>(0x00)), max_outstanding_write_m1(static_cast<uint32_t>(0x000000))
    {
    }
    CONSTEXPR axi_limit3_r(uint32_t value) :
        max_beats(value >> 0), memtype(value >> 4), max_outstanding_read_m1(value >> 16),
        max_outstanding_write_m1(value >> 24)
    {
    }
    CONSTEXPR void operator=(uint32_t value)
    {
        max_beats                = value >> 0;
        memtype                  = value >> 4;
        max_outstanding_read_m1  = value >> 16;
        max_outstanding_write_m1 = value >> 24;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (max_beats << 0) | (memtype << 4) | (max_outstanding_read_m1 << 16) | (max_outstanding_write_m1 << 24);
    }
    axi_limit3_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR axi_limit3_r() :
        max_beats(static_cast<uint32_t>(0)), reserved0(static_cast<uint32_t>(0)), memtype(static_cast<uint32_t>(0)),
        reserved1(static_cast<uint32_t>(0)), max_outstanding_read_m1(static_cast<uint32_t>(0x00)),
        max_outstanding_write_m1(static_cast<uint32_t>(0x000000))
    {
    }
    CONSTEXPR axi_limit3_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    axi_limit3_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_max_beats() const
    {
        uint32_t value = static_cast<uint32_t>(max_beats);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_max_beats() const volatile
    {
        uint32_t value = static_cast<uint32_t>(max_beats);
        return value;
    }
#endif
    CONSTEXPR axi_limit3_r &set_max_beats(uint32_t value)
    {
        max_beats = ((1u << 2) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_memtype() const
    {
        uint32_t value = static_cast<uint32_t>(memtype);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_memtype() const volatile
    {
        uint32_t value = static_cast<uint32_t>(memtype);
        return value;
    }
#endif
    CONSTEXPR axi_limit3_r &set_memtype(uint32_t value)
    {
        memtype = ((1u << 4) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_max_outstanding_read_m1() const
    {
        uint32_t value = static_cast<uint32_t>(max_outstanding_read_m1);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_max_outstanding_read_m1() const volatile
    {
        uint32_t value = static_cast<uint32_t>(max_outstanding_read_m1);
        return value;
    }
#endif
    CONSTEXPR axi_limit3_r &set_max_outstanding_read_m1(uint32_t value)
    {
        max_outstanding_read_m1 = ((1u << 8) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_max_outstanding_write_m1() const
    {
        uint32_t value = static_cast<uint32_t>(max_outstanding_write_m1);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_max_outstanding_write_m1() const volatile
    {
        uint32_t value = static_cast<uint32_t>(max_outstanding_write_m1);
        return value;
    }
#endif
    CONSTEXPR axi_limit3_r &set_max_outstanding_write_m1(uint32_t value)
    {
        max_outstanding_write_m1 = ((1u << 8) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// pmcr_r - PMU Register control
struct pmcr_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<1> cnt_en;        // Enable counters (RW)
    ::core::dt::uint_t<1> event_cnt_rst; // Reset event counters (WO)
    ::core::dt::uint_t<1> cycle_cnt_rst; // Reset cycle counter (WO)
    ::core::dt::uint_t<1> mask_en;       // PMU can be enabled/disabled by command stream operation NPU_OP_PMU_MASK
    ::core::dt::uint_t<5> num_event_cnt; // Number of event counters (RO)
#else
    union
    {
        struct
        {
            uint32_t cnt_en : 1;        // Enable counters (RW)
            uint32_t event_cnt_rst : 1; // Reset event counters (WO)
            uint32_t cycle_cnt_rst : 1; // Reset cycle counter (WO)
            uint32_t mask_en : 1;       // PMU can be enabled/disabled by command stream operation NPU_OP_PMU_MASK
            uint32_t reserved0 : 7;
            uint32_t num_event_cnt : 5; // Number of event counters (RO)
            uint32_t reserved1 : 16;
        };
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR pmcr_r() :
        cnt_en(static_cast<uint32_t>(0)), event_cnt_rst(static_cast<uint32_t>(0)),
        cycle_cnt_rst(static_cast<uint32_t>(0)), mask_en(static_cast<uint32_t>(0)),
        num_event_cnt(static_cast<uint32_t>(4))
    {
    }
    CONSTEXPR pmcr_r(uint32_t value) :
        cnt_en(value >> 0), event_cnt_rst(value >> 1), cycle_cnt_rst(value >> 2), mask_en(value >> 3),
        num_event_cnt(value >> 11)
    {
    }
    CONSTEXPR void operator=(uint32_t value)
    {
        cnt_en        = value >> 0;
        event_cnt_rst = value >> 1;
        cycle_cnt_rst = value >> 2;
        mask_en       = value >> 3;
        num_event_cnt = value >> 11;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (cnt_en << 0) | (event_cnt_rst << 1) | (cycle_cnt_rst << 2) | (mask_en << 3) | (num_event_cnt << 11);
    }
    pmcr_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR pmcr_r() :
        cnt_en(static_cast<uint32_t>(0)), event_cnt_rst(static_cast<uint32_t>(0)),
        cycle_cnt_rst(static_cast<uint32_t>(0)), mask_en(static_cast<uint32_t>(0)), reserved0(static_cast<uint32_t>(0)),
        num_event_cnt(static_cast<uint32_t>(4)), reserved1(static_cast<uint32_t>(0))
    {
    }
    CONSTEXPR pmcr_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    pmcr_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_cnt_en() const
    {
        uint32_t value = static_cast<uint32_t>(cnt_en);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_cnt_en() const volatile
    {
        uint32_t value = static_cast<uint32_t>(cnt_en);
        return value;
    }
#endif
    CONSTEXPR pmcr_r &set_cnt_en(uint32_t value)
    {
        cnt_en = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_event_cnt_rst() const
    {
        uint32_t value = static_cast<uint32_t>(event_cnt_rst);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_event_cnt_rst() const volatile
    {
        uint32_t value = static_cast<uint32_t>(event_cnt_rst);
        return value;
    }
#endif
    CONSTEXPR pmcr_r &set_event_cnt_rst(uint32_t value)
    {
        event_cnt_rst = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_cycle_cnt_rst() const
    {
        uint32_t value = static_cast<uint32_t>(cycle_cnt_rst);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_cycle_cnt_rst() const volatile
    {
        uint32_t value = static_cast<uint32_t>(cycle_cnt_rst);
        return value;
    }
#endif
    CONSTEXPR pmcr_r &set_cycle_cnt_rst(uint32_t value)
    {
        cycle_cnt_rst = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_mask_en() const
    {
        uint32_t value = static_cast<uint32_t>(mask_en);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_mask_en() const volatile
    {
        uint32_t value = static_cast<uint32_t>(mask_en);
        return value;
    }
#endif
    CONSTEXPR pmcr_r &set_mask_en(uint32_t value)
    {
        mask_en = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_num_event_cnt() const
    {
        uint32_t value = static_cast<uint32_t>(num_event_cnt);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_num_event_cnt() const volatile
    {
        uint32_t value = static_cast<uint32_t>(num_event_cnt);
        return value;
    }
#endif
    CONSTEXPR pmcr_r &set_num_event_cnt(uint32_t value)
    {
        num_event_cnt = ((1u << 5) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// pmcntenset_r - Count enable set register
struct pmcntenset_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<1> EVENT_CNT_0; // Event counter enable bit for PMEVCNTR0
    ::core::dt::uint_t<1> EVENT_CNT_1; // Event counter enable bit for PMEVCNTR1
    ::core::dt::uint_t<1> EVENT_CNT_2; // Event counter enable bit for PMEVCNTR2
    ::core::dt::uint_t<1> EVENT_CNT_3; // Event counter enable bit for PMEVCNTR3
    ::core::dt::uint_t<1> CYCLE_CNT;   // PMCCNTR enable bit
#else
    union
    {
        struct
        {
            uint32_t EVENT_CNT_0 : 1; // Event counter enable bit for PMEVCNTR0
            uint32_t EVENT_CNT_1 : 1; // Event counter enable bit for PMEVCNTR1
            uint32_t EVENT_CNT_2 : 1; // Event counter enable bit for PMEVCNTR2
            uint32_t EVENT_CNT_3 : 1; // Event counter enable bit for PMEVCNTR3
            uint32_t reserved0 : 27;
            uint32_t CYCLE_CNT : 1; // PMCCNTR enable bit
        };
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR pmcntenset_r() :
        EVENT_CNT_0(static_cast<uint32_t>(0)), EVENT_CNT_1(static_cast<uint32_t>(0)),
        EVENT_CNT_2(static_cast<uint32_t>(0)), EVENT_CNT_3(static_cast<uint32_t>(0)),
        CYCLE_CNT(static_cast<uint32_t>(0))
    {
    }
    CONSTEXPR pmcntenset_r(uint32_t value) :
        EVENT_CNT_0(value >> 0), EVENT_CNT_1(value >> 1), EVENT_CNT_2(value >> 2), EVENT_CNT_3(value >> 3),
        CYCLE_CNT(value >> 31)
    {
    }
    CONSTEXPR void operator=(uint32_t value)
    {
        EVENT_CNT_0 = value >> 0;
        EVENT_CNT_1 = value >> 1;
        EVENT_CNT_2 = value >> 2;
        EVENT_CNT_3 = value >> 3;
        CYCLE_CNT   = value >> 31;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (EVENT_CNT_0 << 0) | (EVENT_CNT_1 << 1) | (EVENT_CNT_2 << 2) | (EVENT_CNT_3 << 3) | (CYCLE_CNT << 31);
    }
    pmcntenset_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR pmcntenset_r() :
        EVENT_CNT_0(static_cast<uint32_t>(0)), EVENT_CNT_1(static_cast<uint32_t>(0)),
        EVENT_CNT_2(static_cast<uint32_t>(0)), EVENT_CNT_3(static_cast<uint32_t>(0)),
        reserved0(static_cast<uint32_t>(0)), CYCLE_CNT(static_cast<uint32_t>(0))
    {
    }
    CONSTEXPR pmcntenset_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    pmcntenset_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_EVENT_CNT_0() const
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_0);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_EVENT_CNT_0() const volatile
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_0);
        return value;
    }
#endif
    CONSTEXPR pmcntenset_r &set_EVENT_CNT_0(uint32_t value)
    {
        EVENT_CNT_0 = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_EVENT_CNT_1() const
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_1);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_EVENT_CNT_1() const volatile
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_1);
        return value;
    }
#endif
    CONSTEXPR pmcntenset_r &set_EVENT_CNT_1(uint32_t value)
    {
        EVENT_CNT_1 = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_EVENT_CNT_2() const
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_2);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_EVENT_CNT_2() const volatile
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_2);
        return value;
    }
#endif
    CONSTEXPR pmcntenset_r &set_EVENT_CNT_2(uint32_t value)
    {
        EVENT_CNT_2 = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_EVENT_CNT_3() const
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_3);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_EVENT_CNT_3() const volatile
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_3);
        return value;
    }
#endif
    CONSTEXPR pmcntenset_r &set_EVENT_CNT_3(uint32_t value)
    {
        EVENT_CNT_3 = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_CYCLE_CNT() const
    {
        uint32_t value = static_cast<uint32_t>(CYCLE_CNT);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_CYCLE_CNT() const volatile
    {
        uint32_t value = static_cast<uint32_t>(CYCLE_CNT);
        return value;
    }
#endif
    CONSTEXPR pmcntenset_r &set_CYCLE_CNT(uint32_t value)
    {
        CYCLE_CNT = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// pmcntenclr_r - Count enable clear register
struct pmcntenclr_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<1> EVENT_CNT_0; // Event counter disable bit for PMEVCNTR0
    ::core::dt::uint_t<1> EVENT_CNT_1; // Event counter disable bit for PMEVCNTR1
    ::core::dt::uint_t<1> EVENT_CNT_2; // Event counter disable bit for PMEVCNTR2
    ::core::dt::uint_t<1> EVENT_CNT_3; // Event counter disable bit for PMEVCNTR3
    ::core::dt::uint_t<1> CYCLE_CNT;   // PMCCNTR disable bit
#else
    union
    {
        struct
        {
            uint32_t EVENT_CNT_0 : 1; // Event counter disable bit for PMEVCNTR0
            uint32_t EVENT_CNT_1 : 1; // Event counter disable bit for PMEVCNTR1
            uint32_t EVENT_CNT_2 : 1; // Event counter disable bit for PMEVCNTR2
            uint32_t EVENT_CNT_3 : 1; // Event counter disable bit for PMEVCNTR3
            uint32_t reserved0 : 27;
            uint32_t CYCLE_CNT : 1; // PMCCNTR disable bit
        };
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR pmcntenclr_r() :
        EVENT_CNT_0(static_cast<uint32_t>(0)), EVENT_CNT_1(static_cast<uint32_t>(0)),
        EVENT_CNT_2(static_cast<uint32_t>(0)), EVENT_CNT_3(static_cast<uint32_t>(0)),
        CYCLE_CNT(static_cast<uint32_t>(0))
    {
    }
    CONSTEXPR pmcntenclr_r(uint32_t value) :
        EVENT_CNT_0(value >> 0), EVENT_CNT_1(value >> 1), EVENT_CNT_2(value >> 2), EVENT_CNT_3(value >> 3),
        CYCLE_CNT(value >> 31)
    {
    }
    CONSTEXPR void operator=(uint32_t value)
    {
        EVENT_CNT_0 = value >> 0;
        EVENT_CNT_1 = value >> 1;
        EVENT_CNT_2 = value >> 2;
        EVENT_CNT_3 = value >> 3;
        CYCLE_CNT   = value >> 31;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (EVENT_CNT_0 << 0) | (EVENT_CNT_1 << 1) | (EVENT_CNT_2 << 2) | (EVENT_CNT_3 << 3) | (CYCLE_CNT << 31);
    }
    pmcntenclr_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR pmcntenclr_r() :
        EVENT_CNT_0(static_cast<uint32_t>(0)), EVENT_CNT_1(static_cast<uint32_t>(0)),
        EVENT_CNT_2(static_cast<uint32_t>(0)), EVENT_CNT_3(static_cast<uint32_t>(0)),
        reserved0(static_cast<uint32_t>(0)), CYCLE_CNT(static_cast<uint32_t>(0))
    {
    }
    CONSTEXPR pmcntenclr_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    pmcntenclr_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_EVENT_CNT_0() const
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_0);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_EVENT_CNT_0() const volatile
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_0);
        return value;
    }
#endif
    CONSTEXPR pmcntenclr_r &set_EVENT_CNT_0(uint32_t value)
    {
        EVENT_CNT_0 = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_EVENT_CNT_1() const
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_1);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_EVENT_CNT_1() const volatile
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_1);
        return value;
    }
#endif
    CONSTEXPR pmcntenclr_r &set_EVENT_CNT_1(uint32_t value)
    {
        EVENT_CNT_1 = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_EVENT_CNT_2() const
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_2);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_EVENT_CNT_2() const volatile
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_2);
        return value;
    }
#endif
    CONSTEXPR pmcntenclr_r &set_EVENT_CNT_2(uint32_t value)
    {
        EVENT_CNT_2 = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_EVENT_CNT_3() const
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_3);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_EVENT_CNT_3() const volatile
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_3);
        return value;
    }
#endif
    CONSTEXPR pmcntenclr_r &set_EVENT_CNT_3(uint32_t value)
    {
        EVENT_CNT_3 = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_CYCLE_CNT() const
    {
        uint32_t value = static_cast<uint32_t>(CYCLE_CNT);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_CYCLE_CNT() const volatile
    {
        uint32_t value = static_cast<uint32_t>(CYCLE_CNT);
        return value;
    }
#endif
    CONSTEXPR pmcntenclr_r &set_CYCLE_CNT(uint32_t value)
    {
        CYCLE_CNT = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// pmovsset_r - Overflow flag status set register
struct pmovsset_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<1> EVENT_CNT_0_OVF; // Event counter overflow set bit for PMEVCNTR0
    ::core::dt::uint_t<1> EVENT_CNT_1_OVF; // Event counter overflow set bit for PMEVCNTR1
    ::core::dt::uint_t<1> EVENT_CNT_2_OVF; // Event counter overflow set bit for PMEVCNTR2
    ::core::dt::uint_t<1> EVENT_CNT_3_OVF; // Event counter overflow set bit for PMEVCNTR3
    ::core::dt::uint_t<1> CYCLE_CNT_OVF;   // PMCCNTR overflow set bit
#else
    union
    {
        struct
        {
            uint32_t EVENT_CNT_0_OVF : 1; // Event counter overflow set bit for PMEVCNTR0
            uint32_t EVENT_CNT_1_OVF : 1; // Event counter overflow set bit for PMEVCNTR1
            uint32_t EVENT_CNT_2_OVF : 1; // Event counter overflow set bit for PMEVCNTR2
            uint32_t EVENT_CNT_3_OVF : 1; // Event counter overflow set bit for PMEVCNTR3
            uint32_t reserved0 : 27;
            uint32_t CYCLE_CNT_OVF : 1; // PMCCNTR overflow set bit
        };
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR pmovsset_r() :
        EVENT_CNT_0_OVF(static_cast<uint32_t>(0)), EVENT_CNT_1_OVF(static_cast<uint32_t>(0)),
        EVENT_CNT_2_OVF(static_cast<uint32_t>(0)), EVENT_CNT_3_OVF(static_cast<uint32_t>(0)),
        CYCLE_CNT_OVF(static_cast<uint32_t>(0))
    {
    }
    CONSTEXPR pmovsset_r(uint32_t value) :
        EVENT_CNT_0_OVF(value >> 0), EVENT_CNT_1_OVF(value >> 1), EVENT_CNT_2_OVF(value >> 2),
        EVENT_CNT_3_OVF(value >> 3), CYCLE_CNT_OVF(value >> 31)
    {
    }
    CONSTEXPR void operator=(uint32_t value)
    {
        EVENT_CNT_0_OVF = value >> 0;
        EVENT_CNT_1_OVF = value >> 1;
        EVENT_CNT_2_OVF = value >> 2;
        EVENT_CNT_3_OVF = value >> 3;
        CYCLE_CNT_OVF   = value >> 31;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (EVENT_CNT_0_OVF << 0) | (EVENT_CNT_1_OVF << 1) | (EVENT_CNT_2_OVF << 2) | (EVENT_CNT_3_OVF << 3) |
               (CYCLE_CNT_OVF << 31);
    }
    pmovsset_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR pmovsset_r() :
        EVENT_CNT_0_OVF(static_cast<uint32_t>(0)), EVENT_CNT_1_OVF(static_cast<uint32_t>(0)),
        EVENT_CNT_2_OVF(static_cast<uint32_t>(0)), EVENT_CNT_3_OVF(static_cast<uint32_t>(0)),
        reserved0(static_cast<uint32_t>(0)), CYCLE_CNT_OVF(static_cast<uint32_t>(0))
    {
    }
    CONSTEXPR pmovsset_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    pmovsset_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_EVENT_CNT_0_OVF() const
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_0_OVF);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_EVENT_CNT_0_OVF() const volatile
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_0_OVF);
        return value;
    }
#endif
    CONSTEXPR pmovsset_r &set_EVENT_CNT_0_OVF(uint32_t value)
    {
        EVENT_CNT_0_OVF = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_EVENT_CNT_1_OVF() const
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_1_OVF);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_EVENT_CNT_1_OVF() const volatile
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_1_OVF);
        return value;
    }
#endif
    CONSTEXPR pmovsset_r &set_EVENT_CNT_1_OVF(uint32_t value)
    {
        EVENT_CNT_1_OVF = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_EVENT_CNT_2_OVF() const
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_2_OVF);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_EVENT_CNT_2_OVF() const volatile
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_2_OVF);
        return value;
    }
#endif
    CONSTEXPR pmovsset_r &set_EVENT_CNT_2_OVF(uint32_t value)
    {
        EVENT_CNT_2_OVF = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_EVENT_CNT_3_OVF() const
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_3_OVF);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_EVENT_CNT_3_OVF() const volatile
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_3_OVF);
        return value;
    }
#endif
    CONSTEXPR pmovsset_r &set_EVENT_CNT_3_OVF(uint32_t value)
    {
        EVENT_CNT_3_OVF = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_CYCLE_CNT_OVF() const
    {
        uint32_t value = static_cast<uint32_t>(CYCLE_CNT_OVF);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_CYCLE_CNT_OVF() const volatile
    {
        uint32_t value = static_cast<uint32_t>(CYCLE_CNT_OVF);
        return value;
    }
#endif
    CONSTEXPR pmovsset_r &set_CYCLE_CNT_OVF(uint32_t value)
    {
        CYCLE_CNT_OVF = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// pmovsclr_r - Overflow flag status clear register
struct pmovsclr_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<1> EVENT_CNT_0_OVF; // Event counter overflow clear bit for PMEVCNTR0
    ::core::dt::uint_t<1> EVENT_CNT_1_OVF; // Event counter overflow clear bit for PMEVCNTR1
    ::core::dt::uint_t<1> EVENT_CNT_2_OVF; // Event counter overflow clear bit for PMEVCNTR2
    ::core::dt::uint_t<1> EVENT_CNT_3_OVF; // Event counter overflow clear bit for PMEVCNTR3
    ::core::dt::uint_t<1> CYCLE_CNT_OVF;   // PMCCNTR overflow clear bit
#else
    union
    {
        struct
        {
            uint32_t EVENT_CNT_0_OVF : 1; // Event counter overflow clear bit for PMEVCNTR0
            uint32_t EVENT_CNT_1_OVF : 1; // Event counter overflow clear bit for PMEVCNTR1
            uint32_t EVENT_CNT_2_OVF : 1; // Event counter overflow clear bit for PMEVCNTR2
            uint32_t EVENT_CNT_3_OVF : 1; // Event counter overflow clear bit for PMEVCNTR3
            uint32_t reserved0 : 27;
            uint32_t CYCLE_CNT_OVF : 1; // PMCCNTR overflow clear bit
        };
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR pmovsclr_r() :
        EVENT_CNT_0_OVF(static_cast<uint32_t>(0)), EVENT_CNT_1_OVF(static_cast<uint32_t>(0)),
        EVENT_CNT_2_OVF(static_cast<uint32_t>(0)), EVENT_CNT_3_OVF(static_cast<uint32_t>(0)),
        CYCLE_CNT_OVF(static_cast<uint32_t>(0))
    {
    }
    CONSTEXPR pmovsclr_r(uint32_t value) :
        EVENT_CNT_0_OVF(value >> 0), EVENT_CNT_1_OVF(value >> 1), EVENT_CNT_2_OVF(value >> 2),
        EVENT_CNT_3_OVF(value >> 3), CYCLE_CNT_OVF(value >> 31)
    {
    }
    CONSTEXPR void operator=(uint32_t value)
    {
        EVENT_CNT_0_OVF = value >> 0;
        EVENT_CNT_1_OVF = value >> 1;
        EVENT_CNT_2_OVF = value >> 2;
        EVENT_CNT_3_OVF = value >> 3;
        CYCLE_CNT_OVF   = value >> 31;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (EVENT_CNT_0_OVF << 0) | (EVENT_CNT_1_OVF << 1) | (EVENT_CNT_2_OVF << 2) | (EVENT_CNT_3_OVF << 3) |
               (CYCLE_CNT_OVF << 31);
    }
    pmovsclr_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR pmovsclr_r() :
        EVENT_CNT_0_OVF(static_cast<uint32_t>(0)), EVENT_CNT_1_OVF(static_cast<uint32_t>(0)),
        EVENT_CNT_2_OVF(static_cast<uint32_t>(0)), EVENT_CNT_3_OVF(static_cast<uint32_t>(0)),
        reserved0(static_cast<uint32_t>(0)), CYCLE_CNT_OVF(static_cast<uint32_t>(0))
    {
    }
    CONSTEXPR pmovsclr_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    pmovsclr_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_EVENT_CNT_0_OVF() const
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_0_OVF);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_EVENT_CNT_0_OVF() const volatile
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_0_OVF);
        return value;
    }
#endif
    CONSTEXPR pmovsclr_r &set_EVENT_CNT_0_OVF(uint32_t value)
    {
        EVENT_CNT_0_OVF = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_EVENT_CNT_1_OVF() const
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_1_OVF);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_EVENT_CNT_1_OVF() const volatile
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_1_OVF);
        return value;
    }
#endif
    CONSTEXPR pmovsclr_r &set_EVENT_CNT_1_OVF(uint32_t value)
    {
        EVENT_CNT_1_OVF = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_EVENT_CNT_2_OVF() const
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_2_OVF);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_EVENT_CNT_2_OVF() const volatile
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_2_OVF);
        return value;
    }
#endif
    CONSTEXPR pmovsclr_r &set_EVENT_CNT_2_OVF(uint32_t value)
    {
        EVENT_CNT_2_OVF = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_EVENT_CNT_3_OVF() const
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_3_OVF);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_EVENT_CNT_3_OVF() const volatile
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_3_OVF);
        return value;
    }
#endif
    CONSTEXPR pmovsclr_r &set_EVENT_CNT_3_OVF(uint32_t value)
    {
        EVENT_CNT_3_OVF = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_CYCLE_CNT_OVF() const
    {
        uint32_t value = static_cast<uint32_t>(CYCLE_CNT_OVF);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_CYCLE_CNT_OVF() const volatile
    {
        uint32_t value = static_cast<uint32_t>(CYCLE_CNT_OVF);
        return value;
    }
#endif
    CONSTEXPR pmovsclr_r &set_CYCLE_CNT_OVF(uint32_t value)
    {
        CYCLE_CNT_OVF = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// pmintset_r - Interrupt enable set register
struct pmintset_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<1> EVENT_CNT_0_INT; // Event counter overflow interrupt request enable bit for PMEVCNTR0
    ::core::dt::uint_t<1> EVENT_CNT_1_INT; // Event counter overflow interrupt request enable bit for PMEVCNTR1
    ::core::dt::uint_t<1> EVENT_CNT_2_INT; // Event counter overflow interrupt request enable bit for PMEVCNTR2
    ::core::dt::uint_t<1> EVENT_CNT_3_INT; // Event counter overflow interrupt request enable bit for PMEVCNTR3
    ::core::dt::uint_t<1> CYCLE_CNT_INT;   // PMCCNTR overflow interrupt request enable bit
#else
    union
    {
        struct
        {
            uint32_t EVENT_CNT_0_INT : 1; // Event counter overflow interrupt request enable bit for PMEVCNTR0
            uint32_t EVENT_CNT_1_INT : 1; // Event counter overflow interrupt request enable bit for PMEVCNTR1
            uint32_t EVENT_CNT_2_INT : 1; // Event counter overflow interrupt request enable bit for PMEVCNTR2
            uint32_t EVENT_CNT_3_INT : 1; // Event counter overflow interrupt request enable bit for PMEVCNTR3
            uint32_t reserved0 : 27;
            uint32_t CYCLE_CNT_INT : 1; // PMCCNTR overflow interrupt request enable bit
        };
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR pmintset_r() :
        EVENT_CNT_0_INT(static_cast<uint32_t>(0)), EVENT_CNT_1_INT(static_cast<uint32_t>(0)),
        EVENT_CNT_2_INT(static_cast<uint32_t>(0)), EVENT_CNT_3_INT(static_cast<uint32_t>(0)),
        CYCLE_CNT_INT(static_cast<uint32_t>(0))
    {
    }
    CONSTEXPR pmintset_r(uint32_t value) :
        EVENT_CNT_0_INT(value >> 0), EVENT_CNT_1_INT(value >> 1), EVENT_CNT_2_INT(value >> 2),
        EVENT_CNT_3_INT(value >> 3), CYCLE_CNT_INT(value >> 31)
    {
    }
    CONSTEXPR void operator=(uint32_t value)
    {
        EVENT_CNT_0_INT = value >> 0;
        EVENT_CNT_1_INT = value >> 1;
        EVENT_CNT_2_INT = value >> 2;
        EVENT_CNT_3_INT = value >> 3;
        CYCLE_CNT_INT   = value >> 31;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (EVENT_CNT_0_INT << 0) | (EVENT_CNT_1_INT << 1) | (EVENT_CNT_2_INT << 2) | (EVENT_CNT_3_INT << 3) |
               (CYCLE_CNT_INT << 31);
    }
    pmintset_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR pmintset_r() :
        EVENT_CNT_0_INT(static_cast<uint32_t>(0)), EVENT_CNT_1_INT(static_cast<uint32_t>(0)),
        EVENT_CNT_2_INT(static_cast<uint32_t>(0)), EVENT_CNT_3_INT(static_cast<uint32_t>(0)),
        reserved0(static_cast<uint32_t>(0)), CYCLE_CNT_INT(static_cast<uint32_t>(0))
    {
    }
    CONSTEXPR pmintset_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    pmintset_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_EVENT_CNT_0_INT() const
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_0_INT);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_EVENT_CNT_0_INT() const volatile
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_0_INT);
        return value;
    }
#endif
    CONSTEXPR pmintset_r &set_EVENT_CNT_0_INT(uint32_t value)
    {
        EVENT_CNT_0_INT = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_EVENT_CNT_1_INT() const
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_1_INT);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_EVENT_CNT_1_INT() const volatile
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_1_INT);
        return value;
    }
#endif
    CONSTEXPR pmintset_r &set_EVENT_CNT_1_INT(uint32_t value)
    {
        EVENT_CNT_1_INT = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_EVENT_CNT_2_INT() const
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_2_INT);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_EVENT_CNT_2_INT() const volatile
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_2_INT);
        return value;
    }
#endif
    CONSTEXPR pmintset_r &set_EVENT_CNT_2_INT(uint32_t value)
    {
        EVENT_CNT_2_INT = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_EVENT_CNT_3_INT() const
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_3_INT);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_EVENT_CNT_3_INT() const volatile
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_3_INT);
        return value;
    }
#endif
    CONSTEXPR pmintset_r &set_EVENT_CNT_3_INT(uint32_t value)
    {
        EVENT_CNT_3_INT = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_CYCLE_CNT_INT() const
    {
        uint32_t value = static_cast<uint32_t>(CYCLE_CNT_INT);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_CYCLE_CNT_INT() const volatile
    {
        uint32_t value = static_cast<uint32_t>(CYCLE_CNT_INT);
        return value;
    }
#endif
    CONSTEXPR pmintset_r &set_CYCLE_CNT_INT(uint32_t value)
    {
        CYCLE_CNT_INT = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// pmintclr_r - Interrupt enable clear register
struct pmintclr_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<1> EVENT_CNT_0_INT; // Event counter overflow interrupt request disable bit for PMEVCNTR0
    ::core::dt::uint_t<1> EVENT_CNT_1_INT; // Event counter overflow interrupt request disable bit for PMEVCNTR1
    ::core::dt::uint_t<1> EVENT_CNT_2_INT; // Event counter overflow interrupt request disable bit for PMEVCNTR2
    ::core::dt::uint_t<1> EVENT_CNT_3_INT; // Event counter overflow interrupt request disable bit for PMEVCNTR3
    ::core::dt::uint_t<1> CYCLE_CNT_INT;   // PMCCNTR overflow interrupt request disable bit
#else
    union
    {
        struct
        {
            uint32_t EVENT_CNT_0_INT : 1; // Event counter overflow interrupt request disable bit for PMEVCNTR0
            uint32_t EVENT_CNT_1_INT : 1; // Event counter overflow interrupt request disable bit for PMEVCNTR1
            uint32_t EVENT_CNT_2_INT : 1; // Event counter overflow interrupt request disable bit for PMEVCNTR2
            uint32_t EVENT_CNT_3_INT : 1; // Event counter overflow interrupt request disable bit for PMEVCNTR3
            uint32_t reserved0 : 27;
            uint32_t CYCLE_CNT_INT : 1; // PMCCNTR overflow interrupt request disable bit
        };
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR pmintclr_r() :
        EVENT_CNT_0_INT(static_cast<uint32_t>(0)), EVENT_CNT_1_INT(static_cast<uint32_t>(0)),
        EVENT_CNT_2_INT(static_cast<uint32_t>(0)), EVENT_CNT_3_INT(static_cast<uint32_t>(0)),
        CYCLE_CNT_INT(static_cast<uint32_t>(0))
    {
    }
    CONSTEXPR pmintclr_r(uint32_t value) :
        EVENT_CNT_0_INT(value >> 0), EVENT_CNT_1_INT(value >> 1), EVENT_CNT_2_INT(value >> 2),
        EVENT_CNT_3_INT(value >> 3), CYCLE_CNT_INT(value >> 31)
    {
    }
    CONSTEXPR void operator=(uint32_t value)
    {
        EVENT_CNT_0_INT = value >> 0;
        EVENT_CNT_1_INT = value >> 1;
        EVENT_CNT_2_INT = value >> 2;
        EVENT_CNT_3_INT = value >> 3;
        CYCLE_CNT_INT   = value >> 31;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (EVENT_CNT_0_INT << 0) | (EVENT_CNT_1_INT << 1) | (EVENT_CNT_2_INT << 2) | (EVENT_CNT_3_INT << 3) |
               (CYCLE_CNT_INT << 31);
    }
    pmintclr_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR pmintclr_r() :
        EVENT_CNT_0_INT(static_cast<uint32_t>(0)), EVENT_CNT_1_INT(static_cast<uint32_t>(0)),
        EVENT_CNT_2_INT(static_cast<uint32_t>(0)), EVENT_CNT_3_INT(static_cast<uint32_t>(0)),
        reserved0(static_cast<uint32_t>(0)), CYCLE_CNT_INT(static_cast<uint32_t>(0))
    {
    }
    CONSTEXPR pmintclr_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    pmintclr_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_EVENT_CNT_0_INT() const
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_0_INT);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_EVENT_CNT_0_INT() const volatile
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_0_INT);
        return value;
    }
#endif
    CONSTEXPR pmintclr_r &set_EVENT_CNT_0_INT(uint32_t value)
    {
        EVENT_CNT_0_INT = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_EVENT_CNT_1_INT() const
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_1_INT);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_EVENT_CNT_1_INT() const volatile
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_1_INT);
        return value;
    }
#endif
    CONSTEXPR pmintclr_r &set_EVENT_CNT_1_INT(uint32_t value)
    {
        EVENT_CNT_1_INT = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_EVENT_CNT_2_INT() const
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_2_INT);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_EVENT_CNT_2_INT() const volatile
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_2_INT);
        return value;
    }
#endif
    CONSTEXPR pmintclr_r &set_EVENT_CNT_2_INT(uint32_t value)
    {
        EVENT_CNT_2_INT = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_EVENT_CNT_3_INT() const
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_3_INT);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_EVENT_CNT_3_INT() const volatile
    {
        uint32_t value = static_cast<uint32_t>(EVENT_CNT_3_INT);
        return value;
    }
#endif
    CONSTEXPR pmintclr_r &set_EVENT_CNT_3_INT(uint32_t value)
    {
        EVENT_CNT_3_INT = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_CYCLE_CNT_INT() const
    {
        uint32_t value = static_cast<uint32_t>(CYCLE_CNT_INT);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_CYCLE_CNT_INT() const volatile
    {
        uint32_t value = static_cast<uint32_t>(CYCLE_CNT_INT);
        return value;
    }
#endif
    CONSTEXPR pmintclr_r &set_CYCLE_CNT_INT(uint32_t value)
    {
        CYCLE_CNT_INT = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// pmccntr_lo_r - Performance monitor cycle count low register
struct pmccntr_lo_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<32> CYCLE_CNT_LO; // Cycle count low
#else
    union
    {
        uint32_t CYCLE_CNT_LO; // Cycle count low
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR pmccntr_lo_r() : CYCLE_CNT_LO(static_cast<uint32_t>(0)) {}
    CONSTEXPR pmccntr_lo_r(uint32_t value) : CYCLE_CNT_LO(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        CYCLE_CNT_LO = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (CYCLE_CNT_LO << 0);
    }
    pmccntr_lo_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR pmccntr_lo_r() : CYCLE_CNT_LO(static_cast<uint32_t>(0)) {}
    CONSTEXPR pmccntr_lo_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    pmccntr_lo_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_CYCLE_CNT_LO() const
    {
        uint32_t value = static_cast<uint32_t>(CYCLE_CNT_LO);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_CYCLE_CNT_LO() const volatile
    {
        uint32_t value = static_cast<uint32_t>(CYCLE_CNT_LO);
        return value;
    }
#endif
    CONSTEXPR pmccntr_lo_r &set_CYCLE_CNT_LO(uint32_t value)
    {
        CYCLE_CNT_LO = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// pmccntr_hi_r - Performance monitor cycle count high register
struct pmccntr_hi_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<16> CYCLE_CNT_HI; // Cycle count high
#else
    union
    {
        struct
        {
            uint32_t CYCLE_CNT_HI : 16; // Cycle count high
            uint32_t reserved0 : 16;
        };
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR pmccntr_hi_r() : CYCLE_CNT_HI(static_cast<uint32_t>(0)) {}
    CONSTEXPR pmccntr_hi_r(uint32_t value) : CYCLE_CNT_HI(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        CYCLE_CNT_HI = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (CYCLE_CNT_HI << 0);
    }
    pmccntr_hi_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR pmccntr_hi_r() : CYCLE_CNT_HI(static_cast<uint32_t>(0)), reserved0(static_cast<uint32_t>(0)) {}
    CONSTEXPR pmccntr_hi_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    pmccntr_hi_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_CYCLE_CNT_HI() const
    {
        uint32_t value = static_cast<uint32_t>(CYCLE_CNT_HI);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_CYCLE_CNT_HI() const volatile
    {
        uint32_t value = static_cast<uint32_t>(CYCLE_CNT_HI);
        return value;
    }
#endif
    CONSTEXPR pmccntr_hi_r &set_CYCLE_CNT_HI(uint32_t value)
    {
        CYCLE_CNT_HI = ((1u << 16) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// pmccntr_cfg_r - Set start/stop event on the cycle counter
struct pmccntr_cfg_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<10> CYCLE_CNT_CFG_START; // Cycle counter start event
    ::core::dt::uint_t<10> CYCLE_CNT_CFG_STOP;  // Cycle counter stop event
#else
    union
    {
        struct
        {
            uint32_t CYCLE_CNT_CFG_START : 10; // Cycle counter start event
            uint32_t reserved0 : 6;
            uint32_t CYCLE_CNT_CFG_STOP : 10; // Cycle counter stop event
            uint32_t reserved1 : 6;
        };
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR pmccntr_cfg_r() :
        CYCLE_CNT_CFG_START(static_cast<uint32_t>(0)), CYCLE_CNT_CFG_STOP(static_cast<uint32_t>(0))
    {
    }
    CONSTEXPR pmccntr_cfg_r(uint32_t value) : CYCLE_CNT_CFG_START(value >> 0), CYCLE_CNT_CFG_STOP(value >> 16) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        CYCLE_CNT_CFG_START = value >> 0;
        CYCLE_CNT_CFG_STOP  = value >> 16;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (CYCLE_CNT_CFG_START << 0) | (CYCLE_CNT_CFG_STOP << 16);
    }
    pmccntr_cfg_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR pmccntr_cfg_r() :
        CYCLE_CNT_CFG_START(static_cast<uint32_t>(0)), reserved0(static_cast<uint32_t>(0)),
        CYCLE_CNT_CFG_STOP(static_cast<uint32_t>(0)), reserved1(static_cast<uint32_t>(0))
    {
    }
    CONSTEXPR pmccntr_cfg_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    pmccntr_cfg_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_CYCLE_CNT_CFG_START() const
    {
        uint32_t value = static_cast<uint32_t>(CYCLE_CNT_CFG_START);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_CYCLE_CNT_CFG_START() const volatile
    {
        uint32_t value = static_cast<uint32_t>(CYCLE_CNT_CFG_START);
        return value;
    }
#endif
    CONSTEXPR pmccntr_cfg_r &set_CYCLE_CNT_CFG_START(uint32_t value)
    {
        CYCLE_CNT_CFG_START = ((1u << 10) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_CYCLE_CNT_CFG_STOP() const
    {
        uint32_t value = static_cast<uint32_t>(CYCLE_CNT_CFG_STOP);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_CYCLE_CNT_CFG_STOP() const volatile
    {
        uint32_t value = static_cast<uint32_t>(CYCLE_CNT_CFG_STOP);
        return value;
    }
#endif
    CONSTEXPR pmccntr_cfg_r &set_CYCLE_CNT_CFG_STOP(uint32_t value)
    {
        CYCLE_CNT_CFG_STOP = ((1u << 10) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// pmcaxi_chan_r - Set which AXI channel to monitor in PMU
struct pmcaxi_chan_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<4> AXI_CHAN; // Channel number to monitor (Read: 0=Cmd 1=IFM 2=Weights 3=Scale+Bias 4=Mem2Mem;
                                    // Write: 8=OFM 9=Mem2Mem)
    ::core::dt::uint_t<1> RW;       // 0 for read, 1 for write
    ::core::dt::uint_t<2>
        AXI_CNT; // AXI counter to monitor (0=AXI0 counter0, 1=AXI0 counter1, 2=AXI1 counter 2, 3=AXI counter3)
#else
    union
    {
        struct
        {
            uint32_t AXI_CHAN : 4; // Channel number to monitor (Read: 0=Cmd 1=IFM 2=Weights 3=Scale+Bias 4=Mem2Mem;
                                   // Write: 8=OFM 9=Mem2Mem)
            uint32_t reserved0 : 3;
            uint32_t RW : 1;      // 0 for read, 1 for write
            uint32_t AXI_CNT : 2; // AXI counter to monitor (0=AXI0 counter0, 1=AXI0 counter1, 2=AXI1 counter 2, 3=AXI
                                  // counter3)
            uint32_t reserved1 : 22;
        };
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR pmcaxi_chan_r() :
        AXI_CHAN(static_cast<uint32_t>(0)), RW(static_cast<uint32_t>(0)), AXI_CNT(static_cast<uint32_t>(0))
    {
    }
    CONSTEXPR pmcaxi_chan_r(uint32_t value) : AXI_CHAN(value >> 0), RW(value >> 7), AXI_CNT(value >> 8) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        AXI_CHAN = value >> 0;
        RW       = value >> 7;
        AXI_CNT  = value >> 8;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (AXI_CHAN << 0) | (RW << 7) | (AXI_CNT << 8);
    }
    pmcaxi_chan_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR pmcaxi_chan_r() :
        AXI_CHAN(static_cast<uint32_t>(0)), reserved0(static_cast<uint32_t>(0)), RW(static_cast<uint32_t>(0)),
        AXI_CNT(static_cast<uint32_t>(0)), reserved1(static_cast<uint32_t>(0))
    {
    }
    CONSTEXPR pmcaxi_chan_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    pmcaxi_chan_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR uint32_t get_AXI_CHAN() const
    {
        uint32_t value = static_cast<uint32_t>(AXI_CHAN);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_AXI_CHAN() const volatile
    {
        uint32_t value = static_cast<uint32_t>(AXI_CHAN);
        return value;
    }
#endif
    CONSTEXPR pmcaxi_chan_r &set_AXI_CHAN(uint32_t value)
    {
        AXI_CHAN = ((1u << 4) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_RW() const
    {
        uint32_t value = static_cast<uint32_t>(RW);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_RW() const volatile
    {
        uint32_t value = static_cast<uint32_t>(RW);
        return value;
    }
#endif
    CONSTEXPR pmcaxi_chan_r &set_RW(uint32_t value)
    {
        RW = ((1u << 1) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_AXI_CNT() const
    {
        uint32_t value = static_cast<uint32_t>(AXI_CNT);
        return value;
    }
#ifndef MODEL_REGS
    uint32_t get_AXI_CNT() const volatile
    {
        uint32_t value = static_cast<uint32_t>(AXI_CNT);
        return value;
    }
#endif
    CONSTEXPR pmcaxi_chan_r &set_AXI_CNT(uint32_t value)
    {
        AXI_CNT = ((1u << 2) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// pmevtyper0_r - Performance monitor event type register 0
struct pmevtyper0_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<10> EV_TYPE; // Event Type
#else
    union
    {
        struct
        {
            uint32_t EV_TYPE : 10; // Event Type
            uint32_t reserved0 : 22;
        };
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR pmevtyper0_r() : EV_TYPE(static_cast<uint32_t>(0)) {}
    CONSTEXPR pmevtyper0_r(uint32_t value) : EV_TYPE(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        EV_TYPE = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (EV_TYPE << 0);
    }
    pmevtyper0_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR pmevtyper0_r() : EV_TYPE(static_cast<uint32_t>(0)), reserved0(static_cast<uint32_t>(0)) {}
    CONSTEXPR pmevtyper0_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    pmevtyper0_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR ::pmu_event_type get_EV_TYPE() const
    {
        ::pmu_event_type value = static_cast<::pmu_event_type>(EV_TYPE);
        return value;
    }
#ifndef MODEL_REGS
    ::pmu_event_type get_EV_TYPE() const volatile
    {
        ::pmu_event_type value = static_cast<::pmu_event_type>(EV_TYPE);
        return value;
    }
#endif
    CONSTEXPR pmevtyper0_r &set_EV_TYPE(::pmu_event_type value)
    {
        EV_TYPE = ((1u << 10) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// pmevtyper1_r - Performance monitor event type register 1
struct pmevtyper1_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<10> EV_TYPE; // Event Type
#else
    union
    {
        struct
        {
            uint32_t EV_TYPE : 10; // Event Type
            uint32_t reserved0 : 22;
        };
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR pmevtyper1_r() : EV_TYPE(static_cast<uint32_t>(0)) {}
    CONSTEXPR pmevtyper1_r(uint32_t value) : EV_TYPE(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        EV_TYPE = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (EV_TYPE << 0);
    }
    pmevtyper1_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR pmevtyper1_r() : EV_TYPE(static_cast<uint32_t>(0)), reserved0(static_cast<uint32_t>(0)) {}
    CONSTEXPR pmevtyper1_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    pmevtyper1_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR ::pmu_event_type get_EV_TYPE() const
    {
        ::pmu_event_type value = static_cast<::pmu_event_type>(EV_TYPE);
        return value;
    }
#ifndef MODEL_REGS
    ::pmu_event_type get_EV_TYPE() const volatile
    {
        ::pmu_event_type value = static_cast<::pmu_event_type>(EV_TYPE);
        return value;
    }
#endif
    CONSTEXPR pmevtyper1_r &set_EV_TYPE(::pmu_event_type value)
    {
        EV_TYPE = ((1u << 10) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// pmevtyper2_r - Performance monitor event type register 2
struct pmevtyper2_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<10> EV_TYPE; // Event Type
#else
    union
    {
        struct
        {
            uint32_t EV_TYPE : 10; // Event Type
            uint32_t reserved0 : 22;
        };
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR pmevtyper2_r() : EV_TYPE(static_cast<uint32_t>(0)) {}
    CONSTEXPR pmevtyper2_r(uint32_t value) : EV_TYPE(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        EV_TYPE = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (EV_TYPE << 0);
    }
    pmevtyper2_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR pmevtyper2_r() : EV_TYPE(static_cast<uint32_t>(0)), reserved0(static_cast<uint32_t>(0)) {}
    CONSTEXPR pmevtyper2_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    pmevtyper2_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR ::pmu_event_type get_EV_TYPE() const
    {
        ::pmu_event_type value = static_cast<::pmu_event_type>(EV_TYPE);
        return value;
    }
#ifndef MODEL_REGS
    ::pmu_event_type get_EV_TYPE() const volatile
    {
        ::pmu_event_type value = static_cast<::pmu_event_type>(EV_TYPE);
        return value;
    }
#endif
    CONSTEXPR pmevtyper2_r &set_EV_TYPE(::pmu_event_type value)
    {
        EV_TYPE = ((1u << 10) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// pmevtyper3_r - Performance monitor event type register 3
struct pmevtyper3_r
{
#ifdef __cplusplus
  private:
#endif //__cplusplus
#ifdef MODEL_REGS
    ::core::dt::uint_t<10> EV_TYPE; // Event Type
#else
    union
    {
        struct
        {
            uint32_t EV_TYPE : 10; // Event Type
            uint32_t reserved0 : 22;
        };
        uint32_t word;
    };
#endif
#ifdef __cplusplus
  public:
#ifdef MODEL_REGS
    CONSTEXPR pmevtyper3_r() : EV_TYPE(static_cast<uint32_t>(0)) {}
    CONSTEXPR pmevtyper3_r(uint32_t value) : EV_TYPE(value >> 0) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        EV_TYPE = value >> 0;
    }
    CONSTEXPR operator uint32_t() const
    {
        return (EV_TYPE << 0);
    }
    pmevtyper3_r copy()
    {
        return *this;
    }
#else
    CONSTEXPR pmevtyper3_r() : EV_TYPE(static_cast<uint32_t>(0)), reserved0(static_cast<uint32_t>(0)) {}
    CONSTEXPR pmevtyper3_r(uint32_t init) : word(init) {}
    CONSTEXPR void operator=(uint32_t value)
    {
        word = value;
    }
    void operator=(uint32_t value) volatile
    {
        word = value;
    }
    CONSTEXPR operator uint32_t()
    {
        return word;
    }
    operator uint32_t() volatile
    {
        return word;
    }
    pmevtyper3_r copy() volatile
    {
        return *this;
    }
#endif
    CONSTEXPR ::pmu_event_type get_EV_TYPE() const
    {
        ::pmu_event_type value = static_cast<::pmu_event_type>(EV_TYPE);
        return value;
    }
#ifndef MODEL_REGS
    ::pmu_event_type get_EV_TYPE() const volatile
    {
        ::pmu_event_type value = static_cast<::pmu_event_type>(EV_TYPE);
        return value;
    }
#endif
    CONSTEXPR pmevtyper3_r &set_EV_TYPE(::pmu_event_type value)
    {
        EV_TYPE = ((1u << 10) - 1) & static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

struct NPU_REG
{
    STRUCT id_r ID;           // 0x0
    STRUCT status_r STATUS;   // 0x4
    STRUCT cmd_r CMD;         // 0x8
    STRUCT reset_r RESET;     // 0xc
    STRUCT qbase0_r QBASE0;   // 0x10
    STRUCT qbase1_r QBASE1;   // 0x14
    STRUCT qread_r QREAD;     // 0x18
    STRUCT qconfig_r QCONFIG; // 0x1c
    STRUCT qsize_r QSIZE;     // 0x20
    STRUCT prot_r PROT;       // 0x24
    STRUCT config_r CONFIG;   // 0x28
    STRUCT lock_r LOCK;       // 0x2c
#ifndef MODEL_REGS
    uint32_t unused0[3];
#endif
    STRUCT regioncfg_r REGIONCFG;   // 0x3c
    STRUCT axi_limit0_r AXI_LIMIT0; // 0x40
    STRUCT axi_limit1_r AXI_LIMIT1; // 0x44
    STRUCT axi_limit2_r AXI_LIMIT2; // 0x48
    STRUCT axi_limit3_r AXI_LIMIT3; // 0x4c
#ifndef MODEL_REGS
    uint32_t unused1[12];
#endif
    STRUCT basep0_r BASEP0;   // 0x80
    STRUCT basep1_r BASEP1;   // 0x84
    STRUCT basep2_r BASEP2;   // 0x88
    STRUCT basep3_r BASEP3;   // 0x8c
    STRUCT basep4_r BASEP4;   // 0x90
    STRUCT basep5_r BASEP5;   // 0x94
    STRUCT basep6_r BASEP6;   // 0x98
    STRUCT basep7_r BASEP7;   // 0x9c
    STRUCT basep8_r BASEP8;   // 0xa0
    STRUCT basep9_r BASEP9;   // 0xa4
    STRUCT basep10_r BASEP10; // 0xa8
    STRUCT basep11_r BASEP11; // 0xac
    STRUCT basep12_r BASEP12; // 0xb0
    STRUCT basep13_r BASEP13; // 0xb4
    STRUCT basep14_r BASEP14; // 0xb8
    STRUCT basep15_r BASEP15; // 0xbc
#ifndef MODEL_REGS
    uint32_t unused2[32];
#endif
    STRUCT clkforce_r CLKFORCE; // 0x140
    uint32_t DEBUG;             // 0x144
    uint32_t DEBUG2;            // 0x148
    uint32_t DEBUGCORE;         // 0x14c
#ifndef MODEL_REGS
    uint32_t unused3[12];
#endif
    STRUCT pmcr_r PMCR;             // 0x180
    STRUCT pmcntenset_r PMCNTENSET; // 0x184
    STRUCT pmcntenclr_r PMCNTENCLR; // 0x188
    STRUCT pmovsset_r PMOVSSET;     // 0x18c
    STRUCT pmovsclr_r PMOVSCLR;     // 0x190
    STRUCT pmintset_r PMINTSET;     // 0x194
    STRUCT pmintclr_r PMINTCLR;     // 0x198
#ifndef MODEL_REGS
    uint32_t unused4[1];
#endif
    STRUCT pmccntr_lo_r PMCCNTR_LO;   // 0x1a0
    STRUCT pmccntr_hi_r PMCCNTR_HI;   // 0x1a4
    STRUCT pmccntr_cfg_r PMCCNTR_CFG; // 0x1a8
    STRUCT pmcaxi_chan_r PMCAXI_CHAN; // 0x1ac
#ifndef MODEL_REGS
    uint32_t unused5[20];
#endif
    uint32_t KERNEL_X;           // 0x200
    uint32_t KERNEL_Y;           // 0x204
    uint32_t KERNEL_W_M1;        // 0x208
    uint32_t KERNEL_H_M1;        // 0x20c
    uint32_t OFM_CBLK_WIDTH_M1;  // 0x210
    uint32_t OFM_CBLK_HEIGHT_M1; // 0x214
    uint32_t OFM_CBLK_DEPTH_M1;  // 0x218
    uint32_t IFM_CBLK_DEPTH_M1;  // 0x21c
    uint32_t OFM_X;              // 0x220
    uint32_t OFM_Y;              // 0x224
    uint32_t OFM_Z;              // 0x228
    uint32_t IFM_Z;              // 0x22c
    uint32_t PAD_TOP;            // 0x230
    uint32_t PAD_LEFT;           // 0x234
    uint32_t IFM_CBLK_WIDTH;     // 0x238
    uint32_t IFM_CBLK_HEIGHT;    // 0x23c
    uint32_t DMA_IFM_SRC;        // 0x240
    uint32_t DMA_IFM_SRC_HI;     // 0x244
    uint32_t DMA_IFM_DST;        // 0x248
    uint32_t DMA_OFM_SRC;        // 0x24c
    uint32_t DMA_OFM_DST;        // 0x250
    uint32_t DMA_OFM_DST_HI;     // 0x254
    uint32_t DMA_WEIGHT_SRC;     // 0x258
    uint32_t DMA_WEIGHT_SRC_HI;  // 0x25c
    uint32_t DMA_CMD_SRC;        // 0x260
    uint32_t DMA_CMD_SRC_HI;     // 0x264
    uint32_t DMA_CMD_SIZE;       // 0x268
    uint32_t DMA_M2M_SRC;        // 0x26c
    uint32_t DMA_M2M_SRC_HI;     // 0x270
    uint32_t DMA_M2M_DST;        // 0x274
    uint32_t DMA_M2M_DST_HI;     // 0x278
    uint32_t CURRENT_QREAD;      // 0x27c
    uint32_t DMA_SCALE_SRC;      // 0x280
    uint32_t DMA_SCALE_SRC_HI;   // 0x284
#ifndef MODEL_REGS
    uint32_t unused6[13];
#endif
    uint32_t CURRENT_CMD; // 0x2bc
#ifndef MODEL_REGS
    uint32_t unused7[16];
#endif
    uint32_t PMEVCNTR[4]; // 0x300
#ifndef MODEL_REGS
    uint32_t unused8[28];
#endif
    STRUCT pmevtyper0_r PMEVTYPER[4]; // 0x380
#ifndef MODEL_REGS
    uint32_t unused9[28];
#endif
    uint32_t SHARED_BUFFER[256]; // 0x400
    uint32_t IFM_PAD_TOP;        // 0x800
    uint32_t IFM_PAD_LEFT;       // 0x804
    uint32_t IFM_PAD_RIGHT;      // 0x808
    uint32_t IFM_PAD_BOTTOM;     // 0x80c
    uint32_t IFM_DEPTH_M1;       // 0x810
    uint32_t IFM_PRECISION;      // 0x814
#ifndef MODEL_REGS
    uint32_t unused10[1];
#endif
    uint32_t IFM_UPSCALE; // 0x81c
#ifndef MODEL_REGS
    uint32_t unused11[1];
#endif
    uint32_t IFM_ZERO_POINT; // 0x824
    uint32_t IFM_WIDTH0_M1;  // 0x828
    uint32_t IFM_HEIGHT0_M1; // 0x82c
    uint32_t IFM_HEIGHT1_M1; // 0x830
    uint32_t IFM_IB_END;     // 0x834
#ifndef MODEL_REGS
    uint32_t unused12[1];
#endif
    uint32_t IFM_REGION; // 0x83c
#ifndef MODEL_REGS
    uint32_t unused13[1];
#endif
    uint32_t OFM_WIDTH_M1;      // 0x844
    uint32_t OFM_HEIGHT_M1;     // 0x848
    uint32_t OFM_DEPTH_M1;      // 0x84c
    uint32_t OFM_PRECISION;     // 0x850
    uint32_t OFM_BLK_WIDTH_M1;  // 0x854
    uint32_t OFM_BLK_HEIGHT_M1; // 0x858
    uint32_t OFM_BLK_DEPTH_M1;  // 0x85c
    uint32_t OFM_ZERO_POINT;    // 0x860
#ifndef MODEL_REGS
    uint32_t unused14[1];
#endif
    uint32_t OFM_WIDTH0_M1;  // 0x868
    uint32_t OFM_HEIGHT0_M1; // 0x86c
    uint32_t OFM_HEIGHT1_M1; // 0x870
#ifndef MODEL_REGS
    uint32_t unused15[2];
#endif
    uint32_t OFM_REGION;       // 0x87c
    uint32_t KERNEL_WIDTH_M1;  // 0x880
    uint32_t KERNEL_HEIGHT_M1; // 0x884
    uint32_t KERNEL_STRIDE;    // 0x888
    uint32_t PARALLEL_MODE;    // 0x88c
    uint32_t ACC_FORMAT;       // 0x890
    uint32_t ACTIVATION;       // 0x894
    uint32_t ACTIVATION_MIN;   // 0x898
    uint32_t ACTIVATION_MAX;   // 0x89c
    uint32_t WEIGHT_REGION;    // 0x8a0
    uint32_t SCALE_REGION;     // 0x8a4
#ifndef MODEL_REGS
    uint32_t unused16[3];
#endif
    uint32_t AB_START; // 0x8b4
#ifndef MODEL_REGS
    uint32_t unused17[1];
#endif
    uint32_t BLOCKDEP;        // 0x8bc
    uint32_t DMA0_SRC_REGION; // 0x8c0
    uint32_t DMA0_DST_REGION; // 0x8c4
    uint32_t DMA0_SIZE0;      // 0x8c8
    uint32_t DMA0_SIZE1;      // 0x8cc
#ifndef MODEL_REGS
    uint32_t unused18[12];
#endif
    uint32_t IFM2_BROADCAST; // 0x900
    uint32_t IFM2_SCALAR;    // 0x904
#ifndef MODEL_REGS
    uint32_t unused19[3];
#endif
    uint32_t IFM2_PRECISION; // 0x914
#ifndef MODEL_REGS
    uint32_t unused20[3];
#endif
    uint32_t IFM2_ZERO_POINT; // 0x924
    uint32_t IFM2_WIDTH0_M1;  // 0x928
    uint32_t IFM2_HEIGHT0_M1; // 0x92c
    uint32_t IFM2_HEIGHT1_M1; // 0x930
    uint32_t IFM2_IB_START;   // 0x934
#ifndef MODEL_REGS
    uint32_t unused21[1];
#endif
    uint32_t IFM2_REGION; // 0x93c
#ifndef MODEL_REGS
    uint32_t unused22[48];
#endif
    uint32_t IFM_BASE0;       // 0xa00
    uint32_t IFM_BASE0_HI;    // 0xa04
    uint32_t IFM_BASE1;       // 0xa08
    uint32_t IFM_BASE1_HI;    // 0xa0c
    uint32_t IFM_BASE2;       // 0xa10
    uint32_t IFM_BASE2_HI;    // 0xa14
    uint32_t IFM_BASE3;       // 0xa18
    uint32_t IFM_BASE3_HI;    // 0xa1c
    uint32_t IFM_STRIDE_X;    // 0xa20
    uint32_t IFM_STRIDE_X_HI; // 0xa24
    uint32_t IFM_STRIDE_Y;    // 0xa28
    uint32_t IFM_STRIDE_Y_HI; // 0xa2c
    uint32_t IFM_STRIDE_C;    // 0xa30
    uint32_t IFM_STRIDE_C_HI; // 0xa34
#ifndef MODEL_REGS
    uint32_t unused23[2];
#endif
    uint32_t OFM_BASE0;       // 0xa40
    uint32_t OFM_BASE0_HI;    // 0xa44
    uint32_t OFM_BASE1;       // 0xa48
    uint32_t OFM_BASE1_HI;    // 0xa4c
    uint32_t OFM_BASE2;       // 0xa50
    uint32_t OFM_BASE2_HI;    // 0xa54
    uint32_t OFM_BASE3;       // 0xa58
    uint32_t OFM_BASE3_HI;    // 0xa5c
    uint32_t OFM_STRIDE_X;    // 0xa60
    uint32_t OFM_STRIDE_X_HI; // 0xa64
    uint32_t OFM_STRIDE_Y;    // 0xa68
    uint32_t OFM_STRIDE_Y_HI; // 0xa6c
    uint32_t OFM_STRIDE_C;    // 0xa70
    uint32_t OFM_STRIDE_C_HI; // 0xa74
#ifndef MODEL_REGS
    uint32_t unused24[2];
#endif
    uint32_t WEIGHT_BASE;      // 0xa80
    uint32_t WEIGHT_BASE_HI;   // 0xa84
    uint32_t WEIGHT_LENGTH;    // 0xa88
    uint32_t WEIGHT_LENGTH_HI; // 0xa8c
    uint32_t SCALE_BASE;       // 0xa90
    uint32_t SCALE_BASE_HI;    // 0xa94
    uint32_t SCALE_LENGTH;     // 0xa98
#ifndef MODEL_REGS
    uint32_t unused25[1];
#endif
    uint32_t OFM_SCALE;       // 0xaa0
    uint32_t OFM_SCALE_SHIFT; // 0xaa4
    uint32_t OPA_SCALE;       // 0xaa8
    uint32_t OPA_SCALE_SHIFT; // 0xaac
    uint32_t OPB_SCALE;       // 0xab0
#ifndef MODEL_REGS
    uint32_t unused26[3];
#endif
    uint32_t DMA0_SRC;      // 0xac0
    uint32_t DMA0_SRC_HI;   // 0xac4
    uint32_t DMA0_DST;      // 0xac8
    uint32_t DMA0_DST_HI;   // 0xacc
    uint32_t DMA0_LEN;      // 0xad0
    uint32_t DMA0_LEN_HI;   // 0xad4
    uint32_t DMA0_SKIP0;    // 0xad8
    uint32_t DMA0_SKIP0_HI; // 0xadc
    uint32_t DMA0_SKIP1;    // 0xae0
    uint32_t DMA0_SKIP1_HI; // 0xae4
#ifndef MODEL_REGS
    uint32_t unused27[6];
#endif
    uint32_t IFM2_BASE0;       // 0xb00
    uint32_t IFM2_BASE0_HI;    // 0xb04
    uint32_t IFM2_BASE1;       // 0xb08
    uint32_t IFM2_BASE1_HI;    // 0xb0c
    uint32_t IFM2_BASE2;       // 0xb10
    uint32_t IFM2_BASE2_HI;    // 0xb14
    uint32_t IFM2_BASE3;       // 0xb18
    uint32_t IFM2_BASE3_HI;    // 0xb1c
    uint32_t IFM2_STRIDE_X;    // 0xb20
    uint32_t IFM2_STRIDE_X_HI; // 0xb24
    uint32_t IFM2_STRIDE_Y;    // 0xb28
    uint32_t IFM2_STRIDE_Y_HI; // 0xb2c
    uint32_t IFM2_STRIDE_C;    // 0xb30
    uint32_t IFM2_STRIDE_C_HI; // 0xb34
#ifndef MODEL_REGS
    uint32_t unused28[2];
#endif
    uint32_t WEIGHT1_BASE;      // 0xb40
    uint32_t WEIGHT1_BASE_HI;   // 0xb44
    uint32_t WEIGHT1_LENGTH;    // 0xb48
    uint32_t WEIGHT1_LENGTH_HI; // 0xb4c
    uint32_t SCALE1_BASE;       // 0xb50
    uint32_t SCALE1_BASE_HI;    // 0xb54
    uint32_t SCALE1_LENGTH;     // 0xb58
#ifndef MODEL_REGS
    uint32_t unused29[281];
#endif
    uint32_t REVISION; // 0xfc0
#ifndef MODEL_REGS
    uint32_t unused30[3];
#endif
    STRUCT pid4_r PID4; // 0xfd0
    STRUCT pid5_r PID5; // 0xfd4
    STRUCT pid6_r PID6; // 0xfd8
    STRUCT pid7_r PID7; // 0xfdc
    STRUCT pid0_r PID0; // 0xfe0
    STRUCT pid1_r PID1; // 0xfe4
    STRUCT pid2_r PID2; // 0xfe8
    STRUCT pid3_r PID3; // 0xfec
    STRUCT cid0_r CID0; // 0xff0
    STRUCT cid1_r CID1; // 0xff4
    STRUCT cid2_r CID2; // 0xff8
    STRUCT cid3_r CID3; // 0xffc
#ifdef __cplusplus
    NPU_REG()
    {
        reset();
    }
    void reset()
    {
        ID                 = 161480704;
        STATUS             = 8;
        CMD                = 0;
        RESET              = 0;
        QBASE0             = 0;
        QBASE1             = 0;
        QREAD              = 0;
        QCONFIG            = 0;
        QSIZE              = 0;
        PROT               = 0;
        CONFIG             = 0;
        LOCK               = 0;
        REGIONCFG          = 0;
        AXI_LIMIT0         = 0;
        AXI_LIMIT1         = 0;
        AXI_LIMIT2         = 0;
        AXI_LIMIT3         = 0;
        BASEP0             = 0;
        BASEP1             = 0;
        BASEP2             = 0;
        BASEP3             = 0;
        BASEP4             = 0;
        BASEP5             = 0;
        BASEP6             = 0;
        BASEP7             = 0;
        BASEP8             = 0;
        BASEP9             = 0;
        BASEP10            = 0;
        BASEP11            = 0;
        BASEP12            = 0;
        BASEP13            = 0;
        BASEP14            = 0;
        BASEP15            = 0;
        REVISION           = 0;
        PID4               = 4;
        PID5               = 0;
        PID6               = 0;
        PID7               = 0;
        PID0               = 128;
        PID1               = 181;
        PID2               = 11;
        PID3               = 0;
        CID0               = 13;
        CID1               = 240;
        CID2               = 5;
        CID3               = 177;
        CLKFORCE           = 0;
        DEBUG              = 0;
        DEBUG2             = 0;
        DEBUGCORE          = 0;
        KERNEL_X           = 0;
        KERNEL_Y           = 0;
        KERNEL_W_M1        = 0;
        KERNEL_H_M1        = 0;
        OFM_CBLK_WIDTH_M1  = 0;
        OFM_CBLK_HEIGHT_M1 = 0;
        OFM_CBLK_DEPTH_M1  = 0;
        IFM_CBLK_DEPTH_M1  = 0;
        OFM_X              = 0;
        OFM_Y              = 0;
        OFM_Z              = 0;
        IFM_Z              = 0;
        PAD_TOP            = 0;
        PAD_LEFT           = 0;
        IFM_CBLK_WIDTH     = 0;
        IFM_CBLK_HEIGHT    = 0;
        DMA_IFM_SRC        = 0;
        DMA_IFM_SRC_HI     = 0;
        DMA_IFM_DST        = 0;
        DMA_OFM_SRC        = 0;
        DMA_OFM_DST        = 0;
        DMA_OFM_DST_HI     = 0;
        DMA_WEIGHT_SRC     = 0;
        DMA_WEIGHT_SRC_HI  = 0;
        DMA_CMD_SRC        = 0;
        DMA_CMD_SRC_HI     = 0;
        DMA_CMD_SIZE       = 0;
        DMA_M2M_SRC        = 0;
        DMA_M2M_SRC_HI     = 0;
        DMA_M2M_DST        = 0;
        DMA_M2M_DST_HI     = 0;
        CURRENT_QREAD      = 0;
        DMA_SCALE_SRC      = 0;
        DMA_SCALE_SRC_HI   = 0;
        CURRENT_CMD        = 0;
        IFM_PAD_TOP        = 0;
        IFM_PAD_LEFT       = 0;
        IFM_PAD_RIGHT      = 0;
        IFM_PAD_BOTTOM     = 0;
        IFM_DEPTH_M1       = 0;
        IFM_PRECISION      = 0;
        IFM_UPSCALE        = 0;
        IFM_ZERO_POINT     = 0;
        IFM_WIDTH0_M1      = 0;
        IFM_HEIGHT0_M1     = 0;
        IFM_HEIGHT1_M1     = 0;
        IFM_IB_END         = 0;
        IFM_REGION         = 0;
        OFM_WIDTH_M1       = 0;
        OFM_HEIGHT_M1      = 0;
        OFM_DEPTH_M1       = 0;
        OFM_PRECISION      = 0;
        OFM_BLK_WIDTH_M1   = 0;
        OFM_BLK_HEIGHT_M1  = 0;
        OFM_BLK_DEPTH_M1   = 0;
        OFM_ZERO_POINT     = 0;
        OFM_WIDTH0_M1      = 0;
        OFM_HEIGHT0_M1     = 0;
        OFM_HEIGHT1_M1     = 0;
        OFM_REGION         = 0;
        KERNEL_WIDTH_M1    = 0;
        KERNEL_HEIGHT_M1   = 0;
        KERNEL_STRIDE      = 0;
        PARALLEL_MODE      = 0;
        ACC_FORMAT         = 0;
        ACTIVATION         = 0;
        ACTIVATION_MIN     = 0;
        ACTIVATION_MAX     = 0;
        WEIGHT_REGION      = 0;
        SCALE_REGION       = 0;
        AB_START           = 0;
        BLOCKDEP           = 0;
        DMA0_SRC_REGION    = 0;
        DMA0_DST_REGION    = 0;
        DMA0_SIZE0         = 0;
        DMA0_SIZE1         = 0;
        IFM2_BROADCAST     = 0;
        IFM2_SCALAR        = 0;
        IFM2_PRECISION     = 0;
        IFM2_ZERO_POINT    = 0;
        IFM2_WIDTH0_M1     = 0;
        IFM2_HEIGHT0_M1    = 0;
        IFM2_HEIGHT1_M1    = 0;
        IFM2_IB_START      = 0;
        IFM2_REGION        = 0;
        IFM_BASE0          = 0;
        IFM_BASE0_HI       = 0;
        IFM_BASE1          = 0;
        IFM_BASE1_HI       = 0;
        IFM_BASE2          = 0;
        IFM_BASE2_HI       = 0;
        IFM_BASE3          = 0;
        IFM_BASE3_HI       = 0;
        IFM_STRIDE_X       = 0;
        IFM_STRIDE_X_HI    = 0;
        IFM_STRIDE_Y       = 0;
        IFM_STRIDE_Y_HI    = 0;
        IFM_STRIDE_C       = 0;
        IFM_STRIDE_C_HI    = 0;
        OFM_BASE0          = 0;
        OFM_BASE0_HI       = 0;
        OFM_BASE1          = 0;
        OFM_BASE1_HI       = 0;
        OFM_BASE2          = 0;
        OFM_BASE2_HI       = 0;
        OFM_BASE3          = 0;
        OFM_BASE3_HI       = 0;
        OFM_STRIDE_X       = 0;
        OFM_STRIDE_X_HI    = 0;
        OFM_STRIDE_Y       = 0;
        OFM_STRIDE_Y_HI    = 0;
        OFM_STRIDE_C       = 0;
        OFM_STRIDE_C_HI    = 0;
        WEIGHT_BASE        = 0;
        WEIGHT_BASE_HI     = 0;
        WEIGHT_LENGTH      = 0;
        WEIGHT_LENGTH_HI   = 0;
        SCALE_BASE         = 0;
        SCALE_BASE_HI      = 0;
        SCALE_LENGTH       = 0;
        OFM_SCALE          = 0;
        OFM_SCALE_SHIFT    = 0;
        OPA_SCALE          = 0;
        OPA_SCALE_SHIFT    = 0;
        OPB_SCALE          = 0;
        DMA0_SRC           = 0;
        DMA0_SRC_HI        = 0;
        DMA0_DST           = 0;
        DMA0_DST_HI        = 0;
        DMA0_LEN           = 0;
        DMA0_LEN_HI        = 0;
        DMA0_SKIP0         = 0;
        DMA0_SKIP0_HI      = 0;
        DMA0_SKIP1         = 0;
        DMA0_SKIP1_HI      = 0;
        IFM2_BASE0         = 0;
        IFM2_BASE0_HI      = 0;
        IFM2_BASE1         = 0;
        IFM2_BASE1_HI      = 0;
        IFM2_BASE2         = 0;
        IFM2_BASE2_HI      = 0;
        IFM2_BASE3         = 0;
        IFM2_BASE3_HI      = 0;
        IFM2_STRIDE_X      = 0;
        IFM2_STRIDE_X_HI   = 0;
        IFM2_STRIDE_Y      = 0;
        IFM2_STRIDE_Y_HI   = 0;
        IFM2_STRIDE_C      = 0;
        IFM2_STRIDE_C_HI   = 0;
        WEIGHT1_BASE       = 0;
        WEIGHT1_BASE_HI    = 0;
        WEIGHT1_LENGTH     = 0;
        WEIGHT1_LENGTH_HI  = 0;
        SCALE1_BASE        = 0;
        SCALE1_BASE_HI     = 0;
        SCALE1_LENGTH      = 0;
        PMCR               = 8192;
        PMCNTENSET         = 0;
        PMCNTENCLR         = 0;
        PMOVSSET           = 0;
        PMOVSCLR           = 0;
        PMINTSET           = 0;
        PMINTCLR           = 0;
        PMCCNTR_LO         = 0;
        PMCCNTR_HI         = 0;
        PMCCNTR_CFG        = 0;
        PMCAXI_CHAN        = 0;
        for (size_t i = 0; i < (sizeof(PMEVCNTR) / sizeof(PMEVCNTR[0])); ++i)
            PMEVCNTR[i] = 0;
        for (size_t i = 0; i < (sizeof(PMEVTYPER) / sizeof(PMEVTYPER[0])); ++i)
            PMEVTYPER[i] = 0;
        for (size_t i = 0; i < (sizeof(SHARED_BUFFER) / sizeof(SHARED_BUFFER[0])); ++i)
            SHARED_BUFFER[i] = 0;
    }
#ifdef MODEL_REGS
    uint32_t get(size_t offset) const
    {
        switch (offset)
        {
        case 0:
            return ID;
        case 4:
            return STATUS;
        case 8:
            return CMD;
        case 12:
            return RESET;
        case 16:
            return QBASE0;
        case 20:
            return QBASE1;
        case 24:
            return QREAD;
        case 28:
            return QCONFIG;
        case 32:
            return QSIZE;
        case 36:
            return PROT;
        case 40:
            return CONFIG;
        case 44:
            return LOCK;
        case 60:
            return REGIONCFG;
        case 64:
            return AXI_LIMIT0;
        case 68:
            return AXI_LIMIT1;
        case 72:
            return AXI_LIMIT2;
        case 76:
            return AXI_LIMIT3;
        case 128:
            return BASEP0;
        case 132:
            return BASEP1;
        case 136:
            return BASEP2;
        case 140:
            return BASEP3;
        case 144:
            return BASEP4;
        case 148:
            return BASEP5;
        case 152:
            return BASEP6;
        case 156:
            return BASEP7;
        case 160:
            return BASEP8;
        case 164:
            return BASEP9;
        case 168:
            return BASEP10;
        case 172:
            return BASEP11;
        case 176:
            return BASEP12;
        case 180:
            return BASEP13;
        case 184:
            return BASEP14;
        case 188:
            return BASEP15;
        case 4032:
            return REVISION;
        case 4048:
            return PID4;
        case 4052:
            return PID5;
        case 4056:
            return PID6;
        case 4060:
            return PID7;
        case 4064:
            return PID0;
        case 4068:
            return PID1;
        case 4072:
            return PID2;
        case 4076:
            return PID3;
        case 4080:
            return CID0;
        case 4084:
            return CID1;
        case 4088:
            return CID2;
        case 4092:
            return CID3;
        case 320:
            return CLKFORCE;
        case 324:
            return DEBUG;
        case 328:
            return DEBUG2;
        case 332:
            return DEBUGCORE;
        case 512:
            return KERNEL_X;
        case 516:
            return KERNEL_Y;
        case 520:
            return KERNEL_W_M1;
        case 524:
            return KERNEL_H_M1;
        case 528:
            return OFM_CBLK_WIDTH_M1;
        case 532:
            return OFM_CBLK_HEIGHT_M1;
        case 536:
            return OFM_CBLK_DEPTH_M1;
        case 540:
            return IFM_CBLK_DEPTH_M1;
        case 544:
            return OFM_X;
        case 548:
            return OFM_Y;
        case 552:
            return OFM_Z;
        case 556:
            return IFM_Z;
        case 560:
            return PAD_TOP;
        case 564:
            return PAD_LEFT;
        case 568:
            return IFM_CBLK_WIDTH;
        case 572:
            return IFM_CBLK_HEIGHT;
        case 576:
            return DMA_IFM_SRC;
        case 580:
            return DMA_IFM_SRC_HI;
        case 584:
            return DMA_IFM_DST;
        case 588:
            return DMA_OFM_SRC;
        case 592:
            return DMA_OFM_DST;
        case 596:
            return DMA_OFM_DST_HI;
        case 600:
            return DMA_WEIGHT_SRC;
        case 604:
            return DMA_WEIGHT_SRC_HI;
        case 608:
            return DMA_CMD_SRC;
        case 612:
            return DMA_CMD_SRC_HI;
        case 616:
            return DMA_CMD_SIZE;
        case 620:
            return DMA_M2M_SRC;
        case 624:
            return DMA_M2M_SRC_HI;
        case 628:
            return DMA_M2M_DST;
        case 632:
            return DMA_M2M_DST_HI;
        case 636:
            return CURRENT_QREAD;
        case 640:
            return DMA_SCALE_SRC;
        case 644:
            return DMA_SCALE_SRC_HI;
        case 700:
            return CURRENT_CMD;
        case 2048:
            return IFM_PAD_TOP;
        case 2052:
            return IFM_PAD_LEFT;
        case 2056:
            return IFM_PAD_RIGHT;
        case 2060:
            return IFM_PAD_BOTTOM;
        case 2064:
            return IFM_DEPTH_M1;
        case 2068:
            return IFM_PRECISION;
        case 2076:
            return IFM_UPSCALE;
        case 2084:
            return IFM_ZERO_POINT;
        case 2088:
            return IFM_WIDTH0_M1;
        case 2092:
            return IFM_HEIGHT0_M1;
        case 2096:
            return IFM_HEIGHT1_M1;
        case 2100:
            return IFM_IB_END;
        case 2108:
            return IFM_REGION;
        case 2116:
            return OFM_WIDTH_M1;
        case 2120:
            return OFM_HEIGHT_M1;
        case 2124:
            return OFM_DEPTH_M1;
        case 2128:
            return OFM_PRECISION;
        case 2132:
            return OFM_BLK_WIDTH_M1;
        case 2136:
            return OFM_BLK_HEIGHT_M1;
        case 2140:
            return OFM_BLK_DEPTH_M1;
        case 2144:
            return OFM_ZERO_POINT;
        case 2152:
            return OFM_WIDTH0_M1;
        case 2156:
            return OFM_HEIGHT0_M1;
        case 2160:
            return OFM_HEIGHT1_M1;
        case 2172:
            return OFM_REGION;
        case 2176:
            return KERNEL_WIDTH_M1;
        case 2180:
            return KERNEL_HEIGHT_M1;
        case 2184:
            return KERNEL_STRIDE;
        case 2188:
            return PARALLEL_MODE;
        case 2192:
            return ACC_FORMAT;
        case 2196:
            return ACTIVATION;
        case 2200:
            return ACTIVATION_MIN;
        case 2204:
            return ACTIVATION_MAX;
        case 2208:
            return WEIGHT_REGION;
        case 2212:
            return SCALE_REGION;
        case 2228:
            return AB_START;
        case 2236:
            return BLOCKDEP;
        case 2240:
            return DMA0_SRC_REGION;
        case 2244:
            return DMA0_DST_REGION;
        case 2248:
            return DMA0_SIZE0;
        case 2252:
            return DMA0_SIZE1;
        case 2304:
            return IFM2_BROADCAST;
        case 2308:
            return IFM2_SCALAR;
        case 2324:
            return IFM2_PRECISION;
        case 2340:
            return IFM2_ZERO_POINT;
        case 2344:
            return IFM2_WIDTH0_M1;
        case 2348:
            return IFM2_HEIGHT0_M1;
        case 2352:
            return IFM2_HEIGHT1_M1;
        case 2356:
            return IFM2_IB_START;
        case 2364:
            return IFM2_REGION;
        case 2560:
            return IFM_BASE0;
        case 2564:
            return IFM_BASE0_HI;
        case 2568:
            return IFM_BASE1;
        case 2572:
            return IFM_BASE1_HI;
        case 2576:
            return IFM_BASE2;
        case 2580:
            return IFM_BASE2_HI;
        case 2584:
            return IFM_BASE3;
        case 2588:
            return IFM_BASE3_HI;
        case 2592:
            return IFM_STRIDE_X;
        case 2596:
            return IFM_STRIDE_X_HI;
        case 2600:
            return IFM_STRIDE_Y;
        case 2604:
            return IFM_STRIDE_Y_HI;
        case 2608:
            return IFM_STRIDE_C;
        case 2612:
            return IFM_STRIDE_C_HI;
        case 2624:
            return OFM_BASE0;
        case 2628:
            return OFM_BASE0_HI;
        case 2632:
            return OFM_BASE1;
        case 2636:
            return OFM_BASE1_HI;
        case 2640:
            return OFM_BASE2;
        case 2644:
            return OFM_BASE2_HI;
        case 2648:
            return OFM_BASE3;
        case 2652:
            return OFM_BASE3_HI;
        case 2656:
            return OFM_STRIDE_X;
        case 2660:
            return OFM_STRIDE_X_HI;
        case 2664:
            return OFM_STRIDE_Y;
        case 2668:
            return OFM_STRIDE_Y_HI;
        case 2672:
            return OFM_STRIDE_C;
        case 2676:
            return OFM_STRIDE_C_HI;
        case 2688:
            return WEIGHT_BASE;
        case 2692:
            return WEIGHT_BASE_HI;
        case 2696:
            return WEIGHT_LENGTH;
        case 2700:
            return WEIGHT_LENGTH_HI;
        case 2704:
            return SCALE_BASE;
        case 2708:
            return SCALE_BASE_HI;
        case 2712:
            return SCALE_LENGTH;
        case 2720:
            return OFM_SCALE;
        case 2724:
            return OFM_SCALE_SHIFT;
        case 2728:
            return OPA_SCALE;
        case 2732:
            return OPA_SCALE_SHIFT;
        case 2736:
            return OPB_SCALE;
        case 2752:
            return DMA0_SRC;
        case 2756:
            return DMA0_SRC_HI;
        case 2760:
            return DMA0_DST;
        case 2764:
            return DMA0_DST_HI;
        case 2768:
            return DMA0_LEN;
        case 2772:
            return DMA0_LEN_HI;
        case 2776:
            return DMA0_SKIP0;
        case 2780:
            return DMA0_SKIP0_HI;
        case 2784:
            return DMA0_SKIP1;
        case 2788:
            return DMA0_SKIP1_HI;
        case 2816:
            return IFM2_BASE0;
        case 2820:
            return IFM2_BASE0_HI;
        case 2824:
            return IFM2_BASE1;
        case 2828:
            return IFM2_BASE1_HI;
        case 2832:
            return IFM2_BASE2;
        case 2836:
            return IFM2_BASE2_HI;
        case 2840:
            return IFM2_BASE3;
        case 2844:
            return IFM2_BASE3_HI;
        case 2848:
            return IFM2_STRIDE_X;
        case 2852:
            return IFM2_STRIDE_X_HI;
        case 2856:
            return IFM2_STRIDE_Y;
        case 2860:
            return IFM2_STRIDE_Y_HI;
        case 2864:
            return IFM2_STRIDE_C;
        case 2868:
            return IFM2_STRIDE_C_HI;
        case 2880:
            return WEIGHT1_BASE;
        case 2884:
            return WEIGHT1_BASE_HI;
        case 2888:
            return WEIGHT1_LENGTH;
        case 2892:
            return WEIGHT1_LENGTH_HI;
        case 2896:
            return SCALE1_BASE;
        case 2900:
            return SCALE1_BASE_HI;
        case 2904:
            return SCALE1_LENGTH;
        case 384:
            return PMCR;
        case 388:
            return PMCNTENSET;
        case 392:
            return PMCNTENCLR;
        case 396:
            return PMOVSSET;
        case 400:
            return PMOVSCLR;
        case 404:
            return PMINTSET;
        case 408:
            return PMINTCLR;
        case 416:
            return PMCCNTR_LO;
        case 420:
            return PMCCNTR_HI;
        case 424:
            return PMCCNTR_CFG;
        case 428:
            return PMCAXI_CHAN;
        case 768:
            return PMEVCNTR[0];
        case 772:
            return PMEVCNTR[1];
        case 776:
            return PMEVCNTR[2];
        case 780:
            return PMEVCNTR[3];
        case 896:
            return PMEVTYPER[0];
        case 900:
            return PMEVTYPER[1];
        case 904:
            return PMEVTYPER[2];
        case 908:
            return PMEVTYPER[3];
        case 1024:
            return SHARED_BUFFER[0];
        case 1028:
            return SHARED_BUFFER[1];
        case 1032:
            return SHARED_BUFFER[2];
        case 1036:
            return SHARED_BUFFER[3];
        case 1040:
            return SHARED_BUFFER[4];
        case 1044:
            return SHARED_BUFFER[5];
        case 1048:
            return SHARED_BUFFER[6];
        case 1052:
            return SHARED_BUFFER[7];
        case 1056:
            return SHARED_BUFFER[8];
        case 1060:
            return SHARED_BUFFER[9];
        case 1064:
            return SHARED_BUFFER[10];
        case 1068:
            return SHARED_BUFFER[11];
        case 1072:
            return SHARED_BUFFER[12];
        case 1076:
            return SHARED_BUFFER[13];
        case 1080:
            return SHARED_BUFFER[14];
        case 1084:
            return SHARED_BUFFER[15];
        case 1088:
            return SHARED_BUFFER[16];
        case 1092:
            return SHARED_BUFFER[17];
        case 1096:
            return SHARED_BUFFER[18];
        case 1100:
            return SHARED_BUFFER[19];
        case 1104:
            return SHARED_BUFFER[20];
        case 1108:
            return SHARED_BUFFER[21];
        case 1112:
            return SHARED_BUFFER[22];
        case 1116:
            return SHARED_BUFFER[23];
        case 1120:
            return SHARED_BUFFER[24];
        case 1124:
            return SHARED_BUFFER[25];
        case 1128:
            return SHARED_BUFFER[26];
        case 1132:
            return SHARED_BUFFER[27];
        case 1136:
            return SHARED_BUFFER[28];
        case 1140:
            return SHARED_BUFFER[29];
        case 1144:
            return SHARED_BUFFER[30];
        case 1148:
            return SHARED_BUFFER[31];
        case 1152:
            return SHARED_BUFFER[32];
        case 1156:
            return SHARED_BUFFER[33];
        case 1160:
            return SHARED_BUFFER[34];
        case 1164:
            return SHARED_BUFFER[35];
        case 1168:
            return SHARED_BUFFER[36];
        case 1172:
            return SHARED_BUFFER[37];
        case 1176:
            return SHARED_BUFFER[38];
        case 1180:
            return SHARED_BUFFER[39];
        case 1184:
            return SHARED_BUFFER[40];
        case 1188:
            return SHARED_BUFFER[41];
        case 1192:
            return SHARED_BUFFER[42];
        case 1196:
            return SHARED_BUFFER[43];
        case 1200:
            return SHARED_BUFFER[44];
        case 1204:
            return SHARED_BUFFER[45];
        case 1208:
            return SHARED_BUFFER[46];
        case 1212:
            return SHARED_BUFFER[47];
        case 1216:
            return SHARED_BUFFER[48];
        case 1220:
            return SHARED_BUFFER[49];
        case 1224:
            return SHARED_BUFFER[50];
        case 1228:
            return SHARED_BUFFER[51];
        case 1232:
            return SHARED_BUFFER[52];
        case 1236:
            return SHARED_BUFFER[53];
        case 1240:
            return SHARED_BUFFER[54];
        case 1244:
            return SHARED_BUFFER[55];
        case 1248:
            return SHARED_BUFFER[56];
        case 1252:
            return SHARED_BUFFER[57];
        case 1256:
            return SHARED_BUFFER[58];
        case 1260:
            return SHARED_BUFFER[59];
        case 1264:
            return SHARED_BUFFER[60];
        case 1268:
            return SHARED_BUFFER[61];
        case 1272:
            return SHARED_BUFFER[62];
        case 1276:
            return SHARED_BUFFER[63];
        case 1280:
            return SHARED_BUFFER[64];
        case 1284:
            return SHARED_BUFFER[65];
        case 1288:
            return SHARED_BUFFER[66];
        case 1292:
            return SHARED_BUFFER[67];
        case 1296:
            return SHARED_BUFFER[68];
        case 1300:
            return SHARED_BUFFER[69];
        case 1304:
            return SHARED_BUFFER[70];
        case 1308:
            return SHARED_BUFFER[71];
        case 1312:
            return SHARED_BUFFER[72];
        case 1316:
            return SHARED_BUFFER[73];
        case 1320:
            return SHARED_BUFFER[74];
        case 1324:
            return SHARED_BUFFER[75];
        case 1328:
            return SHARED_BUFFER[76];
        case 1332:
            return SHARED_BUFFER[77];
        case 1336:
            return SHARED_BUFFER[78];
        case 1340:
            return SHARED_BUFFER[79];
        case 1344:
            return SHARED_BUFFER[80];
        case 1348:
            return SHARED_BUFFER[81];
        case 1352:
            return SHARED_BUFFER[82];
        case 1356:
            return SHARED_BUFFER[83];
        case 1360:
            return SHARED_BUFFER[84];
        case 1364:
            return SHARED_BUFFER[85];
        case 1368:
            return SHARED_BUFFER[86];
        case 1372:
            return SHARED_BUFFER[87];
        case 1376:
            return SHARED_BUFFER[88];
        case 1380:
            return SHARED_BUFFER[89];
        case 1384:
            return SHARED_BUFFER[90];
        case 1388:
            return SHARED_BUFFER[91];
        case 1392:
            return SHARED_BUFFER[92];
        case 1396:
            return SHARED_BUFFER[93];
        case 1400:
            return SHARED_BUFFER[94];
        case 1404:
            return SHARED_BUFFER[95];
        case 1408:
            return SHARED_BUFFER[96];
        case 1412:
            return SHARED_BUFFER[97];
        case 1416:
            return SHARED_BUFFER[98];
        case 1420:
            return SHARED_BUFFER[99];
        case 1424:
            return SHARED_BUFFER[100];
        case 1428:
            return SHARED_BUFFER[101];
        case 1432:
            return SHARED_BUFFER[102];
        case 1436:
            return SHARED_BUFFER[103];
        case 1440:
            return SHARED_BUFFER[104];
        case 1444:
            return SHARED_BUFFER[105];
        case 1448:
            return SHARED_BUFFER[106];
        case 1452:
            return SHARED_BUFFER[107];
        case 1456:
            return SHARED_BUFFER[108];
        case 1460:
            return SHARED_BUFFER[109];
        case 1464:
            return SHARED_BUFFER[110];
        case 1468:
            return SHARED_BUFFER[111];
        case 1472:
            return SHARED_BUFFER[112];
        case 1476:
            return SHARED_BUFFER[113];
        case 1480:
            return SHARED_BUFFER[114];
        case 1484:
            return SHARED_BUFFER[115];
        case 1488:
            return SHARED_BUFFER[116];
        case 1492:
            return SHARED_BUFFER[117];
        case 1496:
            return SHARED_BUFFER[118];
        case 1500:
            return SHARED_BUFFER[119];
        case 1504:
            return SHARED_BUFFER[120];
        case 1508:
            return SHARED_BUFFER[121];
        case 1512:
            return SHARED_BUFFER[122];
        case 1516:
            return SHARED_BUFFER[123];
        case 1520:
            return SHARED_BUFFER[124];
        case 1524:
            return SHARED_BUFFER[125];
        case 1528:
            return SHARED_BUFFER[126];
        case 1532:
            return SHARED_BUFFER[127];
        case 1536:
            return SHARED_BUFFER[128];
        case 1540:
            return SHARED_BUFFER[129];
        case 1544:
            return SHARED_BUFFER[130];
        case 1548:
            return SHARED_BUFFER[131];
        case 1552:
            return SHARED_BUFFER[132];
        case 1556:
            return SHARED_BUFFER[133];
        case 1560:
            return SHARED_BUFFER[134];
        case 1564:
            return SHARED_BUFFER[135];
        case 1568:
            return SHARED_BUFFER[136];
        case 1572:
            return SHARED_BUFFER[137];
        case 1576:
            return SHARED_BUFFER[138];
        case 1580:
            return SHARED_BUFFER[139];
        case 1584:
            return SHARED_BUFFER[140];
        case 1588:
            return SHARED_BUFFER[141];
        case 1592:
            return SHARED_BUFFER[142];
        case 1596:
            return SHARED_BUFFER[143];
        case 1600:
            return SHARED_BUFFER[144];
        case 1604:
            return SHARED_BUFFER[145];
        case 1608:
            return SHARED_BUFFER[146];
        case 1612:
            return SHARED_BUFFER[147];
        case 1616:
            return SHARED_BUFFER[148];
        case 1620:
            return SHARED_BUFFER[149];
        case 1624:
            return SHARED_BUFFER[150];
        case 1628:
            return SHARED_BUFFER[151];
        case 1632:
            return SHARED_BUFFER[152];
        case 1636:
            return SHARED_BUFFER[153];
        case 1640:
            return SHARED_BUFFER[154];
        case 1644:
            return SHARED_BUFFER[155];
        case 1648:
            return SHARED_BUFFER[156];
        case 1652:
            return SHARED_BUFFER[157];
        case 1656:
            return SHARED_BUFFER[158];
        case 1660:
            return SHARED_BUFFER[159];
        case 1664:
            return SHARED_BUFFER[160];
        case 1668:
            return SHARED_BUFFER[161];
        case 1672:
            return SHARED_BUFFER[162];
        case 1676:
            return SHARED_BUFFER[163];
        case 1680:
            return SHARED_BUFFER[164];
        case 1684:
            return SHARED_BUFFER[165];
        case 1688:
            return SHARED_BUFFER[166];
        case 1692:
            return SHARED_BUFFER[167];
        case 1696:
            return SHARED_BUFFER[168];
        case 1700:
            return SHARED_BUFFER[169];
        case 1704:
            return SHARED_BUFFER[170];
        case 1708:
            return SHARED_BUFFER[171];
        case 1712:
            return SHARED_BUFFER[172];
        case 1716:
            return SHARED_BUFFER[173];
        case 1720:
            return SHARED_BUFFER[174];
        case 1724:
            return SHARED_BUFFER[175];
        case 1728:
            return SHARED_BUFFER[176];
        case 1732:
            return SHARED_BUFFER[177];
        case 1736:
            return SHARED_BUFFER[178];
        case 1740:
            return SHARED_BUFFER[179];
        case 1744:
            return SHARED_BUFFER[180];
        case 1748:
            return SHARED_BUFFER[181];
        case 1752:
            return SHARED_BUFFER[182];
        case 1756:
            return SHARED_BUFFER[183];
        case 1760:
            return SHARED_BUFFER[184];
        case 1764:
            return SHARED_BUFFER[185];
        case 1768:
            return SHARED_BUFFER[186];
        case 1772:
            return SHARED_BUFFER[187];
        case 1776:
            return SHARED_BUFFER[188];
        case 1780:
            return SHARED_BUFFER[189];
        case 1784:
            return SHARED_BUFFER[190];
        case 1788:
            return SHARED_BUFFER[191];
        case 1792:
            return SHARED_BUFFER[192];
        case 1796:
            return SHARED_BUFFER[193];
        case 1800:
            return SHARED_BUFFER[194];
        case 1804:
            return SHARED_BUFFER[195];
        case 1808:
            return SHARED_BUFFER[196];
        case 1812:
            return SHARED_BUFFER[197];
        case 1816:
            return SHARED_BUFFER[198];
        case 1820:
            return SHARED_BUFFER[199];
        case 1824:
            return SHARED_BUFFER[200];
        case 1828:
            return SHARED_BUFFER[201];
        case 1832:
            return SHARED_BUFFER[202];
        case 1836:
            return SHARED_BUFFER[203];
        case 1840:
            return SHARED_BUFFER[204];
        case 1844:
            return SHARED_BUFFER[205];
        case 1848:
            return SHARED_BUFFER[206];
        case 1852:
            return SHARED_BUFFER[207];
        case 1856:
            return SHARED_BUFFER[208];
        case 1860:
            return SHARED_BUFFER[209];
        case 1864:
            return SHARED_BUFFER[210];
        case 1868:
            return SHARED_BUFFER[211];
        case 1872:
            return SHARED_BUFFER[212];
        case 1876:
            return SHARED_BUFFER[213];
        case 1880:
            return SHARED_BUFFER[214];
        case 1884:
            return SHARED_BUFFER[215];
        case 1888:
            return SHARED_BUFFER[216];
        case 1892:
            return SHARED_BUFFER[217];
        case 1896:
            return SHARED_BUFFER[218];
        case 1900:
            return SHARED_BUFFER[219];
        case 1904:
            return SHARED_BUFFER[220];
        case 1908:
            return SHARED_BUFFER[221];
        case 1912:
            return SHARED_BUFFER[222];
        case 1916:
            return SHARED_BUFFER[223];
        case 1920:
            return SHARED_BUFFER[224];
        case 1924:
            return SHARED_BUFFER[225];
        case 1928:
            return SHARED_BUFFER[226];
        case 1932:
            return SHARED_BUFFER[227];
        case 1936:
            return SHARED_BUFFER[228];
        case 1940:
            return SHARED_BUFFER[229];
        case 1944:
            return SHARED_BUFFER[230];
        case 1948:
            return SHARED_BUFFER[231];
        case 1952:
            return SHARED_BUFFER[232];
        case 1956:
            return SHARED_BUFFER[233];
        case 1960:
            return SHARED_BUFFER[234];
        case 1964:
            return SHARED_BUFFER[235];
        case 1968:
            return SHARED_BUFFER[236];
        case 1972:
            return SHARED_BUFFER[237];
        case 1976:
            return SHARED_BUFFER[238];
        case 1980:
            return SHARED_BUFFER[239];
        case 1984:
            return SHARED_BUFFER[240];
        case 1988:
            return SHARED_BUFFER[241];
        case 1992:
            return SHARED_BUFFER[242];
        case 1996:
            return SHARED_BUFFER[243];
        case 2000:
            return SHARED_BUFFER[244];
        case 2004:
            return SHARED_BUFFER[245];
        case 2008:
            return SHARED_BUFFER[246];
        case 2012:
            return SHARED_BUFFER[247];
        case 2016:
            return SHARED_BUFFER[248];
        case 2020:
            return SHARED_BUFFER[249];
        case 2024:
            return SHARED_BUFFER[250];
        case 2028:
            return SHARED_BUFFER[251];
        case 2032:
            return SHARED_BUFFER[252];
        case 2036:
            return SHARED_BUFFER[253];
        case 2040:
            return SHARED_BUFFER[254];
        case 2044:
            return SHARED_BUFFER[255];
        default:
            throw std::runtime_error("invalid register address");
        }
    }
    void set(size_t offset, uint32_t value)
    {
        switch (offset)
        {
        case 0:
            ID = value;
            return;
        case 4:
            STATUS = value;
            return;
        case 8:
            CMD = value;
            return;
        case 12:
            RESET = value;
            return;
        case 16:
            QBASE0 = value;
            return;
        case 20:
            QBASE1 = value;
            return;
        case 24:
            QREAD = value;
            return;
        case 28:
            QCONFIG = value;
            return;
        case 32:
            QSIZE = value;
            return;
        case 36:
            PROT = value;
            return;
        case 40:
            CONFIG = value;
            return;
        case 44:
            LOCK = value;
            return;
        case 60:
            REGIONCFG = value;
            return;
        case 64:
            AXI_LIMIT0 = value;
            return;
        case 68:
            AXI_LIMIT1 = value;
            return;
        case 72:
            AXI_LIMIT2 = value;
            return;
        case 76:
            AXI_LIMIT3 = value;
            return;
        case 128:
            BASEP0 = value;
            return;
        case 132:
            BASEP1 = value;
            return;
        case 136:
            BASEP2 = value;
            return;
        case 140:
            BASEP3 = value;
            return;
        case 144:
            BASEP4 = value;
            return;
        case 148:
            BASEP5 = value;
            return;
        case 152:
            BASEP6 = value;
            return;
        case 156:
            BASEP7 = value;
            return;
        case 160:
            BASEP8 = value;
            return;
        case 164:
            BASEP9 = value;
            return;
        case 168:
            BASEP10 = value;
            return;
        case 172:
            BASEP11 = value;
            return;
        case 176:
            BASEP12 = value;
            return;
        case 180:
            BASEP13 = value;
            return;
        case 184:
            BASEP14 = value;
            return;
        case 188:
            BASEP15 = value;
            return;
        case 4032:
            REVISION = value;
            return;
        case 4048:
            PID4 = value;
            return;
        case 4052:
            PID5 = value;
            return;
        case 4056:
            PID6 = value;
            return;
        case 4060:
            PID7 = value;
            return;
        case 4064:
            PID0 = value;
            return;
        case 4068:
            PID1 = value;
            return;
        case 4072:
            PID2 = value;
            return;
        case 4076:
            PID3 = value;
            return;
        case 4080:
            CID0 = value;
            return;
        case 4084:
            CID1 = value;
            return;
        case 4088:
            CID2 = value;
            return;
        case 4092:
            CID3 = value;
            return;
        case 320:
            CLKFORCE = value;
            return;
        case 324:
            DEBUG = value;
            return;
        case 328:
            DEBUG2 = value;
            return;
        case 332:
            DEBUGCORE = value;
            return;
        case 512:
            KERNEL_X = value;
            return;
        case 516:
            KERNEL_Y = value;
            return;
        case 520:
            KERNEL_W_M1 = value;
            return;
        case 524:
            KERNEL_H_M1 = value;
            return;
        case 528:
            OFM_CBLK_WIDTH_M1 = value;
            return;
        case 532:
            OFM_CBLK_HEIGHT_M1 = value;
            return;
        case 536:
            OFM_CBLK_DEPTH_M1 = value;
            return;
        case 540:
            IFM_CBLK_DEPTH_M1 = value;
            return;
        case 544:
            OFM_X = value;
            return;
        case 548:
            OFM_Y = value;
            return;
        case 552:
            OFM_Z = value;
            return;
        case 556:
            IFM_Z = value;
            return;
        case 560:
            PAD_TOP = value;
            return;
        case 564:
            PAD_LEFT = value;
            return;
        case 568:
            IFM_CBLK_WIDTH = value;
            return;
        case 572:
            IFM_CBLK_HEIGHT = value;
            return;
        case 576:
            DMA_IFM_SRC = value;
            return;
        case 580:
            DMA_IFM_SRC_HI = value;
            return;
        case 584:
            DMA_IFM_DST = value;
            return;
        case 588:
            DMA_OFM_SRC = value;
            return;
        case 592:
            DMA_OFM_DST = value;
            return;
        case 596:
            DMA_OFM_DST_HI = value;
            return;
        case 600:
            DMA_WEIGHT_SRC = value;
            return;
        case 604:
            DMA_WEIGHT_SRC_HI = value;
            return;
        case 608:
            DMA_CMD_SRC = value;
            return;
        case 612:
            DMA_CMD_SRC_HI = value;
            return;
        case 616:
            DMA_CMD_SIZE = value;
            return;
        case 620:
            DMA_M2M_SRC = value;
            return;
        case 624:
            DMA_M2M_SRC_HI = value;
            return;
        case 628:
            DMA_M2M_DST = value;
            return;
        case 632:
            DMA_M2M_DST_HI = value;
            return;
        case 636:
            CURRENT_QREAD = value;
            return;
        case 640:
            DMA_SCALE_SRC = value;
            return;
        case 644:
            DMA_SCALE_SRC_HI = value;
            return;
        case 700:
            CURRENT_CMD = value;
            return;
        case 2048:
            IFM_PAD_TOP = value;
            return;
        case 2052:
            IFM_PAD_LEFT = value;
            return;
        case 2056:
            IFM_PAD_RIGHT = value;
            return;
        case 2060:
            IFM_PAD_BOTTOM = value;
            return;
        case 2064:
            IFM_DEPTH_M1 = value;
            return;
        case 2068:
            IFM_PRECISION = value;
            return;
        case 2076:
            IFM_UPSCALE = value;
            return;
        case 2084:
            IFM_ZERO_POINT = value;
            return;
        case 2088:
            IFM_WIDTH0_M1 = value;
            return;
        case 2092:
            IFM_HEIGHT0_M1 = value;
            return;
        case 2096:
            IFM_HEIGHT1_M1 = value;
            return;
        case 2100:
            IFM_IB_END = value;
            return;
        case 2108:
            IFM_REGION = value;
            return;
        case 2116:
            OFM_WIDTH_M1 = value;
            return;
        case 2120:
            OFM_HEIGHT_M1 = value;
            return;
        case 2124:
            OFM_DEPTH_M1 = value;
            return;
        case 2128:
            OFM_PRECISION = value;
            return;
        case 2132:
            OFM_BLK_WIDTH_M1 = value;
            return;
        case 2136:
            OFM_BLK_HEIGHT_M1 = value;
            return;
        case 2140:
            OFM_BLK_DEPTH_M1 = value;
            return;
        case 2144:
            OFM_ZERO_POINT = value;
            return;
        case 2152:
            OFM_WIDTH0_M1 = value;
            return;
        case 2156:
            OFM_HEIGHT0_M1 = value;
            return;
        case 2160:
            OFM_HEIGHT1_M1 = value;
            return;
        case 2172:
            OFM_REGION = value;
            return;
        case 2176:
            KERNEL_WIDTH_M1 = value;
            return;
        case 2180:
            KERNEL_HEIGHT_M1 = value;
            return;
        case 2184:
            KERNEL_STRIDE = value;
            return;
        case 2188:
            PARALLEL_MODE = value;
            return;
        case 2192:
            ACC_FORMAT = value;
            return;
        case 2196:
            ACTIVATION = value;
            return;
        case 2200:
            ACTIVATION_MIN = value;
            return;
        case 2204:
            ACTIVATION_MAX = value;
            return;
        case 2208:
            WEIGHT_REGION = value;
            return;
        case 2212:
            SCALE_REGION = value;
            return;
        case 2228:
            AB_START = value;
            return;
        case 2236:
            BLOCKDEP = value;
            return;
        case 2240:
            DMA0_SRC_REGION = value;
            return;
        case 2244:
            DMA0_DST_REGION = value;
            return;
        case 2248:
            DMA0_SIZE0 = value;
            return;
        case 2252:
            DMA0_SIZE1 = value;
            return;
        case 2304:
            IFM2_BROADCAST = value;
            return;
        case 2308:
            IFM2_SCALAR = value;
            return;
        case 2324:
            IFM2_PRECISION = value;
            return;
        case 2340:
            IFM2_ZERO_POINT = value;
            return;
        case 2344:
            IFM2_WIDTH0_M1 = value;
            return;
        case 2348:
            IFM2_HEIGHT0_M1 = value;
            return;
        case 2352:
            IFM2_HEIGHT1_M1 = value;
            return;
        case 2356:
            IFM2_IB_START = value;
            return;
        case 2364:
            IFM2_REGION = value;
            return;
        case 2560:
            IFM_BASE0 = value;
            return;
        case 2564:
            IFM_BASE0_HI = value;
            return;
        case 2568:
            IFM_BASE1 = value;
            return;
        case 2572:
            IFM_BASE1_HI = value;
            return;
        case 2576:
            IFM_BASE2 = value;
            return;
        case 2580:
            IFM_BASE2_HI = value;
            return;
        case 2584:
            IFM_BASE3 = value;
            return;
        case 2588:
            IFM_BASE3_HI = value;
            return;
        case 2592:
            IFM_STRIDE_X = value;
            return;
        case 2596:
            IFM_STRIDE_X_HI = value;
            return;
        case 2600:
            IFM_STRIDE_Y = value;
            return;
        case 2604:
            IFM_STRIDE_Y_HI = value;
            return;
        case 2608:
            IFM_STRIDE_C = value;
            return;
        case 2612:
            IFM_STRIDE_C_HI = value;
            return;
        case 2624:
            OFM_BASE0 = value;
            return;
        case 2628:
            OFM_BASE0_HI = value;
            return;
        case 2632:
            OFM_BASE1 = value;
            return;
        case 2636:
            OFM_BASE1_HI = value;
            return;
        case 2640:
            OFM_BASE2 = value;
            return;
        case 2644:
            OFM_BASE2_HI = value;
            return;
        case 2648:
            OFM_BASE3 = value;
            return;
        case 2652:
            OFM_BASE3_HI = value;
            return;
        case 2656:
            OFM_STRIDE_X = value;
            return;
        case 2660:
            OFM_STRIDE_X_HI = value;
            return;
        case 2664:
            OFM_STRIDE_Y = value;
            return;
        case 2668:
            OFM_STRIDE_Y_HI = value;
            return;
        case 2672:
            OFM_STRIDE_C = value;
            return;
        case 2676:
            OFM_STRIDE_C_HI = value;
            return;
        case 2688:
            WEIGHT_BASE = value;
            return;
        case 2692:
            WEIGHT_BASE_HI = value;
            return;
        case 2696:
            WEIGHT_LENGTH = value;
            return;
        case 2700:
            WEIGHT_LENGTH_HI = value;
            return;
        case 2704:
            SCALE_BASE = value;
            return;
        case 2708:
            SCALE_BASE_HI = value;
            return;
        case 2712:
            SCALE_LENGTH = value;
            return;
        case 2720:
            OFM_SCALE = value;
            return;
        case 2724:
            OFM_SCALE_SHIFT = value;
            return;
        case 2728:
            OPA_SCALE = value;
            return;
        case 2732:
            OPA_SCALE_SHIFT = value;
            return;
        case 2736:
            OPB_SCALE = value;
            return;
        case 2752:
            DMA0_SRC = value;
            return;
        case 2756:
            DMA0_SRC_HI = value;
            return;
        case 2760:
            DMA0_DST = value;
            return;
        case 2764:
            DMA0_DST_HI = value;
            return;
        case 2768:
            DMA0_LEN = value;
            return;
        case 2772:
            DMA0_LEN_HI = value;
            return;
        case 2776:
            DMA0_SKIP0 = value;
            return;
        case 2780:
            DMA0_SKIP0_HI = value;
            return;
        case 2784:
            DMA0_SKIP1 = value;
            return;
        case 2788:
            DMA0_SKIP1_HI = value;
            return;
        case 2816:
            IFM2_BASE0 = value;
            return;
        case 2820:
            IFM2_BASE0_HI = value;
            return;
        case 2824:
            IFM2_BASE1 = value;
            return;
        case 2828:
            IFM2_BASE1_HI = value;
            return;
        case 2832:
            IFM2_BASE2 = value;
            return;
        case 2836:
            IFM2_BASE2_HI = value;
            return;
        case 2840:
            IFM2_BASE3 = value;
            return;
        case 2844:
            IFM2_BASE3_HI = value;
            return;
        case 2848:
            IFM2_STRIDE_X = value;
            return;
        case 2852:
            IFM2_STRIDE_X_HI = value;
            return;
        case 2856:
            IFM2_STRIDE_Y = value;
            return;
        case 2860:
            IFM2_STRIDE_Y_HI = value;
            return;
        case 2864:
            IFM2_STRIDE_C = value;
            return;
        case 2868:
            IFM2_STRIDE_C_HI = value;
            return;
        case 2880:
            WEIGHT1_BASE = value;
            return;
        case 2884:
            WEIGHT1_BASE_HI = value;
            return;
        case 2888:
            WEIGHT1_LENGTH = value;
            return;
        case 2892:
            WEIGHT1_LENGTH_HI = value;
            return;
        case 2896:
            SCALE1_BASE = value;
            return;
        case 2900:
            SCALE1_BASE_HI = value;
            return;
        case 2904:
            SCALE1_LENGTH = value;
            return;
        case 384:
            PMCR = value;
            return;
        case 388:
            PMCNTENSET = value;
            return;
        case 392:
            PMCNTENCLR = value;
            return;
        case 396:
            PMOVSSET = value;
            return;
        case 400:
            PMOVSCLR = value;
            return;
        case 404:
            PMINTSET = value;
            return;
        case 408:
            PMINTCLR = value;
            return;
        case 416:
            PMCCNTR_LO = value;
            return;
        case 420:
            PMCCNTR_HI = value;
            return;
        case 424:
            PMCCNTR_CFG = value;
            return;
        case 428:
            PMCAXI_CHAN = value;
            return;
        case 768:
            PMEVCNTR[0] = value;
            return;
        case 772:
            PMEVCNTR[1] = value;
            return;
        case 776:
            PMEVCNTR[2] = value;
            return;
        case 780:
            PMEVCNTR[3] = value;
            return;
        case 896:
            PMEVTYPER[0] = value;
            return;
        case 900:
            PMEVTYPER[1] = value;
            return;
        case 904:
            PMEVTYPER[2] = value;
            return;
        case 908:
            PMEVTYPER[3] = value;
            return;
        case 1024:
            SHARED_BUFFER[0] = value;
            return;
        case 1028:
            SHARED_BUFFER[1] = value;
            return;
        case 1032:
            SHARED_BUFFER[2] = value;
            return;
        case 1036:
            SHARED_BUFFER[3] = value;
            return;
        case 1040:
            SHARED_BUFFER[4] = value;
            return;
        case 1044:
            SHARED_BUFFER[5] = value;
            return;
        case 1048:
            SHARED_BUFFER[6] = value;
            return;
        case 1052:
            SHARED_BUFFER[7] = value;
            return;
        case 1056:
            SHARED_BUFFER[8] = value;
            return;
        case 1060:
            SHARED_BUFFER[9] = value;
            return;
        case 1064:
            SHARED_BUFFER[10] = value;
            return;
        case 1068:
            SHARED_BUFFER[11] = value;
            return;
        case 1072:
            SHARED_BUFFER[12] = value;
            return;
        case 1076:
            SHARED_BUFFER[13] = value;
            return;
        case 1080:
            SHARED_BUFFER[14] = value;
            return;
        case 1084:
            SHARED_BUFFER[15] = value;
            return;
        case 1088:
            SHARED_BUFFER[16] = value;
            return;
        case 1092:
            SHARED_BUFFER[17] = value;
            return;
        case 1096:
            SHARED_BUFFER[18] = value;
            return;
        case 1100:
            SHARED_BUFFER[19] = value;
            return;
        case 1104:
            SHARED_BUFFER[20] = value;
            return;
        case 1108:
            SHARED_BUFFER[21] = value;
            return;
        case 1112:
            SHARED_BUFFER[22] = value;
            return;
        case 1116:
            SHARED_BUFFER[23] = value;
            return;
        case 1120:
            SHARED_BUFFER[24] = value;
            return;
        case 1124:
            SHARED_BUFFER[25] = value;
            return;
        case 1128:
            SHARED_BUFFER[26] = value;
            return;
        case 1132:
            SHARED_BUFFER[27] = value;
            return;
        case 1136:
            SHARED_BUFFER[28] = value;
            return;
        case 1140:
            SHARED_BUFFER[29] = value;
            return;
        case 1144:
            SHARED_BUFFER[30] = value;
            return;
        case 1148:
            SHARED_BUFFER[31] = value;
            return;
        case 1152:
            SHARED_BUFFER[32] = value;
            return;
        case 1156:
            SHARED_BUFFER[33] = value;
            return;
        case 1160:
            SHARED_BUFFER[34] = value;
            return;
        case 1164:
            SHARED_BUFFER[35] = value;
            return;
        case 1168:
            SHARED_BUFFER[36] = value;
            return;
        case 1172:
            SHARED_BUFFER[37] = value;
            return;
        case 1176:
            SHARED_BUFFER[38] = value;
            return;
        case 1180:
            SHARED_BUFFER[39] = value;
            return;
        case 1184:
            SHARED_BUFFER[40] = value;
            return;
        case 1188:
            SHARED_BUFFER[41] = value;
            return;
        case 1192:
            SHARED_BUFFER[42] = value;
            return;
        case 1196:
            SHARED_BUFFER[43] = value;
            return;
        case 1200:
            SHARED_BUFFER[44] = value;
            return;
        case 1204:
            SHARED_BUFFER[45] = value;
            return;
        case 1208:
            SHARED_BUFFER[46] = value;
            return;
        case 1212:
            SHARED_BUFFER[47] = value;
            return;
        case 1216:
            SHARED_BUFFER[48] = value;
            return;
        case 1220:
            SHARED_BUFFER[49] = value;
            return;
        case 1224:
            SHARED_BUFFER[50] = value;
            return;
        case 1228:
            SHARED_BUFFER[51] = value;
            return;
        case 1232:
            SHARED_BUFFER[52] = value;
            return;
        case 1236:
            SHARED_BUFFER[53] = value;
            return;
        case 1240:
            SHARED_BUFFER[54] = value;
            return;
        case 1244:
            SHARED_BUFFER[55] = value;
            return;
        case 1248:
            SHARED_BUFFER[56] = value;
            return;
        case 1252:
            SHARED_BUFFER[57] = value;
            return;
        case 1256:
            SHARED_BUFFER[58] = value;
            return;
        case 1260:
            SHARED_BUFFER[59] = value;
            return;
        case 1264:
            SHARED_BUFFER[60] = value;
            return;
        case 1268:
            SHARED_BUFFER[61] = value;
            return;
        case 1272:
            SHARED_BUFFER[62] = value;
            return;
        case 1276:
            SHARED_BUFFER[63] = value;
            return;
        case 1280:
            SHARED_BUFFER[64] = value;
            return;
        case 1284:
            SHARED_BUFFER[65] = value;
            return;
        case 1288:
            SHARED_BUFFER[66] = value;
            return;
        case 1292:
            SHARED_BUFFER[67] = value;
            return;
        case 1296:
            SHARED_BUFFER[68] = value;
            return;
        case 1300:
            SHARED_BUFFER[69] = value;
            return;
        case 1304:
            SHARED_BUFFER[70] = value;
            return;
        case 1308:
            SHARED_BUFFER[71] = value;
            return;
        case 1312:
            SHARED_BUFFER[72] = value;
            return;
        case 1316:
            SHARED_BUFFER[73] = value;
            return;
        case 1320:
            SHARED_BUFFER[74] = value;
            return;
        case 1324:
            SHARED_BUFFER[75] = value;
            return;
        case 1328:
            SHARED_BUFFER[76] = value;
            return;
        case 1332:
            SHARED_BUFFER[77] = value;
            return;
        case 1336:
            SHARED_BUFFER[78] = value;
            return;
        case 1340:
            SHARED_BUFFER[79] = value;
            return;
        case 1344:
            SHARED_BUFFER[80] = value;
            return;
        case 1348:
            SHARED_BUFFER[81] = value;
            return;
        case 1352:
            SHARED_BUFFER[82] = value;
            return;
        case 1356:
            SHARED_BUFFER[83] = value;
            return;
        case 1360:
            SHARED_BUFFER[84] = value;
            return;
        case 1364:
            SHARED_BUFFER[85] = value;
            return;
        case 1368:
            SHARED_BUFFER[86] = value;
            return;
        case 1372:
            SHARED_BUFFER[87] = value;
            return;
        case 1376:
            SHARED_BUFFER[88] = value;
            return;
        case 1380:
            SHARED_BUFFER[89] = value;
            return;
        case 1384:
            SHARED_BUFFER[90] = value;
            return;
        case 1388:
            SHARED_BUFFER[91] = value;
            return;
        case 1392:
            SHARED_BUFFER[92] = value;
            return;
        case 1396:
            SHARED_BUFFER[93] = value;
            return;
        case 1400:
            SHARED_BUFFER[94] = value;
            return;
        case 1404:
            SHARED_BUFFER[95] = value;
            return;
        case 1408:
            SHARED_BUFFER[96] = value;
            return;
        case 1412:
            SHARED_BUFFER[97] = value;
            return;
        case 1416:
            SHARED_BUFFER[98] = value;
            return;
        case 1420:
            SHARED_BUFFER[99] = value;
            return;
        case 1424:
            SHARED_BUFFER[100] = value;
            return;
        case 1428:
            SHARED_BUFFER[101] = value;
            return;
        case 1432:
            SHARED_BUFFER[102] = value;
            return;
        case 1436:
            SHARED_BUFFER[103] = value;
            return;
        case 1440:
            SHARED_BUFFER[104] = value;
            return;
        case 1444:
            SHARED_BUFFER[105] = value;
            return;
        case 1448:
            SHARED_BUFFER[106] = value;
            return;
        case 1452:
            SHARED_BUFFER[107] = value;
            return;
        case 1456:
            SHARED_BUFFER[108] = value;
            return;
        case 1460:
            SHARED_BUFFER[109] = value;
            return;
        case 1464:
            SHARED_BUFFER[110] = value;
            return;
        case 1468:
            SHARED_BUFFER[111] = value;
            return;
        case 1472:
            SHARED_BUFFER[112] = value;
            return;
        case 1476:
            SHARED_BUFFER[113] = value;
            return;
        case 1480:
            SHARED_BUFFER[114] = value;
            return;
        case 1484:
            SHARED_BUFFER[115] = value;
            return;
        case 1488:
            SHARED_BUFFER[116] = value;
            return;
        case 1492:
            SHARED_BUFFER[117] = value;
            return;
        case 1496:
            SHARED_BUFFER[118] = value;
            return;
        case 1500:
            SHARED_BUFFER[119] = value;
            return;
        case 1504:
            SHARED_BUFFER[120] = value;
            return;
        case 1508:
            SHARED_BUFFER[121] = value;
            return;
        case 1512:
            SHARED_BUFFER[122] = value;
            return;
        case 1516:
            SHARED_BUFFER[123] = value;
            return;
        case 1520:
            SHARED_BUFFER[124] = value;
            return;
        case 1524:
            SHARED_BUFFER[125] = value;
            return;
        case 1528:
            SHARED_BUFFER[126] = value;
            return;
        case 1532:
            SHARED_BUFFER[127] = value;
            return;
        case 1536:
            SHARED_BUFFER[128] = value;
            return;
        case 1540:
            SHARED_BUFFER[129] = value;
            return;
        case 1544:
            SHARED_BUFFER[130] = value;
            return;
        case 1548:
            SHARED_BUFFER[131] = value;
            return;
        case 1552:
            SHARED_BUFFER[132] = value;
            return;
        case 1556:
            SHARED_BUFFER[133] = value;
            return;
        case 1560:
            SHARED_BUFFER[134] = value;
            return;
        case 1564:
            SHARED_BUFFER[135] = value;
            return;
        case 1568:
            SHARED_BUFFER[136] = value;
            return;
        case 1572:
            SHARED_BUFFER[137] = value;
            return;
        case 1576:
            SHARED_BUFFER[138] = value;
            return;
        case 1580:
            SHARED_BUFFER[139] = value;
            return;
        case 1584:
            SHARED_BUFFER[140] = value;
            return;
        case 1588:
            SHARED_BUFFER[141] = value;
            return;
        case 1592:
            SHARED_BUFFER[142] = value;
            return;
        case 1596:
            SHARED_BUFFER[143] = value;
            return;
        case 1600:
            SHARED_BUFFER[144] = value;
            return;
        case 1604:
            SHARED_BUFFER[145] = value;
            return;
        case 1608:
            SHARED_BUFFER[146] = value;
            return;
        case 1612:
            SHARED_BUFFER[147] = value;
            return;
        case 1616:
            SHARED_BUFFER[148] = value;
            return;
        case 1620:
            SHARED_BUFFER[149] = value;
            return;
        case 1624:
            SHARED_BUFFER[150] = value;
            return;
        case 1628:
            SHARED_BUFFER[151] = value;
            return;
        case 1632:
            SHARED_BUFFER[152] = value;
            return;
        case 1636:
            SHARED_BUFFER[153] = value;
            return;
        case 1640:
            SHARED_BUFFER[154] = value;
            return;
        case 1644:
            SHARED_BUFFER[155] = value;
            return;
        case 1648:
            SHARED_BUFFER[156] = value;
            return;
        case 1652:
            SHARED_BUFFER[157] = value;
            return;
        case 1656:
            SHARED_BUFFER[158] = value;
            return;
        case 1660:
            SHARED_BUFFER[159] = value;
            return;
        case 1664:
            SHARED_BUFFER[160] = value;
            return;
        case 1668:
            SHARED_BUFFER[161] = value;
            return;
        case 1672:
            SHARED_BUFFER[162] = value;
            return;
        case 1676:
            SHARED_BUFFER[163] = value;
            return;
        case 1680:
            SHARED_BUFFER[164] = value;
            return;
        case 1684:
            SHARED_BUFFER[165] = value;
            return;
        case 1688:
            SHARED_BUFFER[166] = value;
            return;
        case 1692:
            SHARED_BUFFER[167] = value;
            return;
        case 1696:
            SHARED_BUFFER[168] = value;
            return;
        case 1700:
            SHARED_BUFFER[169] = value;
            return;
        case 1704:
            SHARED_BUFFER[170] = value;
            return;
        case 1708:
            SHARED_BUFFER[171] = value;
            return;
        case 1712:
            SHARED_BUFFER[172] = value;
            return;
        case 1716:
            SHARED_BUFFER[173] = value;
            return;
        case 1720:
            SHARED_BUFFER[174] = value;
            return;
        case 1724:
            SHARED_BUFFER[175] = value;
            return;
        case 1728:
            SHARED_BUFFER[176] = value;
            return;
        case 1732:
            SHARED_BUFFER[177] = value;
            return;
        case 1736:
            SHARED_BUFFER[178] = value;
            return;
        case 1740:
            SHARED_BUFFER[179] = value;
            return;
        case 1744:
            SHARED_BUFFER[180] = value;
            return;
        case 1748:
            SHARED_BUFFER[181] = value;
            return;
        case 1752:
            SHARED_BUFFER[182] = value;
            return;
        case 1756:
            SHARED_BUFFER[183] = value;
            return;
        case 1760:
            SHARED_BUFFER[184] = value;
            return;
        case 1764:
            SHARED_BUFFER[185] = value;
            return;
        case 1768:
            SHARED_BUFFER[186] = value;
            return;
        case 1772:
            SHARED_BUFFER[187] = value;
            return;
        case 1776:
            SHARED_BUFFER[188] = value;
            return;
        case 1780:
            SHARED_BUFFER[189] = value;
            return;
        case 1784:
            SHARED_BUFFER[190] = value;
            return;
        case 1788:
            SHARED_BUFFER[191] = value;
            return;
        case 1792:
            SHARED_BUFFER[192] = value;
            return;
        case 1796:
            SHARED_BUFFER[193] = value;
            return;
        case 1800:
            SHARED_BUFFER[194] = value;
            return;
        case 1804:
            SHARED_BUFFER[195] = value;
            return;
        case 1808:
            SHARED_BUFFER[196] = value;
            return;
        case 1812:
            SHARED_BUFFER[197] = value;
            return;
        case 1816:
            SHARED_BUFFER[198] = value;
            return;
        case 1820:
            SHARED_BUFFER[199] = value;
            return;
        case 1824:
            SHARED_BUFFER[200] = value;
            return;
        case 1828:
            SHARED_BUFFER[201] = value;
            return;
        case 1832:
            SHARED_BUFFER[202] = value;
            return;
        case 1836:
            SHARED_BUFFER[203] = value;
            return;
        case 1840:
            SHARED_BUFFER[204] = value;
            return;
        case 1844:
            SHARED_BUFFER[205] = value;
            return;
        case 1848:
            SHARED_BUFFER[206] = value;
            return;
        case 1852:
            SHARED_BUFFER[207] = value;
            return;
        case 1856:
            SHARED_BUFFER[208] = value;
            return;
        case 1860:
            SHARED_BUFFER[209] = value;
            return;
        case 1864:
            SHARED_BUFFER[210] = value;
            return;
        case 1868:
            SHARED_BUFFER[211] = value;
            return;
        case 1872:
            SHARED_BUFFER[212] = value;
            return;
        case 1876:
            SHARED_BUFFER[213] = value;
            return;
        case 1880:
            SHARED_BUFFER[214] = value;
            return;
        case 1884:
            SHARED_BUFFER[215] = value;
            return;
        case 1888:
            SHARED_BUFFER[216] = value;
            return;
        case 1892:
            SHARED_BUFFER[217] = value;
            return;
        case 1896:
            SHARED_BUFFER[218] = value;
            return;
        case 1900:
            SHARED_BUFFER[219] = value;
            return;
        case 1904:
            SHARED_BUFFER[220] = value;
            return;
        case 1908:
            SHARED_BUFFER[221] = value;
            return;
        case 1912:
            SHARED_BUFFER[222] = value;
            return;
        case 1916:
            SHARED_BUFFER[223] = value;
            return;
        case 1920:
            SHARED_BUFFER[224] = value;
            return;
        case 1924:
            SHARED_BUFFER[225] = value;
            return;
        case 1928:
            SHARED_BUFFER[226] = value;
            return;
        case 1932:
            SHARED_BUFFER[227] = value;
            return;
        case 1936:
            SHARED_BUFFER[228] = value;
            return;
        case 1940:
            SHARED_BUFFER[229] = value;
            return;
        case 1944:
            SHARED_BUFFER[230] = value;
            return;
        case 1948:
            SHARED_BUFFER[231] = value;
            return;
        case 1952:
            SHARED_BUFFER[232] = value;
            return;
        case 1956:
            SHARED_BUFFER[233] = value;
            return;
        case 1960:
            SHARED_BUFFER[234] = value;
            return;
        case 1964:
            SHARED_BUFFER[235] = value;
            return;
        case 1968:
            SHARED_BUFFER[236] = value;
            return;
        case 1972:
            SHARED_BUFFER[237] = value;
            return;
        case 1976:
            SHARED_BUFFER[238] = value;
            return;
        case 1980:
            SHARED_BUFFER[239] = value;
            return;
        case 1984:
            SHARED_BUFFER[240] = value;
            return;
        case 1988:
            SHARED_BUFFER[241] = value;
            return;
        case 1992:
            SHARED_BUFFER[242] = value;
            return;
        case 1996:
            SHARED_BUFFER[243] = value;
            return;
        case 2000:
            SHARED_BUFFER[244] = value;
            return;
        case 2004:
            SHARED_BUFFER[245] = value;
            return;
        case 2008:
            SHARED_BUFFER[246] = value;
            return;
        case 2012:
            SHARED_BUFFER[247] = value;
            return;
        case 2016:
            SHARED_BUFFER[248] = value;
            return;
        case 2020:
            SHARED_BUFFER[249] = value;
            return;
        case 2024:
            SHARED_BUFFER[250] = value;
            return;
        case 2028:
            SHARED_BUFFER[251] = value;
            return;
        case 2032:
            SHARED_BUFFER[252] = value;
            return;
        case 2036:
            SHARED_BUFFER[253] = value;
            return;
        case 2040:
            SHARED_BUFFER[254] = value;
            return;
        case 2044:
            SHARED_BUFFER[255] = value;
            return;
        default:
            throw std::runtime_error("invalid register address");
        }
    }
#else
    uint32_t &operator[](const int addr_offset)
    {
        return reinterpret_cast<uint32_t *>(this)[addr_offset / 4];
    }
#endif
    enum class access_type_t : bool
    {
        RO,
        RW
    };
    access_type_t get_access_type(uint32_t offset)
    {
        switch (offset)
        {
        case 0:
            return access_type_t::RO;
        case 4:
            return access_type_t::RO;
        case 8:
            return access_type_t::RW;
        case 12:
            return access_type_t::RW;
        case 16:
            return access_type_t::RW;
        case 20:
            return access_type_t::RW;
        case 24:
            return access_type_t::RO;
        case 28:
            return access_type_t::RW;
        case 32:
            return access_type_t::RW;
        case 36:
            return access_type_t::RO;
        case 40:
            return access_type_t::RO;
        case 44:
            return access_type_t::RW;
        case 60:
            return access_type_t::RW;
        case 64:
            return access_type_t::RW;
        case 68:
            return access_type_t::RW;
        case 72:
            return access_type_t::RW;
        case 76:
            return access_type_t::RW;
        case 128:
            return access_type_t::RW;
        case 132:
            return access_type_t::RW;
        case 136:
            return access_type_t::RW;
        case 140:
            return access_type_t::RW;
        case 144:
            return access_type_t::RW;
        case 148:
            return access_type_t::RW;
        case 152:
            return access_type_t::RW;
        case 156:
            return access_type_t::RW;
        case 160:
            return access_type_t::RW;
        case 164:
            return access_type_t::RW;
        case 168:
            return access_type_t::RW;
        case 172:
            return access_type_t::RW;
        case 176:
            return access_type_t::RW;
        case 180:
            return access_type_t::RW;
        case 184:
            return access_type_t::RW;
        case 188:
            return access_type_t::RW;
        case 4032:
            return access_type_t::RO;
        case 4048:
            return access_type_t::RO;
        case 4052:
            return access_type_t::RO;
        case 4056:
            return access_type_t::RO;
        case 4060:
            return access_type_t::RO;
        case 4064:
            return access_type_t::RO;
        case 4068:
            return access_type_t::RO;
        case 4072:
            return access_type_t::RO;
        case 4076:
            return access_type_t::RO;
        case 4080:
            return access_type_t::RO;
        case 4084:
            return access_type_t::RO;
        case 4088:
            return access_type_t::RO;
        case 4092:
            return access_type_t::RO;
        case 320:
            return access_type_t::RW;
        case 324:
            return access_type_t::RW;
        case 328:
            return access_type_t::RW;
        case 332:
            return access_type_t::RW;
        case 512:
            return access_type_t::RO;
        case 516:
            return access_type_t::RO;
        case 520:
            return access_type_t::RO;
        case 524:
            return access_type_t::RO;
        case 528:
            return access_type_t::RO;
        case 532:
            return access_type_t::RO;
        case 536:
            return access_type_t::RO;
        case 540:
            return access_type_t::RO;
        case 544:
            return access_type_t::RO;
        case 548:
            return access_type_t::RO;
        case 552:
            return access_type_t::RO;
        case 556:
            return access_type_t::RO;
        case 560:
            return access_type_t::RO;
        case 564:
            return access_type_t::RO;
        case 568:
            return access_type_t::RO;
        case 572:
            return access_type_t::RO;
        case 576:
            return access_type_t::RO;
        case 580:
            return access_type_t::RO;
        case 584:
            return access_type_t::RO;
        case 588:
            return access_type_t::RO;
        case 592:
            return access_type_t::RO;
        case 596:
            return access_type_t::RO;
        case 600:
            return access_type_t::RO;
        case 604:
            return access_type_t::RO;
        case 608:
            return access_type_t::RO;
        case 612:
            return access_type_t::RO;
        case 616:
            return access_type_t::RO;
        case 620:
            return access_type_t::RO;
        case 624:
            return access_type_t::RO;
        case 628:
            return access_type_t::RO;
        case 632:
            return access_type_t::RO;
        case 636:
            return access_type_t::RO;
        case 640:
            return access_type_t::RO;
        case 644:
            return access_type_t::RO;
        case 700:
            return access_type_t::RO;
        case 2048:
            return access_type_t::RW;
        case 2052:
            return access_type_t::RW;
        case 2056:
            return access_type_t::RW;
        case 2060:
            return access_type_t::RW;
        case 2064:
            return access_type_t::RW;
        case 2068:
            return access_type_t::RW;
        case 2076:
            return access_type_t::RW;
        case 2084:
            return access_type_t::RW;
        case 2088:
            return access_type_t::RW;
        case 2092:
            return access_type_t::RW;
        case 2096:
            return access_type_t::RW;
        case 2100:
            return access_type_t::RW;
        case 2108:
            return access_type_t::RW;
        case 2116:
            return access_type_t::RW;
        case 2120:
            return access_type_t::RW;
        case 2124:
            return access_type_t::RW;
        case 2128:
            return access_type_t::RW;
        case 2132:
            return access_type_t::RW;
        case 2136:
            return access_type_t::RW;
        case 2140:
            return access_type_t::RW;
        case 2144:
            return access_type_t::RW;
        case 2152:
            return access_type_t::RW;
        case 2156:
            return access_type_t::RW;
        case 2160:
            return access_type_t::RW;
        case 2172:
            return access_type_t::RW;
        case 2176:
            return access_type_t::RW;
        case 2180:
            return access_type_t::RW;
        case 2184:
            return access_type_t::RW;
        case 2188:
            return access_type_t::RW;
        case 2192:
            return access_type_t::RW;
        case 2196:
            return access_type_t::RW;
        case 2200:
            return access_type_t::RW;
        case 2204:
            return access_type_t::RW;
        case 2208:
            return access_type_t::RW;
        case 2212:
            return access_type_t::RW;
        case 2228:
            return access_type_t::RW;
        case 2236:
            return access_type_t::RW;
        case 2240:
            return access_type_t::RW;
        case 2244:
            return access_type_t::RW;
        case 2248:
            return access_type_t::RW;
        case 2252:
            return access_type_t::RW;
        case 2304:
            return access_type_t::RW;
        case 2308:
            return access_type_t::RW;
        case 2324:
            return access_type_t::RW;
        case 2340:
            return access_type_t::RW;
        case 2344:
            return access_type_t::RW;
        case 2348:
            return access_type_t::RW;
        case 2352:
            return access_type_t::RW;
        case 2356:
            return access_type_t::RW;
        case 2364:
            return access_type_t::RW;
        case 2560:
            return access_type_t::RW;
        case 2564:
            return access_type_t::RW;
        case 2568:
            return access_type_t::RW;
        case 2572:
            return access_type_t::RW;
        case 2576:
            return access_type_t::RW;
        case 2580:
            return access_type_t::RW;
        case 2584:
            return access_type_t::RW;
        case 2588:
            return access_type_t::RW;
        case 2592:
            return access_type_t::RW;
        case 2596:
            return access_type_t::RW;
        case 2600:
            return access_type_t::RW;
        case 2604:
            return access_type_t::RW;
        case 2608:
            return access_type_t::RW;
        case 2612:
            return access_type_t::RW;
        case 2624:
            return access_type_t::RW;
        case 2628:
            return access_type_t::RW;
        case 2632:
            return access_type_t::RW;
        case 2636:
            return access_type_t::RW;
        case 2640:
            return access_type_t::RW;
        case 2644:
            return access_type_t::RW;
        case 2648:
            return access_type_t::RW;
        case 2652:
            return access_type_t::RW;
        case 2656:
            return access_type_t::RW;
        case 2660:
            return access_type_t::RW;
        case 2664:
            return access_type_t::RW;
        case 2668:
            return access_type_t::RW;
        case 2672:
            return access_type_t::RW;
        case 2676:
            return access_type_t::RW;
        case 2688:
            return access_type_t::RW;
        case 2692:
            return access_type_t::RW;
        case 2696:
            return access_type_t::RW;
        case 2700:
            return access_type_t::RW;
        case 2704:
            return access_type_t::RW;
        case 2708:
            return access_type_t::RW;
        case 2712:
            return access_type_t::RW;
        case 2720:
            return access_type_t::RW;
        case 2724:
            return access_type_t::RW;
        case 2728:
            return access_type_t::RW;
        case 2732:
            return access_type_t::RW;
        case 2736:
            return access_type_t::RW;
        case 2752:
            return access_type_t::RW;
        case 2756:
            return access_type_t::RW;
        case 2760:
            return access_type_t::RW;
        case 2764:
            return access_type_t::RW;
        case 2768:
            return access_type_t::RW;
        case 2772:
            return access_type_t::RW;
        case 2776:
            return access_type_t::RW;
        case 2780:
            return access_type_t::RW;
        case 2784:
            return access_type_t::RW;
        case 2788:
            return access_type_t::RW;
        case 2816:
            return access_type_t::RW;
        case 2820:
            return access_type_t::RW;
        case 2824:
            return access_type_t::RW;
        case 2828:
            return access_type_t::RW;
        case 2832:
            return access_type_t::RW;
        case 2836:
            return access_type_t::RW;
        case 2840:
            return access_type_t::RW;
        case 2844:
            return access_type_t::RW;
        case 2848:
            return access_type_t::RW;
        case 2852:
            return access_type_t::RW;
        case 2856:
            return access_type_t::RW;
        case 2860:
            return access_type_t::RW;
        case 2864:
            return access_type_t::RW;
        case 2868:
            return access_type_t::RW;
        case 2880:
            return access_type_t::RW;
        case 2884:
            return access_type_t::RW;
        case 2888:
            return access_type_t::RW;
        case 2892:
            return access_type_t::RW;
        case 2896:
            return access_type_t::RW;
        case 2900:
            return access_type_t::RW;
        case 2904:
            return access_type_t::RW;
        case 384:
            return access_type_t::RW;
        case 388:
            return access_type_t::RW;
        case 392:
            return access_type_t::RW;
        case 396:
            return access_type_t::RW;
        case 400:
            return access_type_t::RW;
        case 404:
            return access_type_t::RW;
        case 408:
            return access_type_t::RW;
        case 416:
            return access_type_t::RW;
        case 420:
            return access_type_t::RW;
        case 424:
            return access_type_t::RW;
        case 428:
            return access_type_t::RW;
        case 768:
            return access_type_t::RW;
        case 772:
            return access_type_t::RW;
        case 776:
            return access_type_t::RW;
        case 780:
            return access_type_t::RW;
        case 896:
            return access_type_t::RW;
        case 900:
            return access_type_t::RW;
        case 904:
            return access_type_t::RW;
        case 908:
            return access_type_t::RW;
        case 1024:
            return access_type_t::RW;
        case 1028:
            return access_type_t::RW;
        case 1032:
            return access_type_t::RW;
        case 1036:
            return access_type_t::RW;
        case 1040:
            return access_type_t::RW;
        case 1044:
            return access_type_t::RW;
        case 1048:
            return access_type_t::RW;
        case 1052:
            return access_type_t::RW;
        case 1056:
            return access_type_t::RW;
        case 1060:
            return access_type_t::RW;
        case 1064:
            return access_type_t::RW;
        case 1068:
            return access_type_t::RW;
        case 1072:
            return access_type_t::RW;
        case 1076:
            return access_type_t::RW;
        case 1080:
            return access_type_t::RW;
        case 1084:
            return access_type_t::RW;
        case 1088:
            return access_type_t::RW;
        case 1092:
            return access_type_t::RW;
        case 1096:
            return access_type_t::RW;
        case 1100:
            return access_type_t::RW;
        case 1104:
            return access_type_t::RW;
        case 1108:
            return access_type_t::RW;
        case 1112:
            return access_type_t::RW;
        case 1116:
            return access_type_t::RW;
        case 1120:
            return access_type_t::RW;
        case 1124:
            return access_type_t::RW;
        case 1128:
            return access_type_t::RW;
        case 1132:
            return access_type_t::RW;
        case 1136:
            return access_type_t::RW;
        case 1140:
            return access_type_t::RW;
        case 1144:
            return access_type_t::RW;
        case 1148:
            return access_type_t::RW;
        case 1152:
            return access_type_t::RW;
        case 1156:
            return access_type_t::RW;
        case 1160:
            return access_type_t::RW;
        case 1164:
            return access_type_t::RW;
        case 1168:
            return access_type_t::RW;
        case 1172:
            return access_type_t::RW;
        case 1176:
            return access_type_t::RW;
        case 1180:
            return access_type_t::RW;
        case 1184:
            return access_type_t::RW;
        case 1188:
            return access_type_t::RW;
        case 1192:
            return access_type_t::RW;
        case 1196:
            return access_type_t::RW;
        case 1200:
            return access_type_t::RW;
        case 1204:
            return access_type_t::RW;
        case 1208:
            return access_type_t::RW;
        case 1212:
            return access_type_t::RW;
        case 1216:
            return access_type_t::RW;
        case 1220:
            return access_type_t::RW;
        case 1224:
            return access_type_t::RW;
        case 1228:
            return access_type_t::RW;
        case 1232:
            return access_type_t::RW;
        case 1236:
            return access_type_t::RW;
        case 1240:
            return access_type_t::RW;
        case 1244:
            return access_type_t::RW;
        case 1248:
            return access_type_t::RW;
        case 1252:
            return access_type_t::RW;
        case 1256:
            return access_type_t::RW;
        case 1260:
            return access_type_t::RW;
        case 1264:
            return access_type_t::RW;
        case 1268:
            return access_type_t::RW;
        case 1272:
            return access_type_t::RW;
        case 1276:
            return access_type_t::RW;
        case 1280:
            return access_type_t::RW;
        case 1284:
            return access_type_t::RW;
        case 1288:
            return access_type_t::RW;
        case 1292:
            return access_type_t::RW;
        case 1296:
            return access_type_t::RW;
        case 1300:
            return access_type_t::RW;
        case 1304:
            return access_type_t::RW;
        case 1308:
            return access_type_t::RW;
        case 1312:
            return access_type_t::RW;
        case 1316:
            return access_type_t::RW;
        case 1320:
            return access_type_t::RW;
        case 1324:
            return access_type_t::RW;
        case 1328:
            return access_type_t::RW;
        case 1332:
            return access_type_t::RW;
        case 1336:
            return access_type_t::RW;
        case 1340:
            return access_type_t::RW;
        case 1344:
            return access_type_t::RW;
        case 1348:
            return access_type_t::RW;
        case 1352:
            return access_type_t::RW;
        case 1356:
            return access_type_t::RW;
        case 1360:
            return access_type_t::RW;
        case 1364:
            return access_type_t::RW;
        case 1368:
            return access_type_t::RW;
        case 1372:
            return access_type_t::RW;
        case 1376:
            return access_type_t::RW;
        case 1380:
            return access_type_t::RW;
        case 1384:
            return access_type_t::RW;
        case 1388:
            return access_type_t::RW;
        case 1392:
            return access_type_t::RW;
        case 1396:
            return access_type_t::RW;
        case 1400:
            return access_type_t::RW;
        case 1404:
            return access_type_t::RW;
        case 1408:
            return access_type_t::RW;
        case 1412:
            return access_type_t::RW;
        case 1416:
            return access_type_t::RW;
        case 1420:
            return access_type_t::RW;
        case 1424:
            return access_type_t::RW;
        case 1428:
            return access_type_t::RW;
        case 1432:
            return access_type_t::RW;
        case 1436:
            return access_type_t::RW;
        case 1440:
            return access_type_t::RW;
        case 1444:
            return access_type_t::RW;
        case 1448:
            return access_type_t::RW;
        case 1452:
            return access_type_t::RW;
        case 1456:
            return access_type_t::RW;
        case 1460:
            return access_type_t::RW;
        case 1464:
            return access_type_t::RW;
        case 1468:
            return access_type_t::RW;
        case 1472:
            return access_type_t::RW;
        case 1476:
            return access_type_t::RW;
        case 1480:
            return access_type_t::RW;
        case 1484:
            return access_type_t::RW;
        case 1488:
            return access_type_t::RW;
        case 1492:
            return access_type_t::RW;
        case 1496:
            return access_type_t::RW;
        case 1500:
            return access_type_t::RW;
        case 1504:
            return access_type_t::RW;
        case 1508:
            return access_type_t::RW;
        case 1512:
            return access_type_t::RW;
        case 1516:
            return access_type_t::RW;
        case 1520:
            return access_type_t::RW;
        case 1524:
            return access_type_t::RW;
        case 1528:
            return access_type_t::RW;
        case 1532:
            return access_type_t::RW;
        case 1536:
            return access_type_t::RW;
        case 1540:
            return access_type_t::RW;
        case 1544:
            return access_type_t::RW;
        case 1548:
            return access_type_t::RW;
        case 1552:
            return access_type_t::RW;
        case 1556:
            return access_type_t::RW;
        case 1560:
            return access_type_t::RW;
        case 1564:
            return access_type_t::RW;
        case 1568:
            return access_type_t::RW;
        case 1572:
            return access_type_t::RW;
        case 1576:
            return access_type_t::RW;
        case 1580:
            return access_type_t::RW;
        case 1584:
            return access_type_t::RW;
        case 1588:
            return access_type_t::RW;
        case 1592:
            return access_type_t::RW;
        case 1596:
            return access_type_t::RW;
        case 1600:
            return access_type_t::RW;
        case 1604:
            return access_type_t::RW;
        case 1608:
            return access_type_t::RW;
        case 1612:
            return access_type_t::RW;
        case 1616:
            return access_type_t::RW;
        case 1620:
            return access_type_t::RW;
        case 1624:
            return access_type_t::RW;
        case 1628:
            return access_type_t::RW;
        case 1632:
            return access_type_t::RW;
        case 1636:
            return access_type_t::RW;
        case 1640:
            return access_type_t::RW;
        case 1644:
            return access_type_t::RW;
        case 1648:
            return access_type_t::RW;
        case 1652:
            return access_type_t::RW;
        case 1656:
            return access_type_t::RW;
        case 1660:
            return access_type_t::RW;
        case 1664:
            return access_type_t::RW;
        case 1668:
            return access_type_t::RW;
        case 1672:
            return access_type_t::RW;
        case 1676:
            return access_type_t::RW;
        case 1680:
            return access_type_t::RW;
        case 1684:
            return access_type_t::RW;
        case 1688:
            return access_type_t::RW;
        case 1692:
            return access_type_t::RW;
        case 1696:
            return access_type_t::RW;
        case 1700:
            return access_type_t::RW;
        case 1704:
            return access_type_t::RW;
        case 1708:
            return access_type_t::RW;
        case 1712:
            return access_type_t::RW;
        case 1716:
            return access_type_t::RW;
        case 1720:
            return access_type_t::RW;
        case 1724:
            return access_type_t::RW;
        case 1728:
            return access_type_t::RW;
        case 1732:
            return access_type_t::RW;
        case 1736:
            return access_type_t::RW;
        case 1740:
            return access_type_t::RW;
        case 1744:
            return access_type_t::RW;
        case 1748:
            return access_type_t::RW;
        case 1752:
            return access_type_t::RW;
        case 1756:
            return access_type_t::RW;
        case 1760:
            return access_type_t::RW;
        case 1764:
            return access_type_t::RW;
        case 1768:
            return access_type_t::RW;
        case 1772:
            return access_type_t::RW;
        case 1776:
            return access_type_t::RW;
        case 1780:
            return access_type_t::RW;
        case 1784:
            return access_type_t::RW;
        case 1788:
            return access_type_t::RW;
        case 1792:
            return access_type_t::RW;
        case 1796:
            return access_type_t::RW;
        case 1800:
            return access_type_t::RW;
        case 1804:
            return access_type_t::RW;
        case 1808:
            return access_type_t::RW;
        case 1812:
            return access_type_t::RW;
        case 1816:
            return access_type_t::RW;
        case 1820:
            return access_type_t::RW;
        case 1824:
            return access_type_t::RW;
        case 1828:
            return access_type_t::RW;
        case 1832:
            return access_type_t::RW;
        case 1836:
            return access_type_t::RW;
        case 1840:
            return access_type_t::RW;
        case 1844:
            return access_type_t::RW;
        case 1848:
            return access_type_t::RW;
        case 1852:
            return access_type_t::RW;
        case 1856:
            return access_type_t::RW;
        case 1860:
            return access_type_t::RW;
        case 1864:
            return access_type_t::RW;
        case 1868:
            return access_type_t::RW;
        case 1872:
            return access_type_t::RW;
        case 1876:
            return access_type_t::RW;
        case 1880:
            return access_type_t::RW;
        case 1884:
            return access_type_t::RW;
        case 1888:
            return access_type_t::RW;
        case 1892:
            return access_type_t::RW;
        case 1896:
            return access_type_t::RW;
        case 1900:
            return access_type_t::RW;
        case 1904:
            return access_type_t::RW;
        case 1908:
            return access_type_t::RW;
        case 1912:
            return access_type_t::RW;
        case 1916:
            return access_type_t::RW;
        case 1920:
            return access_type_t::RW;
        case 1924:
            return access_type_t::RW;
        case 1928:
            return access_type_t::RW;
        case 1932:
            return access_type_t::RW;
        case 1936:
            return access_type_t::RW;
        case 1940:
            return access_type_t::RW;
        case 1944:
            return access_type_t::RW;
        case 1948:
            return access_type_t::RW;
        case 1952:
            return access_type_t::RW;
        case 1956:
            return access_type_t::RW;
        case 1960:
            return access_type_t::RW;
        case 1964:
            return access_type_t::RW;
        case 1968:
            return access_type_t::RW;
        case 1972:
            return access_type_t::RW;
        case 1976:
            return access_type_t::RW;
        case 1980:
            return access_type_t::RW;
        case 1984:
            return access_type_t::RW;
        case 1988:
            return access_type_t::RW;
        case 1992:
            return access_type_t::RW;
        case 1996:
            return access_type_t::RW;
        case 2000:
            return access_type_t::RW;
        case 2004:
            return access_type_t::RW;
        case 2008:
            return access_type_t::RW;
        case 2012:
            return access_type_t::RW;
        case 2016:
            return access_type_t::RW;
        case 2020:
            return access_type_t::RW;
        case 2024:
            return access_type_t::RW;
        case 2028:
            return access_type_t::RW;
        case 2032:
            return access_type_t::RW;
        case 2036:
            return access_type_t::RW;
        case 2040:
            return access_type_t::RW;
        case 2044:
            return access_type_t::RW;
        default:
            throw std::runtime_error("invalid register address");
        }
    }
#endif //__cplusplus
};

// Data structure for commands without payload
struct command_no_payload_t
{
    uint32_t cmd_code : 10;
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR command_no_payload_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR command_no_payload_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Data structure for commands with payload
struct command_with_payload_t
{
    uint32_t cmd_code : 10;
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t param : 16;
    uint32_t data : 32;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return must_be_zero == 0 && payload_size >= 1 && payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR command_with_payload_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR command_with_payload_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR command_with_payload_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR command_with_payload_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Move to stopped state once all commands to this point are done. Raise IRQ to the host and logically OR the mask into
// the status register upper 16 bits (see the status register)
struct npu_op_stop_t
{
    uint32_t cmd_code : 10;     // NPU_OP_STOP
    uint32_t must_be_zero0 : 6; // 0
    uint32_t mask : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_OP_STOP) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_OP_STOP);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_op_stop_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_mask() const
    {
        return static_cast<uint32_t>(mask);
    }
    CONSTEXPR npu_op_stop_t &set_mask(uint32_t value)
    {
        mask = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Raise IRQ to the host and logically OR the mask into the status register upper 16 bits (see the status register)
struct npu_op_irq_t
{
    uint32_t cmd_code : 10;     // NPU_OP_IRQ
    uint32_t must_be_zero0 : 6; // 0
    uint32_t mask : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_OP_IRQ) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_OP_IRQ);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_op_irq_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_mask() const
    {
        return static_cast<uint32_t>(mask);
    }
    CONSTEXPR npu_op_irq_t &set_mask(uint32_t value)
    {
        mask = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Start stripe with full convolution or deconvolution
struct npu_op_conv_t
{
    uint32_t cmd_code : 10;     // NPU_OP_CONV
    uint32_t must_be_zero0 : 6; // 0
    uint32_t reserved0 : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_OP_CONV) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_OP_CONV);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_op_conv_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Start stripe width depth-wise convolution or deconvolution operation
struct npu_op_depthwise_t
{
    uint32_t cmd_code : 10;     // NPU_OP_DEPTHWISE
    uint32_t must_be_zero0 : 6; // 0
    uint32_t reserved0 : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_OP_DEPTHWISE) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_OP_DEPTHWISE);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_op_depthwise_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Start stripe with pooling operation
struct npu_op_pool_t
{
    uint32_t cmd_code : 10;     // NPU_OP_POOL
    uint32_t must_be_zero0 : 6; // 0
    uint32_t mode : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_OP_POOL) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_OP_POOL);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_op_pool_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR ::pooling_mode get_mode() const
    {
        return static_cast<::pooling_mode>(mode);
    }
    CONSTEXPR npu_op_pool_t &set_mode(::pooling_mode value)
    {
        mode = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Start stripe with pointwise operation
struct npu_op_elementwise_t
{
    uint32_t cmd_code : 10;     // NPU_OP_ELEMENTWISE
    uint32_t must_be_zero0 : 6; // 0
    uint32_t mode : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_OP_ELEMENTWISE) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_OP_ELEMENTWISE);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_op_elementwise_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR ::elementwise_mode get_mode() const
    {
        return static_cast<::elementwise_mode>(mode);
    }
    CONSTEXPR npu_op_elementwise_t &set_mode(::elementwise_mode value)
    {
        mode = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Queue new DMA for the given channel with the given mode. Mode bit 0 specifies the source address type 0=external,
// 1=internal Mode bit 1 specifies the destination address type 0=external, 1=internal In Ethos-U55 there is only one
// user channel so channel=0. If the channel is fully in use then the command blocks until a new DMA can start
struct npu_op_dma_start_t
{
    uint32_t cmd_code : 10;     // NPU_OP_DMA_START
    uint32_t must_be_zero0 : 6; // 0
    uint32_t channel_mode : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_OP_DMA_START) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_OP_DMA_START);
        must_be_zero0 = 0;
    }
    CONSTEXPR uint32_t get_channel_mode() const
    {
        return static_cast<uint32_t>(channel_mode);
    }
    CONSTEXPR npu_op_dma_start_t &set_channel_mode(uint32_t value)
    {
        channel_mode = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_op_dma_start_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Wait for the DMA channel to have k or fewer active descriptors outstanding. In Ethos-U55 there is only one user
// channel so channel=0. In Ethos-U55 there is only one descriptor per channel so k=0 and the command waits for the
// single DMA to be complete.
struct npu_op_dma_wait_t
{
    uint32_t cmd_code : 10;     // NPU_OP_DMA_WAIT
    uint32_t must_be_zero0 : 6; // 0
    uint32_t reserved0 : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_OP_DMA_WAIT) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_OP_DMA_WAIT);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_op_dma_wait_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Wait for n or fewer kernel operations to be remaining (not complete) before starting the next command. A kernel
// operation is Conv, Depthwise, Pool, VectorProd Elementwise. This command is typically placed before an
// NPU_OP_DMA_START command to prevent the DMA from starting until a previous kernel operation reading the memory has
// completed.
struct npu_op_kernel_wait_t
{
    uint32_t cmd_code : 10;     // NPU_OP_KERNEL_WAIT
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_OP_KERNEL_WAIT) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_OP_KERNEL_WAIT);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_op_kernel_wait_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_op_kernel_wait_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Enable or disable PMU counting (debug feature only).
struct npu_op_pmu_mask_t
{
    uint32_t cmd_code : 10;     // NPU_OP_PMU_MASK
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_OP_PMU_MASK) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_OP_PMU_MASK);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_op_pmu_mask_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_op_pmu_mask_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// IFM top pad
struct npu_set_ifm_pad_top_t
{
    uint32_t cmd_code : 10;     // NPU_SET_IFM_PAD_TOP
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_IFM_PAD_TOP) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_IFM_PAD_TOP);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ifm_pad_top_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_ifm_pad_top_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// IFM left pad
struct npu_set_ifm_pad_left_t
{
    uint32_t cmd_code : 10;     // NPU_SET_IFM_PAD_LEFT
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_IFM_PAD_LEFT) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_IFM_PAD_LEFT);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ifm_pad_left_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_ifm_pad_left_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// IFM right pad
struct npu_set_ifm_pad_right_t
{
    uint32_t cmd_code : 10;     // NPU_SET_IFM_PAD_RIGHT
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_IFM_PAD_RIGHT) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_IFM_PAD_RIGHT);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ifm_pad_right_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_ifm_pad_right_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// IFM bottom pad
struct npu_set_ifm_pad_bottom_t
{
    uint32_t cmd_code : 10;     // NPU_SET_IFM_PAD_BOTTOM
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_IFM_PAD_BOTTOM) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_IFM_PAD_BOTTOM);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ifm_pad_bottom_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_ifm_pad_bottom_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Number of input channels - 1
struct npu_set_ifm_depth_m1_t
{
    uint32_t cmd_code : 10;     // NPU_SET_IFM_DEPTH_M1
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_IFM_DEPTH_M1) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_IFM_DEPTH_M1);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ifm_depth_m1_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_ifm_depth_m1_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set IFM precision
struct npu_set_ifm_precision_t
{
    uint32_t cmd_code : 10;     // NPU_SET_IFM_PRECISION
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 4;
    uint32_t reserved0 : 2;
    uint32_t format : 2;
    uint32_t scale_mode : 2;
    uint32_t reserved1 : 4;
    uint32_t round_mode : 2;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_IFM_PRECISION) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_IFM_PRECISION);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ifm_precision_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR ::data_format get_format() const
    {
        return static_cast<::data_format>(format);
    }
    CONSTEXPR npu_set_ifm_precision_t &set_format(::data_format value)
    {
        format = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR ::ifm_precision get_param() const
    {
        return static_cast<::ifm_precision>(param);
    }
    CONSTEXPR npu_set_ifm_precision_t &set_param(::ifm_precision value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR ::rounding get_round_mode() const
    {
        return static_cast<::rounding>(round_mode);
    }
    CONSTEXPR npu_set_ifm_precision_t &set_round_mode(::rounding value)
    {
        round_mode = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR ::ifm_scale_mode get_scale_mode() const
    {
        return static_cast<::ifm_scale_mode>(scale_mode);
    }
    CONSTEXPR npu_set_ifm_precision_t &set_scale_mode(::ifm_scale_mode value)
    {
        scale_mode = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// b[1:0] = upscale mode (0=none, 1=2x2 nearest, 2=2x2 transpose)
struct npu_set_ifm_upscale_t
{
    uint32_t cmd_code : 10;     // NPU_SET_IFM_UPSCALE
    uint32_t must_be_zero0 : 6; // 0
    uint32_t mode : 2;
    uint32_t reserved0 : 14;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_IFM_UPSCALE) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_IFM_UPSCALE);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ifm_upscale_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR ::resampling_mode get_mode() const
    {
        return static_cast<::resampling_mode>(mode);
    }
    CONSTEXPR npu_set_ifm_upscale_t &set_mode(::resampling_mode value)
    {
        mode = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Zero point offset (so value that 0 is encoded as)
struct npu_set_ifm_zero_point_t
{
    uint32_t cmd_code : 10;     // NPU_SET_IFM_ZERO_POINT
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_IFM_ZERO_POINT) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_IFM_ZERO_POINT);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ifm_zero_point_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_ifm_zero_point_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// IFM Tile 0 and tile 2 (width-1)
struct npu_set_ifm_width0_m1_t
{
    uint32_t cmd_code : 10;     // NPU_SET_IFM_WIDTH0_M1
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_IFM_WIDTH0_M1) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_IFM_WIDTH0_M1);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ifm_width0_m1_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_ifm_width0_m1_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// IFM Tile 0 (height-1)
struct npu_set_ifm_height0_m1_t
{
    uint32_t cmd_code : 10;     // NPU_SET_IFM_HEIGHT0_M1
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_IFM_HEIGHT0_M1) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_IFM_HEIGHT0_M1);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ifm_height0_m1_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_ifm_height0_m1_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// IFM Tile 1 (height-1)
struct npu_set_ifm_height1_m1_t
{
    uint32_t cmd_code : 10;     // NPU_SET_IFM_HEIGHT1_M1
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_IFM_HEIGHT1_M1) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_IFM_HEIGHT1_M1);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ifm_height1_m1_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_ifm_height1_m1_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// End of IB0,IB1 buffers in the SHRAM in KB units. Multiple of 2.
struct npu_set_ifm_ib_end_t
{
    uint32_t cmd_code : 10;     // NPU_SET_IFM_IB_END
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_IFM_IB_END) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_IFM_IB_END);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ifm_ib_end_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_ifm_ib_end_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Index n for IFM access: BasePointer[n] is added to all IFM offsets
struct npu_set_ifm_region_t
{
    uint32_t cmd_code : 10;     // NPU_SET_IFM_REGION
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_IFM_REGION) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_IFM_REGION);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ifm_region_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_ifm_region_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Output feature map width -1 (for the stripe to process)
struct npu_set_ofm_width_m1_t
{
    uint32_t cmd_code : 10;     // NPU_SET_OFM_WIDTH_M1
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_OFM_WIDTH_M1) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_OFM_WIDTH_M1);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ofm_width_m1_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_ofm_width_m1_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Output feature map height -1 (for the stripe to process)
struct npu_set_ofm_height_m1_t
{
    uint32_t cmd_code : 10;     // NPU_SET_OFM_HEIGHT_M1
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_OFM_HEIGHT_M1) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_OFM_HEIGHT_M1);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ofm_height_m1_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_ofm_height_m1_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Output feature map depth -1 (for the stripe to process)
struct npu_set_ofm_depth_m1_t
{
    uint32_t cmd_code : 10;     // NPU_SET_OFM_DEPTH_M1
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_OFM_DEPTH_M1) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_OFM_DEPTH_M1);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ofm_depth_m1_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_ofm_depth_m1_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set OFM precision
struct npu_set_ofm_precision_t
{
    uint32_t cmd_code : 10;     // NPU_SET_OFM_PRECISION
    uint32_t must_be_zero0 : 6; // 0
    uint32_t precision : 3;
    uint32_t reserved0 : 3;
    uint32_t format : 2;
    uint32_t scaling : 1; // 0=Per channel scale/bias 1=Global scale (SET_OFM_SCALE), no bias
    uint32_t reserved1 : 5;
    uint32_t rounding : 2; // 0=TFL rounding 1=truncate towards zero 2=natural rounding
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_OFM_PRECISION) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_OFM_PRECISION);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ofm_precision_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR ::data_format get_format() const
    {
        return static_cast<::data_format>(format);
    }
    CONSTEXPR npu_set_ofm_precision_t &set_format(::data_format value)
    {
        format = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR ::ofm_precision get_precision() const
    {
        return static_cast<::ofm_precision>(precision);
    }
    CONSTEXPR npu_set_ofm_precision_t &set_precision(::ofm_precision value)
    {
        precision = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR ::rounding get_rounding() const
    {
        return static_cast<::rounding>(rounding);
    }
    CONSTEXPR npu_set_ofm_precision_t &set_rounding(::rounding value)
    {
        rounding = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_scaling() const
    {
        return static_cast<uint32_t>(scaling);
    }
    CONSTEXPR npu_set_ofm_precision_t &set_scaling(uint32_t value)
    {
        scaling = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// TSU block width - 1 (provided sufficient data remaining)
struct npu_set_ofm_blk_width_m1_t
{
    uint32_t cmd_code : 10;     // NPU_SET_OFM_BLK_WIDTH_M1
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_OFM_BLK_WIDTH_M1) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_OFM_BLK_WIDTH_M1);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ofm_blk_width_m1_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_ofm_blk_width_m1_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// TSU block height -1 (provided sufficient data remaining)
struct npu_set_ofm_blk_height_m1_t
{
    uint32_t cmd_code : 10;     // NPU_SET_OFM_BLK_HEIGHT_M1
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_OFM_BLK_HEIGHT_M1) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_OFM_BLK_HEIGHT_M1);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ofm_blk_height_m1_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_ofm_blk_height_m1_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// TSU block depth -1 (provided sufficient data remaining)
struct npu_set_ofm_blk_depth_m1_t
{
    uint32_t cmd_code : 10;     // NPU_SET_OFM_BLK_DEPTH_M1
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_OFM_BLK_DEPTH_M1) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_OFM_BLK_DEPTH_M1);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ofm_blk_depth_m1_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_ofm_blk_depth_m1_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Zero point offset (so value that 0 is encoded as)
struct npu_set_ofm_zero_point_t
{
    uint32_t cmd_code : 10;     // NPU_SET_OFM_ZERO_POINT
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_OFM_ZERO_POINT) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_OFM_ZERO_POINT);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ofm_zero_point_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_ofm_zero_point_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// OFM Tile 0 and tile 2 (width-1)
struct npu_set_ofm_width0_m1_t
{
    uint32_t cmd_code : 10;     // NPU_SET_OFM_WIDTH0_M1
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_OFM_WIDTH0_M1) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_OFM_WIDTH0_M1);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ofm_width0_m1_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_ofm_width0_m1_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// OFM Tile 0 (height-1)
struct npu_set_ofm_height0_m1_t
{
    uint32_t cmd_code : 10;     // NPU_SET_OFM_HEIGHT0_M1
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_OFM_HEIGHT0_M1) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_OFM_HEIGHT0_M1);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ofm_height0_m1_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_ofm_height0_m1_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// OFM Tile 1 (height-1)
struct npu_set_ofm_height1_m1_t
{
    uint32_t cmd_code : 10;     // NPU_SET_OFM_HEIGHT1_M1
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_OFM_HEIGHT1_M1) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_OFM_HEIGHT1_M1);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ofm_height1_m1_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_ofm_height1_m1_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Index n for OFM access: BasePointer[n] is added to all OFM offsets
struct npu_set_ofm_region_t
{
    uint32_t cmd_code : 10;     // NPU_SET_OFM_REGION
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_OFM_REGION) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_OFM_REGION);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ofm_region_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_ofm_region_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set kernel width - 1
struct npu_set_kernel_width_m1_t
{
    uint32_t cmd_code : 10;     // NPU_SET_KERNEL_WIDTH_M1
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_KERNEL_WIDTH_M1) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_KERNEL_WIDTH_M1);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_kernel_width_m1_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_kernel_width_m1_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set kernel height - 1
struct npu_set_kernel_height_m1_t
{
    uint32_t cmd_code : 10;     // NPU_SET_KERNEL_HEIGHT_M1
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_KERNEL_HEIGHT_M1) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_KERNEL_HEIGHT_M1);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_kernel_height_m1_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_kernel_height_m1_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Kernel stride b0=X stride-1, b1=Y stride-1, b2=weight order (0=depth, 1=kernel) b3 = kernel_x_dilation - 1 (0=no x
// dilation, 1=x dilation of x2) b4 = kernel_y_dilation -1 (0=no y dilation, 1=y dilation of x2) b5 = kernel
// decomposition size (0 for kernel_split_size=8, 1 for kernel_split_size=4)
struct npu_set_kernel_stride_t
{
    uint32_t cmd_code : 10;     // NPU_SET_KERNEL_STRIDE
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_KERNEL_STRIDE) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_KERNEL_STRIDE);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_kernel_stride_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_kernel_stride_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// 0=1-core, 1=2-core depth
struct npu_set_parallel_mode_t
{
    uint32_t cmd_code : 10;     // NPU_SET_PARALLEL_MODE
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_PARALLEL_MODE) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_PARALLEL_MODE);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_parallel_mode_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_parallel_mode_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set accumulator format
struct npu_set_acc_format_t
{
    uint32_t cmd_code : 10;     // NPU_SET_ACC_FORMAT
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_ACC_FORMAT) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_ACC_FORMAT);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_acc_format_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR ::acc_format get_param() const
    {
        return static_cast<::acc_format>(param);
    }
    CONSTEXPR npu_set_acc_format_t &set_param(::acc_format value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set activation
struct npu_set_activation_t
{
    uint32_t cmd_code : 10;     // NPU_SET_ACTIVATION
    uint32_t must_be_zero0 : 6; // 0
    uint32_t type : 12;
    uint32_t act_clip_range : 4;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_ACTIVATION) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_ACTIVATION);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::clip_range get_act_clip_range() const
    {
        return static_cast<::clip_range>(act_clip_range);
    }
    CONSTEXPR npu_set_activation_t &set_act_clip_range(::clip_range value)
    {
        act_clip_range = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_activation_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR ::activation get_type() const
    {
        return static_cast<::activation>(type);
    }
    CONSTEXPR npu_set_activation_t &set_type(::activation value)
    {
        type = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Lower bound clip for OFM activations – range is the OFM type range
struct npu_set_activation_min_t
{
    uint32_t cmd_code : 10;     // NPU_SET_ACTIVATION_MIN
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_ACTIVATION_MIN) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_ACTIVATION_MIN);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_activation_min_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_activation_min_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Upper bound clip for OFM activations – range is the OFM type range
struct npu_set_activation_max_t
{
    uint32_t cmd_code : 10;     // NPU_SET_ACTIVATION_MAX
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_ACTIVATION_MAX) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_ACTIVATION_MAX);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_activation_max_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_activation_max_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Index n for weight access: BasePointer[n] is added to all Weight stream offsets
struct npu_set_weight_region_t
{
    uint32_t cmd_code : 10;     // NPU_SET_WEIGHT_REGION
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_WEIGHT_REGION) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_WEIGHT_REGION);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_weight_region_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_weight_region_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Index n for weight access: BasePointer[n] is added to all scale stream offsets
struct npu_set_scale_region_t
{
    uint32_t cmd_code : 10;     // NPU_SET_SCALE_REGION
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_SCALE_REGION) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_SCALE_REGION);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_scale_region_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_scale_region_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Start of ACC0,ACC1 buffers in the SHRAM in KB units. Multiple of 4.)
struct npu_set_ab_start_t
{
    uint32_t cmd_code : 10;     // NPU_SET_AB_START
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_AB_START) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_AB_START);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ab_start_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_ab_start_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set block number of blocks dependency between kernel operations
struct npu_set_blockdep_t
{
    uint32_t cmd_code : 10;     // NPU_SET_BLOCKDEP
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_BLOCKDEP) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_BLOCKDEP);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_blockdep_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_blockdep_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// DMA0 SRC region bitmap
struct npu_set_dma0_src_region_t
{
    uint32_t cmd_code : 10;     // NPU_SET_DMA0_SRC_REGION
    uint32_t must_be_zero0 : 6; // 0
    uint32_t region : 8;        // If Bit[8]=0, Bit[7:0]=Region number in the range [0, 8) of SRC offset. If Bit[8]=1,
                                // Bit[7:0]=Core number (0 or 1) to read.
    uint32_t internal : 1;      // Must be 0 (external)
    uint32_t stride_mode : 2;   // stride mode 0/1/2=1D/2D/3D
    uint32_t reserved0 : 5;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_DMA0_SRC_REGION) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_DMA0_SRC_REGION);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_dma0_src_region_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_internal() const
    {
        return static_cast<uint32_t>(internal);
    }
    CONSTEXPR npu_set_dma0_src_region_t &set_internal(uint32_t value)
    {
        internal = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_region() const
    {
        return static_cast<uint32_t>(region);
    }
    CONSTEXPR npu_set_dma0_src_region_t &set_region(uint32_t value)
    {
        region = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR ::stride_mode get_stride_mode() const
    {
        return static_cast<::stride_mode>(stride_mode);
    }
    CONSTEXPR npu_set_dma0_src_region_t &set_stride_mode(::stride_mode value)
    {
        stride_mode = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// DMA0 DST region bitmap
struct npu_set_dma0_dst_region_t
{
    uint32_t cmd_code : 10;     // NPU_SET_DMA0_DST_REGION
    uint32_t must_be_zero0 : 6; // 0
    uint32_t region : 8;        // If Bit[8]=0, Bit[7:0]=Region number in the range [0, 8) of DST offset. If Bit[8]=1,
                                // Bit[7:0]=Core mask to write to (bit k set for core k=0,1).
    uint32_t internal : 1;      // Select external/internal=0/1
    uint32_t stride_mode : 2;   // stride mode 0/1/2=1D/2D/3D
    uint32_t reserved0 : 5;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_DMA0_DST_REGION) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_DMA0_DST_REGION);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_dma0_dst_region_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_internal() const
    {
        return static_cast<uint32_t>(internal);
    }
    CONSTEXPR npu_set_dma0_dst_region_t &set_internal(uint32_t value)
    {
        internal = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_region() const
    {
        return static_cast<uint32_t>(region);
    }
    CONSTEXPR npu_set_dma0_dst_region_t &set_region(uint32_t value)
    {
        region = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR ::stride_mode get_stride_mode() const
    {
        return static_cast<::stride_mode>(stride_mode);
    }
    CONSTEXPR npu_set_dma0_dst_region_t &set_stride_mode(::stride_mode value)
    {
        stride_mode = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Inner size for 2D/3D mode.
struct npu_set_dma0_size0_t
{
    uint32_t cmd_code : 10;     // NPU_SET_DMA0_SIZE0
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_DMA0_SIZE0) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_DMA0_SIZE0);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_dma0_size0_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_dma0_size0_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Outer size for 3D mode.
struct npu_set_dma0_size1_t
{
    uint32_t cmd_code : 10;     // NPU_SET_DMA0_SIZE1
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_DMA0_SIZE1) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_DMA0_SIZE1);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_dma0_size1_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_dma0_size1_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set IFM2 Broadcast mode
struct npu_set_ifm2_broadcast_t
{
    uint32_t cmd_code : 10;     // NPU_SET_IFM2_BROADCAST
    uint32_t must_be_zero0 : 6; // 0
    uint32_t broadcast_height : 1;
    uint32_t broadcast_width : 1;
    uint32_t broadcast_depth : 1;
    uint32_t reserved0 : 3;
    uint32_t operand_order : 1;
    uint32_t broadcast_scalar : 1;
    uint32_t reserved1 : 8;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_IFM2_BROADCAST) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_IFM2_BROADCAST);
        must_be_zero0 = 0;
    }
    CONSTEXPR uint32_t get_broadcast_depth() const
    {
        return static_cast<uint32_t>(broadcast_depth);
    }
    CONSTEXPR npu_set_ifm2_broadcast_t &set_broadcast_depth(uint32_t value)
    {
        broadcast_depth = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_broadcast_height() const
    {
        return static_cast<uint32_t>(broadcast_height);
    }
    CONSTEXPR npu_set_ifm2_broadcast_t &set_broadcast_height(uint32_t value)
    {
        broadcast_height = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_broadcast_scalar() const
    {
        return static_cast<uint32_t>(broadcast_scalar);
    }
    CONSTEXPR npu_set_ifm2_broadcast_t &set_broadcast_scalar(uint32_t value)
    {
        broadcast_scalar = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_broadcast_width() const
    {
        return static_cast<uint32_t>(broadcast_width);
    }
    CONSTEXPR npu_set_ifm2_broadcast_t &set_broadcast_width(uint32_t value)
    {
        broadcast_width = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ifm2_broadcast_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_operand_order() const
    {
        return static_cast<uint32_t>(operand_order);
    }
    CONSTEXPR npu_set_ifm2_broadcast_t &set_operand_order(uint32_t value)
    {
        operand_order = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// IFM2 scalar value at range IFM_PRECISION
struct npu_set_ifm2_scalar_t
{
    uint32_t cmd_code : 10;     // NPU_SET_IFM2_SCALAR
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_IFM2_SCALAR) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_IFM2_SCALAR);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ifm2_scalar_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_ifm2_scalar_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set activation
struct npu_set_ifm2_precision_t
{
    uint32_t cmd_code : 10;     // NPU_SET_IFM2_PRECISION
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 4;
    uint32_t reserved0 : 2;
    uint32_t format : 2;
    uint32_t reserved1 : 8;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_IFM2_PRECISION) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_IFM2_PRECISION);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ifm2_precision_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR ::data_format get_format() const
    {
        return static_cast<::data_format>(format);
    }
    CONSTEXPR npu_set_ifm2_precision_t &set_format(::data_format value)
    {
        format = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR ::ifm_precision get_param() const
    {
        return static_cast<::ifm_precision>(param);
    }
    CONSTEXPR npu_set_ifm2_precision_t &set_param(::ifm_precision value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Zero point offset (so value that 0 is encoded as) at range IFM_PRECISION
struct npu_set_ifm2_zero_point_t
{
    uint32_t cmd_code : 10;     // NPU_SET_IFM2_ZERO_POINT
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_IFM2_ZERO_POINT) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_IFM2_ZERO_POINT);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ifm2_zero_point_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_ifm2_zero_point_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// IFM2 Tile 0 and tile 2 (width-1)
struct npu_set_ifm2_width0_m1_t
{
    uint32_t cmd_code : 10;     // NPU_SET_IFM2_WIDTH0_M1
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_IFM2_WIDTH0_M1) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_IFM2_WIDTH0_M1);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ifm2_width0_m1_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_ifm2_width0_m1_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// IFM2 Tile 0 (height-1)
struct npu_set_ifm2_height0_m1_t
{
    uint32_t cmd_code : 10;     // NPU_SET_IFM2_HEIGHT0_M1
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_IFM2_HEIGHT0_M1) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_IFM2_HEIGHT0_M1);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ifm2_height0_m1_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_ifm2_height0_m1_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// IFM2 Tile 1 (height-1)
struct npu_set_ifm2_height1_m1_t
{
    uint32_t cmd_code : 10;     // NPU_SET_IFM2_HEIGHT1_M1
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_IFM2_HEIGHT1_M1) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_IFM2_HEIGHT1_M1);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ifm2_height1_m1_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_ifm2_height1_m1_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Start of IB0, IB1 buffers for IFM2 in SHRAM. In KB units, multiple of 2.
struct npu_set_ifm2_ib_start_t
{
    uint32_t cmd_code : 10;     // NPU_SET_IFM2_IB_START
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_IFM2_IB_START) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_IFM2_IB_START);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ifm2_ib_start_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_ifm2_ib_start_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Index n for IFM2 access: Region[n] is added to all IFM2 addresses
struct npu_set_ifm2_region_t
{
    uint32_t cmd_code : 10;     // NPU_SET_IFM2_REGION
    uint32_t must_be_zero0 : 6; // 0
    uint32_t param : 16;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd0::NPU_SET_IFM2_REGION) && must_be_zero0 == 0;
    }
    CONSTEXPR void init()
    {
        cmd_code      = static_cast<uint32_t>(cmd0::NPU_SET_IFM2_REGION);
        must_be_zero0 = 0;
    }
    CONSTEXPR ::cmd0 get_cmd_code() const
    {
        return static_cast<::cmd0>(cmd_code);
    }
    CONSTEXPR npu_set_ifm2_region_t &set_cmd_code(::cmd0 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_ifm2_region_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set IFM base address (top left tile)
struct npu_set_ifm_base0_t
{
    uint32_t cmd_code : 10;    // NPU_SET_IFM_BASE0
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t reserved0 : 16;
    uint32_t data : 32; // IFM base address (top left tile)
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_IFM_BASE0) && must_be_zero == 0 && payload_size >= 1 &&
               payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_IFM_BASE0);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_ifm_base0_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_ifm_base0_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_ifm_base0_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set IFM base address (top right tile)
struct npu_set_ifm_base1_t
{
    uint32_t cmd_code : 10;    // NPU_SET_IFM_BASE1
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t reserved0 : 16;
    uint32_t data : 32; // IFM base address (top right tile)
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_IFM_BASE1) && must_be_zero == 0 && payload_size >= 1 &&
               payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_IFM_BASE1);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_ifm_base1_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_ifm_base1_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_ifm_base1_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set IFM base address (bottom left tile)
struct npu_set_ifm_base2_t
{
    uint32_t cmd_code : 10;    // NPU_SET_IFM_BASE2
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t reserved0 : 16;
    uint32_t data : 32; // IFM base address (bottom left tile)
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_IFM_BASE2) && must_be_zero == 0 && payload_size >= 1 &&
               payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_IFM_BASE2);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_ifm_base2_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_ifm_base2_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_ifm_base2_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set IFM base address (bottom right tile)
struct npu_set_ifm_base3_t
{
    uint32_t cmd_code : 10;    // NPU_SET_IFM_BASE3
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t reserved0 : 16;
    uint32_t data : 32; // IFM base address (bottom right tile)
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_IFM_BASE3) && must_be_zero == 0 && payload_size >= 1 &&
               payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_IFM_BASE3);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_ifm_base3_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_ifm_base3_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_ifm_base3_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set IFM byte stride between horizontal values
struct npu_set_ifm_stride_x_t
{
    uint32_t cmd_code : 10;    // NPU_SET_IFM_STRIDE_X
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t reserved0 : 16;
    uint32_t data : 32; // IFM byte stride between horizontal values
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_IFM_STRIDE_X) && must_be_zero == 0 &&
               payload_size >= 1 && payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_IFM_STRIDE_X);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_ifm_stride_x_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_ifm_stride_x_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_ifm_stride_x_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set IFM byte stride between vertical values
struct npu_set_ifm_stride_y_t
{
    uint32_t cmd_code : 10;    // NPU_SET_IFM_STRIDE_Y
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t reserved0 : 16;
    uint32_t data : 32; // IFM byte stride between vertical values
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_IFM_STRIDE_Y) && must_be_zero == 0 &&
               payload_size >= 1 && payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_IFM_STRIDE_Y);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_ifm_stride_y_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_ifm_stride_y_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_ifm_stride_y_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set IFM byte stride between channel blocks (of 16 bytes each block)
struct npu_set_ifm_stride_c_t
{
    uint32_t cmd_code : 10;    // NPU_SET_IFM_STRIDE_C
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t reserved0 : 16;
    uint32_t data : 32; // IFM byte stride between channel blocks (of 16 bytes each block)
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_IFM_STRIDE_C) && must_be_zero == 0 &&
               payload_size >= 1 && payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_IFM_STRIDE_C);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_ifm_stride_c_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_ifm_stride_c_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_ifm_stride_c_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set OFM base address (top left tile)
struct npu_set_ofm_base0_t
{
    uint32_t cmd_code : 10;    // NPU_SET_OFM_BASE0
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t reserved0 : 16;
    uint32_t data : 32; // OFM base address (top left tile)
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_OFM_BASE0) && must_be_zero == 0 && payload_size >= 1 &&
               payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_OFM_BASE0);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_ofm_base0_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_ofm_base0_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_ofm_base0_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set OFM base address (top right tile)
struct npu_set_ofm_base1_t
{
    uint32_t cmd_code : 10;    // NPU_SET_OFM_BASE1
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t reserved0 : 16;
    uint32_t data : 32; // OFM base address (top right tile)
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_OFM_BASE1) && must_be_zero == 0 && payload_size >= 1 &&
               payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_OFM_BASE1);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_ofm_base1_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_ofm_base1_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_ofm_base1_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set OFM base address (bottom left tile)
struct npu_set_ofm_base2_t
{
    uint32_t cmd_code : 10;    // NPU_SET_OFM_BASE2
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t reserved0 : 16;
    uint32_t data : 32; // OFM base address (bottom left tile)
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_OFM_BASE2) && must_be_zero == 0 && payload_size >= 1 &&
               payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_OFM_BASE2);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_ofm_base2_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_ofm_base2_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_ofm_base2_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set OFM base address (bottom right tile)
struct npu_set_ofm_base3_t
{
    uint32_t cmd_code : 10;    // NPU_SET_OFM_BASE3
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t reserved0 : 16;
    uint32_t data : 32; // OFM base address (bottom right tile)
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_OFM_BASE3) && must_be_zero == 0 && payload_size >= 1 &&
               payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_OFM_BASE3);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_ofm_base3_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_ofm_base3_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_ofm_base3_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set OFM byte stride between horizontal values
struct npu_set_ofm_stride_x_t
{
    uint32_t cmd_code : 10;    // NPU_SET_OFM_STRIDE_X
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t reserved0 : 16;
    uint32_t data : 32; // OFM byte stride between horizontal values
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_OFM_STRIDE_X) && must_be_zero == 0 &&
               payload_size >= 1 && payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_OFM_STRIDE_X);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_ofm_stride_x_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_ofm_stride_x_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_ofm_stride_x_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set OFM byte stride between vertical values
struct npu_set_ofm_stride_y_t
{
    uint32_t cmd_code : 10;    // NPU_SET_OFM_STRIDE_Y
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t reserved0 : 16;
    uint32_t data : 32; // OFM byte stride between vertical values
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_OFM_STRIDE_Y) && must_be_zero == 0 &&
               payload_size >= 1 && payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_OFM_STRIDE_Y);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_ofm_stride_y_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_ofm_stride_y_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_ofm_stride_y_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set OFM byte stride between channel blocks (of 16 bytes each block)
struct npu_set_ofm_stride_c_t
{
    uint32_t cmd_code : 10;    // NPU_SET_OFM_STRIDE_C
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t reserved0 : 16;
    uint32_t data : 32; // OFM byte stride between channel blocks (of 16 bytes each block)
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_OFM_STRIDE_C) && must_be_zero == 0 &&
               payload_size >= 1 && payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_OFM_STRIDE_C);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_ofm_stride_c_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_ofm_stride_c_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_ofm_stride_c_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set Weight stream input base address
struct npu_set_weight_base_t
{
    uint32_t cmd_code : 10;    // NPU_SET_WEIGHT_BASE
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t reserved0 : 16;
    uint32_t data : 32; // Weight stream input base address
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_WEIGHT_BASE) && must_be_zero == 0 && payload_size >= 1 &&
               payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_WEIGHT_BASE);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_weight_base_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_weight_base_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_weight_base_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set Weight stream length
struct npu_set_weight_length_t
{
    uint32_t cmd_code : 10;    // NPU_SET_WEIGHT_LENGTH
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t reserved0 : 16;
    uint32_t data : 32; // Weight stream length
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_WEIGHT_LENGTH) && must_be_zero == 0 &&
               payload_size >= 1 && payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_WEIGHT_LENGTH);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_weight_length_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_weight_length_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_weight_length_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set Scale and bias stream input base address
struct npu_set_scale_base_t
{
    uint32_t cmd_code : 10;    // NPU_SET_SCALE_BASE
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t reserved0 : 16;
    uint32_t data : 32; // Scale and bias stream input base address
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_SCALE_BASE) && must_be_zero == 0 && payload_size >= 1 &&
               payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_SCALE_BASE);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_scale_base_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_scale_base_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_scale_base_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set Scale and bias stream input length
struct npu_set_scale_length_t
{
    uint32_t cmd_code : 10;    // NPU_SET_SCALE_LENGTH
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t reserved0 : 16;
    uint32_t data : 32; // Scale and bias stream input length
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_SCALE_LENGTH) && must_be_zero == 0 &&
               payload_size >= 1 && payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_SCALE_LENGTH);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_scale_length_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_scale_length_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_scale_length_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set scale (32-bit). Used by average pool with pad=0, elementwise MUL, ADD, SUB
struct npu_set_ofm_scale_t
{
    uint32_t cmd_code : 10;    // NPU_SET_OFM_SCALE
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t shift : 16;
    uint32_t data : 32; // scale (32-bit). Used by average pool with pad=0, elementwise MUL, ADD, SUB
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_OFM_SCALE) && must_be_zero == 0 && payload_size >= 1 &&
               payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_OFM_SCALE);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_ofm_scale_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_ofm_scale_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_ofm_scale_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_shift() const
    {
        return static_cast<uint32_t>(shift);
    }
    CONSTEXPR npu_set_ofm_scale_t &set_shift(uint32_t value)
    {
        shift = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set scale (32-bit) used for elementwise ADD/SUB OPA prescale. If IFM scale mode is 0 then shift is ignored and scale
// is 16-bit. If IFM scale mode is 1 or 2 then shift is 6-bit and scale is 32-bit
struct npu_set_opa_scale_t
{
    uint32_t cmd_code : 10;    // NPU_SET_OPA_SCALE
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t shift : 16;
    uint32_t
        data : 32; // scale (32-bit) used for elementwise ADD/SUB OPA prescale. If IFM scale mode is 0 then shift is
                   // ignored and scale is 16-bit. If IFM scale mode is 1 or 2 then shift is 6-bit and scale is 32-bit
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_OPA_SCALE) && must_be_zero == 0 && payload_size >= 1 &&
               payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_OPA_SCALE);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_opa_scale_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_opa_scale_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_opa_scale_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_shift() const
    {
        return static_cast<uint32_t>(shift);
    }
    CONSTEXPR npu_set_opa_scale_t &set_shift(uint32_t value)
    {
        shift = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set scale (16-bit) used for elementwise ADD/SUB OPB prescale. If IFM scale mode is 0 then scale is 16-bit. If IFM
// scale mode is 1 or 2 then this register is not used
struct npu_set_opb_scale_t
{
    uint32_t cmd_code : 10;    // NPU_SET_OPB_SCALE
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t reserved0 : 16;
    uint32_t data : 32; // scale (16-bit) used for elementwise ADD/SUB OPB prescale. If IFM scale mode is 0 then scale
                        // is 16-bit. If IFM scale mode is 1 or 2 then this register is not used
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_OPB_SCALE) && must_be_zero == 0 && payload_size >= 1 &&
               payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_OPB_SCALE);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_opb_scale_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_opb_scale_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_opb_scale_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set DMA source address
struct npu_set_dma0_src_t
{
    uint32_t cmd_code : 10;    // NPU_SET_DMA0_SRC
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t reserved0 : 16;
    uint32_t data : 32;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_DMA0_SRC) && must_be_zero == 0 && payload_size >= 1 &&
               payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_DMA0_SRC);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_dma0_src_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_dma0_src_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_dma0_src_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set DMA destination address
struct npu_set_dma0_dst_t
{
    uint32_t cmd_code : 10;    // NPU_SET_DMA0_DST
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t reserved0 : 16;
    uint32_t data : 32;
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_DMA0_DST) && must_be_zero == 0 && payload_size >= 1 &&
               payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_DMA0_DST);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_dma0_dst_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_dma0_dst_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_dma0_dst_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set DMA length
struct npu_set_dma0_len_t
{
    uint32_t cmd_code : 10;    // NPU_SET_DMA0_LEN
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t reserved0 : 16;
    uint32_t data : 32; // DMA length
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_DMA0_LEN) && must_be_zero == 0 && payload_size >= 1 &&
               payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_DMA0_LEN);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_dma0_len_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_dma0_len_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_dma0_len_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set Byte distance to skip after inner size (2D/3D mode)
struct npu_set_dma0_skip0_t
{
    uint32_t cmd_code : 10;    // NPU_SET_DMA0_SKIP0
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t param : 16;
    uint32_t data : 32; // Byte distance to skip after inner size (2D/3D mode)
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_DMA0_SKIP0) && must_be_zero == 0 && payload_size >= 1 &&
               payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_DMA0_SKIP0);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_dma0_skip0_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_dma0_skip0_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_dma0_skip0_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_dma0_skip0_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set Byte distance to skip after outer size (3D mode)
struct npu_set_dma0_skip1_t
{
    uint32_t cmd_code : 10;    // NPU_SET_DMA0_SKIP1
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t param : 16;
    uint32_t data : 32; // Byte distance to skip after outer size (3D mode)
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_DMA0_SKIP1) && must_be_zero == 0 && payload_size >= 1 &&
               payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_DMA0_SKIP1);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_dma0_skip1_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_dma0_skip1_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_dma0_skip1_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_dma0_skip1_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set IFM2 tile0 offset (top left tile) from IFM_REGION start
struct npu_set_ifm2_base0_t
{
    uint32_t cmd_code : 10;    // NPU_SET_IFM2_BASE0
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t reserved0 : 16;
    uint32_t data : 32; // IFM2 tile0 offset (top left tile) from IFM_REGION start
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_IFM2_BASE0) && must_be_zero == 0 && payload_size >= 1 &&
               payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_IFM2_BASE0);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_ifm2_base0_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_ifm2_base0_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_ifm2_base0_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set IFM2 tile1 offset (top right tile) from IFM_REGION start
struct npu_set_ifm2_base1_t
{
    uint32_t cmd_code : 10;    // NPU_SET_IFM2_BASE1
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t reserved0 : 16;
    uint32_t data : 32; // IFM2 tile1 offset (top right tile) from IFM_REGION start
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_IFM2_BASE1) && must_be_zero == 0 && payload_size >= 1 &&
               payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_IFM2_BASE1);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_ifm2_base1_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_ifm2_base1_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_ifm2_base1_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set IFM2 tile2 offset (bottom left tile) from IFM_REGION start
struct npu_set_ifm2_base2_t
{
    uint32_t cmd_code : 10;    // NPU_SET_IFM2_BASE2
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t reserved0 : 16;
    uint32_t data : 32; // IFM2 tile2 offset (bottom left tile) from IFM_REGION start
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_IFM2_BASE2) && must_be_zero == 0 && payload_size >= 1 &&
               payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_IFM2_BASE2);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_ifm2_base2_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_ifm2_base2_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_ifm2_base2_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set IFM2 tile3 offset (bottom right tile) from IFM_REGION start
struct npu_set_ifm2_base3_t
{
    uint32_t cmd_code : 10;    // NPU_SET_IFM2_BASE3
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t reserved0 : 16;
    uint32_t data : 32; // IFM2 tile3 offset (bottom right tile) from IFM_REGION start
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_IFM2_BASE3) && must_be_zero == 0 && payload_size >= 1 &&
               payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_IFM2_BASE3);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_ifm2_base3_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_ifm2_base3_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_ifm2_base3_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set IFM2 byte stride between horizontal values
struct npu_set_ifm2_stride_x_t
{
    uint32_t cmd_code : 10;    // NPU_SET_IFM2_STRIDE_X
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t reserved0 : 16;
    uint32_t data : 32; // IFM2 byte stride between horizontal values
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_IFM2_STRIDE_X) && must_be_zero == 0 &&
               payload_size >= 1 && payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_IFM2_STRIDE_X);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_ifm2_stride_x_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_ifm2_stride_x_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_ifm2_stride_x_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set IFM2 byte stride between vertical values
struct npu_set_ifm2_stride_y_t
{
    uint32_t cmd_code : 10;    // NPU_SET_IFM2_STRIDE_Y
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t reserved0 : 16;
    uint32_t data : 32; // IFM2 byte stride between vertical values
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_IFM2_STRIDE_Y) && must_be_zero == 0 &&
               payload_size >= 1 && payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_IFM2_STRIDE_Y);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_ifm2_stride_y_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_ifm2_stride_y_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_ifm2_stride_y_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set IFM2 byte stride between channel blocks (of 16 bytes each block)
struct npu_set_ifm2_stride_c_t
{
    uint32_t cmd_code : 10;    // NPU_SET_IFM2_STRIDE_C
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t reserved0 : 16;
    uint32_t data : 32; // IFM2 byte stride between channel blocks (of 16 bytes each block)
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_IFM2_STRIDE_C) && must_be_zero == 0 &&
               payload_size >= 1 && payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_IFM2_STRIDE_C);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_ifm2_stride_c_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_ifm2_stride_c_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_ifm2_stride_c_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set Weight stream byte offset in WEIGHT_REGION
struct npu_set_weight1_base_t
{
    uint32_t cmd_code : 10;    // NPU_SET_WEIGHT1_BASE
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t param : 16;
    uint32_t data : 32; // Weight stream byte offset in WEIGHT_REGION
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_WEIGHT1_BASE) && must_be_zero == 0 &&
               payload_size >= 1 && payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_WEIGHT1_BASE);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_weight1_base_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_weight1_base_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_weight1_base_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_weight1_base_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set Weight stream byte length (unsigned 32 bits)
struct npu_set_weight1_length_t
{
    uint32_t cmd_code : 10;    // NPU_SET_WEIGHT1_LENGTH
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t reserved0 : 16;
    uint32_t data : 32; // Weight stream byte length (unsigned 32 bits)
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_WEIGHT1_LENGTH) && must_be_zero == 0 &&
               payload_size >= 1 && payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_WEIGHT1_LENGTH);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_weight1_length_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_weight1_length_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_weight1_length_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set Scale and bias stream input byte offset from SCALE_REGION
struct npu_set_scale1_base_t
{
    uint32_t cmd_code : 10;    // NPU_SET_SCALE1_BASE
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t param : 16;
    uint32_t data : 32; // Scale and bias stream input byte offset from SCALE_REGION
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_SCALE1_BASE) && must_be_zero == 0 && payload_size >= 1 &&
               payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_SCALE1_BASE);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_scale1_base_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_scale1_base_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_param() const
    {
        return static_cast<uint32_t>(param);
    }
    CONSTEXPR npu_set_scale1_base_t &set_param(uint32_t value)
    {
        param = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_scale1_base_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

// Set Scale and bias stream input byte length (unsigned 20 bits)
struct npu_set_scale1_length_t
{
    uint32_t cmd_code : 10;    // NPU_SET_SCALE1_LENGTH
    uint32_t must_be_zero : 4; // 0
    uint32_t payload_size : 2; // Min:1 Max:2
    uint32_t reserved0 : 16;
    uint32_t data : 32; // Scale and bias stream input byte length (unsigned 20 bits)
#ifdef __cplusplus
    CONSTEXPR bool valid() const
    {
        return cmd_code == static_cast<uint32_t>(cmd1::NPU_SET_SCALE1_LENGTH) && must_be_zero == 0 &&
               payload_size >= 1 && payload_size <= 2;
    }
    CONSTEXPR void init()
    {
        cmd_code     = static_cast<uint32_t>(cmd1::NPU_SET_SCALE1_LENGTH);
        must_be_zero = 0;
        payload_size = 1;
    }
    CONSTEXPR ::cmd1 get_cmd_code() const
    {
        return static_cast<::cmd1>(cmd_code);
    }
    CONSTEXPR npu_set_scale1_length_t &set_cmd_code(::cmd1 value)
    {
        cmd_code = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_data() const
    {
        return static_cast<uint32_t>(data);
    }
    CONSTEXPR npu_set_scale1_length_t &set_data(uint32_t value)
    {
        data = static_cast<uint32_t>(value);
        return *this;
    }
    CONSTEXPR uint32_t get_payload_size() const
    {
        return static_cast<uint32_t>(payload_size);
    }
    CONSTEXPR npu_set_scale1_length_t &set_payload_size(uint32_t value)
    {
        payload_size = static_cast<uint32_t>(value);
        return *this;
    }
#endif //__cplusplus
};

#define NPU_DATA_STRUCTS                                                                                               \
    NPU_STRUCT(command_no_payload)                                                                                     \
    NPU_STRUCT(command_with_payload)                                                                                   \
    NPU_STRUCT(npu_op_stop)                                                                                            \
    NPU_STRUCT(npu_op_irq)                                                                                             \
    NPU_STRUCT(npu_op_conv)                                                                                            \
    NPU_STRUCT(npu_op_depthwise)                                                                                       \
    NPU_STRUCT(npu_op_pool)                                                                                            \
    NPU_STRUCT(npu_op_elementwise)                                                                                     \
    NPU_STRUCT(npu_op_dma_start)                                                                                       \
    NPU_STRUCT(npu_op_dma_wait)                                                                                        \
    NPU_STRUCT(npu_op_kernel_wait)                                                                                     \
    NPU_STRUCT(npu_op_pmu_mask)                                                                                        \
    NPU_STRUCT(npu_set_ifm_pad_top)                                                                                    \
    NPU_STRUCT(npu_set_ifm_pad_left)                                                                                   \
    NPU_STRUCT(npu_set_ifm_pad_right)                                                                                  \
    NPU_STRUCT(npu_set_ifm_pad_bottom)                                                                                 \
    NPU_STRUCT(npu_set_ifm_depth_m1)                                                                                   \
    NPU_STRUCT(npu_set_ifm_precision)                                                                                  \
    NPU_STRUCT(npu_set_ifm_upscale)                                                                                    \
    NPU_STRUCT(npu_set_ifm_zero_point)                                                                                 \
    NPU_STRUCT(npu_set_ifm_width0_m1)                                                                                  \
    NPU_STRUCT(npu_set_ifm_height0_m1)                                                                                 \
    NPU_STRUCT(npu_set_ifm_height1_m1)                                                                                 \
    NPU_STRUCT(npu_set_ifm_ib_end)                                                                                     \
    NPU_STRUCT(npu_set_ifm_region)                                                                                     \
    NPU_STRUCT(npu_set_ofm_width_m1)                                                                                   \
    NPU_STRUCT(npu_set_ofm_height_m1)                                                                                  \
    NPU_STRUCT(npu_set_ofm_depth_m1)                                                                                   \
    NPU_STRUCT(npu_set_ofm_precision)                                                                                  \
    NPU_STRUCT(npu_set_ofm_blk_width_m1)                                                                               \
    NPU_STRUCT(npu_set_ofm_blk_height_m1)                                                                              \
    NPU_STRUCT(npu_set_ofm_blk_depth_m1)                                                                               \
    NPU_STRUCT(npu_set_ofm_zero_point)                                                                                 \
    NPU_STRUCT(npu_set_ofm_width0_m1)                                                                                  \
    NPU_STRUCT(npu_set_ofm_height0_m1)                                                                                 \
    NPU_STRUCT(npu_set_ofm_height1_m1)                                                                                 \
    NPU_STRUCT(npu_set_ofm_region)                                                                                     \
    NPU_STRUCT(npu_set_kernel_width_m1)                                                                                \
    NPU_STRUCT(npu_set_kernel_height_m1)                                                                               \
    NPU_STRUCT(npu_set_kernel_stride)                                                                                  \
    NPU_STRUCT(npu_set_parallel_mode)                                                                                  \
    NPU_STRUCT(npu_set_acc_format)                                                                                     \
    NPU_STRUCT(npu_set_activation)                                                                                     \
    NPU_STRUCT(npu_set_activation_min)                                                                                 \
    NPU_STRUCT(npu_set_activation_max)                                                                                 \
    NPU_STRUCT(npu_set_weight_region)                                                                                  \
    NPU_STRUCT(npu_set_scale_region)                                                                                   \
    NPU_STRUCT(npu_set_ab_start)                                                                                       \
    NPU_STRUCT(npu_set_blockdep)                                                                                       \
    NPU_STRUCT(npu_set_dma0_src_region)                                                                                \
    NPU_STRUCT(npu_set_dma0_dst_region)                                                                                \
    NPU_STRUCT(npu_set_dma0_size0)                                                                                     \
    NPU_STRUCT(npu_set_dma0_size1)                                                                                     \
    NPU_STRUCT(npu_set_ifm2_broadcast)                                                                                 \
    NPU_STRUCT(npu_set_ifm2_scalar)                                                                                    \
    NPU_STRUCT(npu_set_ifm2_precision)                                                                                 \
    NPU_STRUCT(npu_set_ifm2_zero_point)                                                                                \
    NPU_STRUCT(npu_set_ifm2_width0_m1)                                                                                 \
    NPU_STRUCT(npu_set_ifm2_height0_m1)                                                                                \
    NPU_STRUCT(npu_set_ifm2_height1_m1)                                                                                \
    NPU_STRUCT(npu_set_ifm2_ib_start)                                                                                  \
    NPU_STRUCT(npu_set_ifm2_region)                                                                                    \
    NPU_STRUCT(npu_set_ifm_base0)                                                                                      \
    NPU_STRUCT(npu_set_ifm_base1)                                                                                      \
    NPU_STRUCT(npu_set_ifm_base2)                                                                                      \
    NPU_STRUCT(npu_set_ifm_base3)                                                                                      \
    NPU_STRUCT(npu_set_ifm_stride_x)                                                                                   \
    NPU_STRUCT(npu_set_ifm_stride_y)                                                                                   \
    NPU_STRUCT(npu_set_ifm_stride_c)                                                                                   \
    NPU_STRUCT(npu_set_ofm_base0)                                                                                      \
    NPU_STRUCT(npu_set_ofm_base1)                                                                                      \
    NPU_STRUCT(npu_set_ofm_base2)                                                                                      \
    NPU_STRUCT(npu_set_ofm_base3)                                                                                      \
    NPU_STRUCT(npu_set_ofm_stride_x)                                                                                   \
    NPU_STRUCT(npu_set_ofm_stride_y)                                                                                   \
    NPU_STRUCT(npu_set_ofm_stride_c)                                                                                   \
    NPU_STRUCT(npu_set_weight_base)                                                                                    \
    NPU_STRUCT(npu_set_weight_length)                                                                                  \
    NPU_STRUCT(npu_set_scale_base)                                                                                     \
    NPU_STRUCT(npu_set_scale_length)                                                                                   \
    NPU_STRUCT(npu_set_ofm_scale)                                                                                      \
    NPU_STRUCT(npu_set_opa_scale)                                                                                      \
    NPU_STRUCT(npu_set_opb_scale)                                                                                      \
    NPU_STRUCT(npu_set_dma0_src)                                                                                       \
    NPU_STRUCT(npu_set_dma0_dst)                                                                                       \
    NPU_STRUCT(npu_set_dma0_len)                                                                                       \
    NPU_STRUCT(npu_set_dma0_skip0)                                                                                     \
    NPU_STRUCT(npu_set_dma0_skip1)                                                                                     \
    NPU_STRUCT(npu_set_ifm2_base0)                                                                                     \
    NPU_STRUCT(npu_set_ifm2_base1)                                                                                     \
    NPU_STRUCT(npu_set_ifm2_base2)                                                                                     \
    NPU_STRUCT(npu_set_ifm2_base3)                                                                                     \
    NPU_STRUCT(npu_set_ifm2_stride_x)                                                                                  \
    NPU_STRUCT(npu_set_ifm2_stride_y)                                                                                  \
    NPU_STRUCT(npu_set_ifm2_stride_c)                                                                                  \
    NPU_STRUCT(npu_set_weight1_base)                                                                                   \
    NPU_STRUCT(npu_set_weight1_length)                                                                                 \
    NPU_STRUCT(npu_set_scale1_base)                                                                                    \
    NPU_STRUCT(npu_set_scale1_length)
#define NPU_OP_STRUCTS                                                                                                 \
    NPU_OP_(stop)                                                                                                      \
    NPU_OP_(irq)                                                                                                       \
    NPU_OP_(conv)                                                                                                      \
    NPU_OP_(depthwise)                                                                                                 \
    NPU_OP_(pool)                                                                                                      \
    NPU_OP_(elementwise)                                                                                               \
    NPU_OP_(dma_start)                                                                                                 \
    NPU_OP_(dma_wait)                                                                                                  \
    NPU_OP_(kernel_wait)                                                                                               \
    NPU_OP_(pmu_mask)
#define NPU_SET_STRUCTS                                                                                                \
    NPU_SET_(ifm_pad_top)                                                                                              \
    NPU_SET_(ifm_pad_left)                                                                                             \
    NPU_SET_(ifm_pad_right)                                                                                            \
    NPU_SET_(ifm_pad_bottom)                                                                                           \
    NPU_SET_(ifm_depth_m1)                                                                                             \
    NPU_SET_(ifm_precision)                                                                                            \
    NPU_SET_(ifm_upscale)                                                                                              \
    NPU_SET_(ifm_zero_point)                                                                                           \
    NPU_SET_(ifm_width0_m1)                                                                                            \
    NPU_SET_(ifm_height0_m1)                                                                                           \
    NPU_SET_(ifm_height1_m1)                                                                                           \
    NPU_SET_(ifm_ib_end)                                                                                               \
    NPU_SET_(ifm_region)                                                                                               \
    NPU_SET_(ofm_width_m1)                                                                                             \
    NPU_SET_(ofm_height_m1)                                                                                            \
    NPU_SET_(ofm_depth_m1)                                                                                             \
    NPU_SET_(ofm_precision)                                                                                            \
    NPU_SET_(ofm_blk_width_m1)                                                                                         \
    NPU_SET_(ofm_blk_height_m1)                                                                                        \
    NPU_SET_(ofm_blk_depth_m1)                                                                                         \
    NPU_SET_(ofm_zero_point)                                                                                           \
    NPU_SET_(ofm_width0_m1)                                                                                            \
    NPU_SET_(ofm_height0_m1)                                                                                           \
    NPU_SET_(ofm_height1_m1)                                                                                           \
    NPU_SET_(ofm_region)                                                                                               \
    NPU_SET_(kernel_width_m1)                                                                                          \
    NPU_SET_(kernel_height_m1)                                                                                         \
    NPU_SET_(kernel_stride)                                                                                            \
    NPU_SET_(parallel_mode)                                                                                            \
    NPU_SET_(acc_format)                                                                                               \
    NPU_SET_(activation)                                                                                               \
    NPU_SET_(activation_min)                                                                                           \
    NPU_SET_(activation_max)                                                                                           \
    NPU_SET_(weight_region)                                                                                            \
    NPU_SET_(scale_region)                                                                                             \
    NPU_SET_(ab_start)                                                                                                 \
    NPU_SET_(blockdep)                                                                                                 \
    NPU_SET_(dma0_src_region)                                                                                          \
    NPU_SET_(dma0_dst_region)                                                                                          \
    NPU_SET_(dma0_size0)                                                                                               \
    NPU_SET_(dma0_size1)                                                                                               \
    NPU_SET_(ifm2_broadcast)                                                                                           \
    NPU_SET_(ifm2_scalar)                                                                                              \
    NPU_SET_(ifm2_precision)                                                                                           \
    NPU_SET_(ifm2_zero_point)                                                                                          \
    NPU_SET_(ifm2_width0_m1)                                                                                           \
    NPU_SET_(ifm2_height0_m1)                                                                                          \
    NPU_SET_(ifm2_height1_m1)                                                                                          \
    NPU_SET_(ifm2_ib_start)                                                                                            \
    NPU_SET_(ifm2_region)                                                                                              \
    NPU_SET_(ifm_base0)                                                                                                \
    NPU_SET_(ifm_base1)                                                                                                \
    NPU_SET_(ifm_base2)                                                                                                \
    NPU_SET_(ifm_base3)                                                                                                \
    NPU_SET_(ifm_stride_x)                                                                                             \
    NPU_SET_(ifm_stride_y)                                                                                             \
    NPU_SET_(ifm_stride_c)                                                                                             \
    NPU_SET_(ofm_base0)                                                                                                \
    NPU_SET_(ofm_base1)                                                                                                \
    NPU_SET_(ofm_base2)                                                                                                \
    NPU_SET_(ofm_base3)                                                                                                \
    NPU_SET_(ofm_stride_x)                                                                                             \
    NPU_SET_(ofm_stride_y)                                                                                             \
    NPU_SET_(ofm_stride_c)                                                                                             \
    NPU_SET_(weight_base)                                                                                              \
    NPU_SET_(weight_length)                                                                                            \
    NPU_SET_(scale_base)                                                                                               \
    NPU_SET_(scale_length)                                                                                             \
    NPU_SET_(ofm_scale)                                                                                                \
    NPU_SET_(opa_scale)                                                                                                \
    NPU_SET_(opb_scale)                                                                                                \
    NPU_SET_(dma0_src)                                                                                                 \
    NPU_SET_(dma0_dst)                                                                                                 \
    NPU_SET_(dma0_len)                                                                                                 \
    NPU_SET_(dma0_skip0)                                                                                               \
    NPU_SET_(dma0_skip1)                                                                                               \
    NPU_SET_(ifm2_base0)                                                                                               \
    NPU_SET_(ifm2_base1)                                                                                               \
    NPU_SET_(ifm2_base2)                                                                                               \
    NPU_SET_(ifm2_base3)                                                                                               \
    NPU_SET_(ifm2_stride_x)                                                                                            \
    NPU_SET_(ifm2_stride_y)                                                                                            \
    NPU_SET_(ifm2_stride_c)                                                                                            \
    NPU_SET_(weight1_base)                                                                                             \
    NPU_SET_(weight1_length)                                                                                           \
    NPU_SET_(scale1_base)                                                                                              \
    NPU_SET_(scale1_length)
#define COMMAND_STRUCTS                                                                                                \
    COMMAND_(no_payload)                                                                                               \
    COMMAND_(with_payload)

#define EXPAND_ACC_FORMAT(FUNC, SEP)                                                                                   \
    FUNC(acc_format, INT_32BIT) SEP FUNC(acc_format, INT_40BIT) SEP FUNC(acc_format, FP_S5_10)

#define EXPAND_ACTIVATION(FUNC, SEP)                                                                                   \
    FUNC(activation, NONE)                                                                                             \
    SEP FUNC(activation, TANH) SEP FUNC(activation, SIGMOID) SEP FUNC(activation, LUT_START)                           \
        SEP FUNC(activation, LUT_END)

#define EXPAND_CLIP_RANGE(FUNC, SEP)                                                                                   \
    FUNC(clip_range, OFM_PRECISION)                                                                                    \
    SEP FUNC(clip_range, FORCE_UINT8) SEP FUNC(clip_range, FORCE_INT8) SEP FUNC(clip_range, FORCE_INT16)

#define EXPAND_CMD0(FUNC, SEP)                                                                                         \
    FUNC(cmd0, NPU_OP_STOP)                                                                                            \
    SEP FUNC(cmd0, NPU_OP_IRQ) SEP FUNC(cmd0, NPU_OP_CONV) SEP FUNC(cmd0, NPU_OP_DEPTHWISE) SEP FUNC(                  \
        cmd0, NPU_OP_POOL) SEP FUNC(cmd0, NPU_OP_ELEMENTWISE) SEP FUNC(cmd0, NPU_OP_DMA_START)                         \
        SEP FUNC(cmd0, NPU_OP_DMA_WAIT) SEP FUNC(cmd0, NPU_OP_KERNEL_WAIT) SEP FUNC(cmd0, NPU_OP_PMU_MASK) SEP FUNC(   \
            cmd0, NPU_SET_IFM_PAD_TOP) SEP FUNC(cmd0, NPU_SET_IFM_PAD_LEFT) SEP FUNC(cmd0, NPU_SET_IFM_PAD_RIGHT)      \
            SEP FUNC(cmd0, NPU_SET_IFM_PAD_BOTTOM) SEP FUNC(cmd0, NPU_SET_IFM_DEPTH_M1) SEP FUNC(                      \
                cmd0, NPU_SET_IFM_PRECISION) SEP FUNC(cmd0, NPU_SET_IFM_UPSCALE)                                       \
                SEP FUNC(cmd0, NPU_SET_IFM_ZERO_POINT) SEP FUNC(cmd0, NPU_SET_IFM_WIDTH0_M1) SEP FUNC(                 \
                    cmd0, NPU_SET_IFM_HEIGHT0_M1) SEP FUNC(cmd0, NPU_SET_IFM_HEIGHT1_M1) SEP FUNC(cmd0,                \
                                                                                                  NPU_SET_IFM_IB_END)  \
                    SEP FUNC(cmd0, NPU_SET_IFM_REGION) SEP FUNC(cmd0, NPU_SET_OFM_WIDTH_M1) SEP FUNC(                  \
                        cmd0, NPU_SET_OFM_HEIGHT_M1) SEP FUNC(cmd0, NPU_SET_OFM_DEPTH_M1)                              \
                        SEP FUNC(cmd0, NPU_SET_OFM_PRECISION) SEP FUNC(cmd0, NPU_SET_OFM_BLK_WIDTH_M1) SEP FUNC(       \
                            cmd0, NPU_SET_OFM_BLK_HEIGHT_M1) SEP FUNC(cmd0, NPU_SET_OFM_BLK_DEPTH_M1)                  \
                            SEP FUNC(cmd0, NPU_SET_OFM_ZERO_POINT) SEP FUNC(cmd0, NPU_SET_OFM_WIDTH0_M1) SEP FUNC(     \
                                cmd0, NPU_SET_OFM_HEIGHT0_M1) SEP FUNC(cmd0, NPU_SET_OFM_HEIGHT1_M1)                   \
                                SEP FUNC(cmd0, NPU_SET_OFM_REGION) SEP FUNC(cmd0, NPU_SET_KERNEL_WIDTH_M1) SEP FUNC(   \
                                    cmd0, NPU_SET_KERNEL_HEIGHT_M1) SEP FUNC(cmd0, NPU_SET_KERNEL_STRIDE)              \
                                    SEP FUNC(cmd0, NPU_SET_PARALLEL_MODE) SEP FUNC(cmd0, NPU_SET_ACC_FORMAT) SEP FUNC( \
                                        cmd0, NPU_SET_ACTIVATION) SEP FUNC(cmd0, NPU_SET_ACTIVATION_MIN)               \
                                        SEP FUNC(cmd0, NPU_SET_ACTIVATION_MAX) SEP FUNC(cmd0, NPU_SET_WEIGHT_REGION)   \
                                            SEP FUNC(cmd0, NPU_SET_SCALE_REGION) SEP FUNC(cmd0, NPU_SET_AB_START)      \
                                                SEP FUNC(cmd0,                                                         \
                                                         NPU_SET_BLOCKDEP) SEP FUNC(cmd0, NPU_SET_DMA0_SRC_REGION)     \
                                                    SEP FUNC(cmd0, NPU_SET_DMA0_DST_REGION) SEP FUNC(                  \
                                                        cmd0, NPU_SET_DMA0_SIZE0) SEP FUNC(cmd0, NPU_SET_DMA0_SIZE1)   \
                                                        SEP FUNC(cmd0, NPU_SET_IFM2_BROADCAST)                         \
                                                            SEP FUNC(cmd0, NPU_SET_IFM2_SCALAR)                        \
                                                                SEP FUNC(cmd0, NPU_SET_IFM2_PRECISION) SEP FUNC(       \
                                                                    cmd0, NPU_SET_IFM2_ZERO_POINT)                     \
                                                                    SEP FUNC(cmd0, NPU_SET_IFM2_WIDTH0_M1) SEP FUNC(   \
                                                                        cmd0, NPU_SET_IFM2_HEIGHT0_M1)                 \
                                                                        SEP FUNC(cmd0, NPU_SET_IFM2_HEIGHT1_M1)        \
                                                                            SEP FUNC(cmd0, NPU_SET_IFM2_IB_START)      \
                                                                                SEP FUNC(cmd0, NPU_SET_IFM2_REGION)

#define EXPAND_CMD1(FUNC, SEP)                                                                                         \
    FUNC(cmd1, NPU_SET_IFM_BASE0)                                                                                      \
    SEP FUNC(cmd1, NPU_SET_IFM_BASE1) SEP FUNC(cmd1, NPU_SET_IFM_BASE2) SEP FUNC(cmd1, NPU_SET_IFM_BASE3)              \
        SEP FUNC(cmd1, NPU_SET_IFM_STRIDE_X) SEP FUNC(cmd1, NPU_SET_IFM_STRIDE_Y) SEP FUNC(cmd1, NPU_SET_IFM_STRIDE_C) \
            SEP FUNC(cmd1, NPU_SET_OFM_BASE0) SEP FUNC(cmd1, NPU_SET_OFM_BASE1) SEP FUNC(cmd1, NPU_SET_OFM_BASE2)      \
                SEP FUNC(cmd1, NPU_SET_OFM_BASE3) SEP FUNC(cmd1, NPU_SET_OFM_STRIDE_X)                                 \
                    SEP FUNC(cmd1, NPU_SET_OFM_STRIDE_Y) SEP FUNC(cmd1, NPU_SET_OFM_STRIDE_C)                          \
                        SEP FUNC(cmd1, NPU_SET_WEIGHT_BASE) SEP FUNC(cmd1, NPU_SET_WEIGHT_LENGTH)                      \
                            SEP FUNC(cmd1, NPU_SET_SCALE_BASE) SEP FUNC(cmd1, NPU_SET_SCALE_LENGTH)                    \
                                SEP FUNC(cmd1, NPU_SET_OFM_SCALE) SEP FUNC(cmd1, NPU_SET_OPA_SCALE)                    \
                                    SEP FUNC(cmd1, NPU_SET_OPB_SCALE) SEP FUNC(cmd1, NPU_SET_DMA0_SRC)                 \
                                        SEP FUNC(cmd1, NPU_SET_DMA0_DST) SEP FUNC(cmd1, NPU_SET_DMA0_LEN) SEP FUNC(    \
                                            cmd1, NPU_SET_DMA0_SKIP0) SEP FUNC(cmd1, NPU_SET_DMA0_SKIP1)               \
                                            SEP FUNC(cmd1, NPU_SET_IFM2_BASE0) SEP FUNC(cmd1, NPU_SET_IFM2_BASE1)      \
                                                SEP FUNC(cmd1, NPU_SET_IFM2_BASE2) SEP FUNC(cmd1, NPU_SET_IFM2_BASE3)  \
                                                    SEP FUNC(cmd1, NPU_SET_IFM2_STRIDE_X)                              \
                                                        SEP FUNC(cmd1, NPU_SET_IFM2_STRIDE_Y)                          \
                                                            SEP FUNC(cmd1, NPU_SET_IFM2_STRIDE_C)                      \
                                                                SEP FUNC(cmd1, NPU_SET_WEIGHT1_BASE)                   \
                                                                    SEP FUNC(cmd1, NPU_SET_WEIGHT1_LENGTH)             \
                                                                        SEP FUNC(cmd1, NPU_SET_SCALE1_BASE)            \
                                                                            SEP FUNC(cmd1, NPU_SET_SCALE1_LENGTH)

#define EXPAND_DATA_FORMAT(FUNC, SEP) FUNC(data_format, NHWC) SEP FUNC(data_format, NHCWB16)

#define EXPAND_ELEMENTWISE_MODE(FUNC, SEP)                                                                             \
    FUNC(elementwise_mode, MUL)                                                                                        \
    SEP FUNC(elementwise_mode, ADD) SEP FUNC(elementwise_mode, SUB) SEP FUNC(elementwise_mode, MIN)                    \
        SEP FUNC(elementwise_mode, MAX) SEP FUNC(elementwise_mode, LRELU) SEP FUNC(elementwise_mode, ABS)              \
            SEP FUNC(elementwise_mode, CLZ) SEP FUNC(elementwise_mode, SHR) SEP FUNC(elementwise_mode, SHL)

#define EXPAND_IFM_PRECISION(FUNC, SEP)                                                                                \
    FUNC(ifm_precision, W8_U8)                                                                                         \
    SEP FUNC(ifm_precision, W8_S8) SEP FUNC(ifm_precision, W8_U16) SEP FUNC(ifm_precision, W8_S16)                     \
        SEP FUNC(ifm_precision, W8_S32)

#define EXPAND_IFM_SCALE_MODE(FUNC, SEP)                                                                               \
    FUNC(ifm_scale_mode, SCALE_16BIT)                                                                                  \
    SEP FUNC(ifm_scale_mode, SCALE_OPA_32BIT) SEP FUNC(ifm_scale_mode, SCALE_OPB_32BIT)

#define EXPAND_MEMORY_TYPE(FUNC, SEP)                                                                                  \
    FUNC(memory_type, AXI0_OUTSTANDING_COUNTER0)                                                                       \
    SEP FUNC(memory_type, AXI0_OUTSTANDING_COUNTER1) SEP FUNC(memory_type, AXI1_OUTSTANDING_COUNTER2)                  \
        SEP FUNC(memory_type, AXI1_OUTSTANDING_COUNTER3)

#define EXPAND_OFM_PRECISION(FUNC, SEP)                                                                                \
    FUNC(ofm_precision, U8)                                                                                            \
    SEP FUNC(ofm_precision, S8) SEP FUNC(ofm_precision, U16) SEP FUNC(ofm_precision, S16) SEP FUNC(ofm_precision, S32)

#define EXPAND_PMU_EVENT_TYPE(FUNC, SEP)                                                                                  \
    FUNC(pmu_event_type, CYCLE)                                                                                           \
    SEP FUNC(pmu_event_type, NPU_IDLE) SEP FUNC(pmu_event_type, MAC_ACTIVE) SEP FUNC(                                     \
        pmu_event_type, MAC_ACTIVE_8BIT) SEP FUNC(pmu_event_type, MAC_ACTIVE_16BIT) SEP FUNC(pmu_event_type,              \
                                                                                             MAC_DPU_ACTIVE)              \
        SEP FUNC(pmu_event_type, MAC_STALLED_BY_WD_ACC) SEP FUNC(pmu_event_type, MAC_STALLED_BY_WD) SEP FUNC(             \
            pmu_event_type, MAC_STALLED_BY_ACC) SEP FUNC(pmu_event_type, MAC_STALLED_BY_IB) SEP FUNC(pmu_event_type,      \
                                                                                                     AO_ACTIVE)           \
            SEP FUNC(pmu_event_type, AO_ACTIVE_8BIT) SEP FUNC(pmu_event_type, AO_ACTIVE_16BIT) SEP FUNC(                  \
                pmu_event_type, AO_STALLED_BY_OFMP_OB) SEP FUNC(pmu_event_type, AO_STALLED_BY_OFMP)                       \
                SEP FUNC(pmu_event_type, AO_STALLED_BY_OB) SEP FUNC(pmu_event_type, AO_STALLED_BY_ACC_IB) SEP FUNC(       \
                    pmu_event_type, AO_STALLED_BY_ACC) SEP FUNC(pmu_event_type, AO_STALLED_BY_IB)                         \
                    SEP FUNC(pmu_event_type, WD_ACTIVE) SEP FUNC(pmu_event_type, WD_STALLED) SEP FUNC(                    \
                        pmu_event_type, WD_STALLED_BY_WS) SEP FUNC(pmu_event_type, WD_STALLED_BY_WD_BUF)                  \
                        SEP FUNC(pmu_event_type, WD_PARSE_ACTIVE) SEP FUNC(pmu_event_type, WD_PARSE_STALLED) SEP FUNC(    \
                            pmu_event_type, WD_PARSE_STALLED_IN) SEP FUNC(pmu_event_type, WD_PARSE_STALLED_OUT)           \
                            SEP FUNC(pmu_event_type, AXI0_RD_TRANS_ACCEPTED) SEP FUNC(                                    \
                                pmu_event_type, AXI0_RD_TRANS_COMPLETED) SEP FUNC(pmu_event_type,                         \
                                                                                  AXI0_RD_DATA_BEAT_RECEIVED)             \
                                SEP FUNC(pmu_event_type, AXI0_RD_TRAN_REQ_STALLED) SEP FUNC(                              \
                                    pmu_event_type,                                                                       \
                                    AXI0_WR_TRANS_ACCEPTED) SEP FUNC(pmu_event_type, AXI0_WR_TRANS_COMPLETED_M)           \
                                    SEP FUNC(                                                                             \
                                        pmu_event_type,                                                                   \
                                        AXI0_WR_TRANS_COMPLETED_S) SEP FUNC(pmu_event_type, AXI0_WR_DATA_BEAT_WRITTEN)    \
                                        SEP FUNC(pmu_event_type, AXI0_WR_TRAN_REQ_STALLED) SEP FUNC(                      \
                                            pmu_event_type,                                                               \
                                            AXI0_WR_DATA_BEAT_STALLED) SEP FUNC(pmu_event_type, AXI0_ENABLED_CYCLES)      \
                                            SEP FUNC(pmu_event_type, AXI0_RD_STALL_LIMIT) SEP FUNC(                       \
                                                pmu_event_type,                                                           \
                                                AXI0_WR_STALL_LIMIT) SEP FUNC(pmu_event_type, AXI1_RD_TRANS_ACCEPTED)     \
                                                SEP FUNC(pmu_event_type, AXI1_RD_TRANS_COMPLETED)                         \
                                                    SEP FUNC(pmu_event_type, AXI1_RD_DATA_BEAT_RECEIVED) SEP FUNC(        \
                                                        pmu_event_type,                                                   \
                                                        AXI1_RD_TRAN_REQ_STALLED) SEP FUNC(pmu_event_type,                \
                                                                                           AXI1_WR_TRANS_ACCEPTED)        \
                                                        SEP FUNC(pmu_event_type, AXI1_WR_TRANS_COMPLETED_M) SEP FUNC(     \
                                                            pmu_event_type,                                               \
                                                            AXI1_WR_TRANS_COMPLETED_S) SEP                                \
                                                            FUNC(pmu_event_type, AXI1_WR_DATA_BEAT_WRITTEN) SEP FUNC(     \
                                                                pmu_event_type,                                           \
                                                                AXI1_WR_TRAN_REQ_STALLED) SEP                             \
                                                                FUNC(pmu_event_type, AXI1_WR_DATA_BEAT_STALLED) SEP FUNC( \
                                                                    pmu_event_type,                                       \
                                                                    AXI1_ENABLED_CYCLES) SEP                              \
                                                                    FUNC(pmu_event_type, AXI1_RD_STALL_LIMIT) SEP FUNC(   \
                                                                        pmu_event_type,                                   \
                                                                        AXI1_WR_STALL_LIMIT) SEP FUNC(pmu_event_type,     \
                                                                                                      AXI_LATENCY_ANY)    \
                                                                        SEP FUNC(pmu_event_type, AXI_LATENCY_32)          \
                                                                            SEP FUNC(pmu_event_type, AXI_LATENCY_64)      \
                                                                                SEP FUNC(pmu_event_type,                  \
                                                                                         AXI_LATENCY_128)                 \
                                                                                    SEP FUNC(pmu_event_type,              \
                                                                                             AXI_LATENCY_256)             \
                                                                                        SEP FUNC(pmu_event_type,          \
                                                                                                 AXI_LATENCY_512)         \
                                                                                            SEP FUNC(pmu_event_type,      \
                                                                                                     AXI_LATENCY_1024)

#define EXPAND_POOLING_MODE(FUNC, SEP)                                                                                 \
    FUNC(pooling_mode, MAX) SEP FUNC(pooling_mode, AVERAGE) SEP FUNC(pooling_mode, REDUCE_SUM)

#define EXPAND_PRIVILEGE_LEVEL(FUNC, SEP) FUNC(privilege_level, USER) SEP FUNC(privilege_level, PRIVILEGED)

#define EXPAND_PRODUCT(FUNC, SEP) FUNC(product, ETHOS_U55)

#define EXPAND_RESAMPLING_MODE(FUNC, SEP)                                                                              \
    FUNC(resampling_mode, NONE) SEP FUNC(resampling_mode, NEAREST) SEP FUNC(resampling_mode, TRANSPOSE)

#define EXPAND_ROUNDING(FUNC, SEP) FUNC(rounding, TFL) SEP FUNC(rounding, TRUNCATE) SEP FUNC(rounding, NATURAL)

#define EXPAND_SECURITY_LEVEL(FUNC, SEP) FUNC(security_level, SECURE) SEP FUNC(security_level, NON_SECURE)

#define EXPAND_STATE(FUNC, SEP) FUNC(state, STOPPED) SEP FUNC(state, RUNNING)

#define EXPAND_STRIDE_MODE(FUNC, SEP)                                                                                  \
    FUNC(stride_mode, STRIDE_MODE_1D) SEP FUNC(stride_mode, STRIDE_MODE_2D) SEP FUNC(stride_mode, STRIDE_MODE_3D)
